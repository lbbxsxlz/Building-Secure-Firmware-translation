## 第八章

# 设备安全

硬件设备是解决方案的重要组成部分。它和板上的其他设备是平台的一部分，例如可信平台模块（TPM）设备、底板管理控制器（BMC）、电源提供单元（PSU）等等。也可以是独立的设备，例如通用串行总线（USB）设备、图形卡设备、网卡设备、硬盘设备等等。

## 设备固件弹性

《高度安全设备的七大特性》介绍了如下的设计原则：

    1. 基于硬件的信任根
    2. 小型可信计算基础
    3. 纵深防御
    4. 区隔化
    5. 基于证书的认证
    6. 可再生安全
    7. 故障报告

原则3，4与通用安全软件设计原则类似。原则1，2，5，6，7与硬件/固件弹性有关。设备固件弹性应该遵循和主机固件弹性相同的规则。保护、检测和恢复都应该考虑。第3，4，5章已经对此进行了讨论。

## 安全设备通信

在系统启动过程中，主机需要与设备通信以交换信息。这种通信通道可能会受到硬件对手的攻击。攻击机制可能包括但不限于拦截、修改、窃听和伪装。

### 认证与测量

与主机固件类似，平台可能希望定义一种为设备执行证明的方法，而不仅仅是支持设备固件的弹性。这包括设备硬件身份认证和设备固件身份测量。

图8-1举例说明了如何使用非对称加密技术来实现这一目标。每台设备都配有一个证书。证书的公共部分通过平台活动信任根（PA-RoT）被知晓。证书的私有部分作为秘密保存在设备不可改变的ROM中，作为活动组件信任根（AC-RoT）。在系统启动过程中，平台信任根作为发起者发送消息给设备信任根（回应者），设备发送回应。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-1.jpg></img></div>
<div align=center>图 8-1 设备认证与测量流程</div>

在识别阶段，平台信任根请求设备证书，设备信任根返回设备的公共证书。然后，平台信任根可以知道哪个设备在平台上。

接下来，在认证阶段，平台信任根会向设备信任根发送一个质疑消息，设备信任根用其私人证书加密质疑值作为回应。有了质疑/响应，平台信任根就可以知道设备是真实的。

最后，在测量阶段，平台信任根请求设备的测量值，包括不可改变ROM、可变固件、硬件配置和固件配置的测量值。一旦设备信任根返回这些信息，平台信任根可将这些信息保存到TPM设备（用于存储和报告的信任根）中，以便进一步进行平台证明。

### 安全通信通道

一旦平台信任根认证设备后，可能需要交换信息。平台信任根信任设备，但平台信任根可能不信任它们之间的链接。攻击者可能会劫持硬件总线来攻击平台信任根和设备之间的链接。平台主板上的连接类似于今天的互联网 —— 两个端点需要在不受信任的世界中创建一个安全通道。互联网中最著名的安全通道是传输层安全（TLS）。TLS可以在握手阶段提供身份认证，在应用阶段提供保密性和完整性。最初的TLS是在面向连接的协议（例如传输控制协议）之上的一个协议。TLS概念也可用于其他协议，例如可扩展身份认证协议（EAP）。TLS的变种 —— 数据报TLS（DTLS）—— 可用于无连接协议，例如用户数据报协议（UDP）。

安全通道可以包括三个阶段：握手、应用和终止（见图8-2）。在握手阶段，发起者和响应者需要交换密钥和加密参数，并进行身份认证。在握手阶段结束时，发起者和响应者都能计算出一组会话密钥，用于加密消息和计算信息的信息认证码（MAC）。在应用阶段，发起方和响应方可交换应用层信息，这些信息由会话密钥加密，并由会话MAC密钥MAC化。通信结束后，会话即被关闭。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-2.jpg></img></div>
<div align=center>图 8-2 设备安全通信</div>

### 设备标识符组合引擎（DICE）

我们已经在第七章讨论过DICE。在这，活动组件信任根（AC-RoT）可以是DICE设备。每个DICE设备包括唯一的设备秘密（UDS），DICE核心基于UDS生成DICE证书。这DICE证书可以用来作为设备标识。第7章的图7-9显示了DICE证书的生成过程。

### 案例研究

现在，让我们来看一下安全设备通信的一些实例。

#### 安全协议与数据模型（SPDM）

分布式管理任务组（DMTF）平台管理组件交互工作组发布了 "安全协议和数据模型（SPDM）规范"，来定义两个实体之间的消息传递，包括如何交换设备认证和设备测量信息。表8-1列出了SPDM 1.0规范中定义的命令。通过这些命令，主机可对设备进行认证，并将设备测量延伸到TPM PCR中。

表 8-1 认证和测量的SPDM 1.0命令列表
| 命令/应答 | 类型 | 描述 | 
| :--- | :--- | :--- |
| GET_VERSION/VERSION | 能力发现与协商 | 接收一个端点的SPDM版本 |
| GET_CAPABILITIES/CAPABILITIES | 能力发现与协商 | 接收一个端点的安全能力 |
| NEGOTIATE_ALGORITHMS/ALGORITHMS | 能力发现与协商 | 协商加密算法 |
| GET_DIGEST/DIGEST | 硬件标识认证 | 接收证书链摘要 |
| GET_CERTIFICATE/CERTIFICATE | 硬件标识认证 | 接收证书链 |
| CHALLENGE/CHALLENGE_AUTH | 硬件标识认证 | 通过质疑-应答协议认证一个端点 |
| GET_MEASUREMENTS/MEASUREMENTS | 固件测量值 | 接收固件测量值 |

TLS是在互联网上提供安全通道的优秀协议。不过对于平台板上的链接来说可能过于复杂。因此，SPDM 1.1规范为平台上的安全通信通道添加了一些特殊命令。这些命令以简化的方式模拟TLS 1.3，假定传输层提供了数据传输和接收的可靠性，并且数据的传输是有序的，或者数据的顺序可以在接收时重建。见表8-2。在握手阶段，两个实体可以使用基于证书的非对称密钥会话创建或基于预共享密钥（PSK）的会话创建。由于嵌入式设备可能处于资源有限的环境中，因此PSK可用于那些不支持非对称密钥加密或证书处理的终端。在应用阶段，两个实体可以通过发送心跳消息或更新会话密钥消息来维护会话。一旦不再需要会话，两个实体就会使用“结束会话”消息关闭会话。

表 8-2 安全通信通道的SPDM 1.1命令列表 【1】
| 命令/应答 | 类型 | 描述 | 
| :--- | :--- | :--- |
| KET_EXCHANGE/KEY_EXCHANGE_RSP | 会话握手：基于非对称密钥会话创建 | 启动请求者与响应者之间的握手，认证响应者，协商加密参数（DH密钥交换），并且建立共享的密钥介质。|
| FINISH/FINISH_RSP | 会话握手：基于非对称密钥会话创建 | 完成请求者与响应者之间由KEY_EXCHANGE发起的握手。|
| PSK_EXCHANGE/PSK_EXCHANGE_RSP | 会话握手：基于对称密钥会话创建 | 允许请求者和响应者基于预先共享的密钥，使用对称密钥加密执行双向认证和会话密钥建立。|
| PSK_FINISH/PSK_FINISH_RSP | 会话握手：基于对称密钥会话创建 | 告知响应者请求者知悉PSK并且已经衍生出正确的会话密钥。|
| HEARTBEAT/HEARTBEAT_ACK | 会话应用：会话维护 | 保持会话活跃。|
| KEY_UPDATE/KEY_UPDATE_ACK | 会话应用：会话维护 | 更新会话密钥，尤其当每条记录的nonce值即将到达最大值并翻转。|
| GET_ENCAPSULATED_REQUEST/ENCAPSULATED_REQEDST | 会话应用：由响应者发起的消息（潜在的双向认证）| 接收来自响应者的SPDM请求消息。|
| DELIVER_ENCAPSULATED_RESPONSE/ENCAPSULATED_RESPONSE_ACK | 对响应者的请求提供应答。|
| END_SESSION/END_SESSION_ACK | 会话应用：会话结束 | 结束会话。|

【1】 注：原文的命令与规范不符，已修正

SPDM 1.0只支持单向认证 —— 请求者认证响应者。SPDM 1.1的封装消息可用来双向认证。响应者能发送消息给请求者，例如GET_DIGEST/GET_CERTIFICATE甚至是CHALLENGE，来验证请求者的身份（标识）。

#### USB认证

SPDM定义了数据交换模型。SPDM消息能通过不同的硬件接口发送。USB组织发布了“USB认证规范”来描述在USB总线上如何为USB设备交换SPDM消息。

#### PCIe 组件测量与认证

SPDM消息也可以通过PCIe设备发送。Intel发布了“PCIe设备安全增强规范”作为一种方法。PCI-SIG通过“ECN —— 组件测量和认证（CMA）”和“ECN —— 数据对象交换（DOE）”规范扩充了该材料，来描述在PCI express总线上PCIe设备如何交换SPDM消息，并提供验证组件配置、固件/可执行文件（测量）和硬件身份（认证）的机制。

#### PCIe完整性和数据加密

PCI-SIG发布了“ECN —— 完整性和数据加密”规范来描述如何为两个端口之间收发的交易层报文（TLPs）提供机密性、完整性和重放保护。安全模型考虑了来自链路上的物理攻击威胁，包括对手使用实验室设备，专用的内插器，恶意的扩展设备等来审查试图保密的数据，修改TLP内容，重新排序或删除TLP。

IDE文档定义了IDE数据流，它是端口到端口的连接来保证两个端口间的TLP传输安全。IDE数据流有两类。选择性数据流是指IDE TLP流穿过交换机但不影响安全性，而链接IDE数据流是指两个端口必须连接，并且没有交换机介入。SPDM安全会话消息是用来建立IDE数据流和编程密钥。

其他硬件接口，例如计算机快速链接（CXL），也采用SPDM消息。

#### SPDM在管理组件传输协议（MCTP）上

DMTF组织定义了管理组件传输协议（MCTP）。它用于受管计算机系统平台管理子系统内智能设备之间的通信。例如，MCTP可用于管理控制器、智能管理设备、网络控制器和系统固件之间的通信。MTCP可通过SMBus/I2C、USB、PCIe厂商定义消息等传输。SPDM消息也可通过MTCP传输。因此，MCTP设备可以交换 SPDM消息。正如我们在第7章中所讨论的，Cerberus项目使用这种机制让平台主动信任根（PA-RoT）认证设备主动组件信任根（AC-RoT）。

#### EDK II设备安全性

EDK II项目正在为其UEFI BIOS实现增加设备固件安全功能。设备认证和测量活动与UEFI镜像认证和测量。见图8-3和图8-4。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-3.jpg></img></div>
<div align=center>图 8-3 EDK II设备认证</div>

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-4.jpg></img></div>
<div align=center>图 8-4 EDK II设备测量</div>

以PCI总线为例。PCI枚举过程发现设备后，PCI总线驱动程序会检查UEFI设备认证或测量是否启用。如果启用，PCI总线驱动程序就会利用平台策略来确定该设备是否需要认证或测量。这一步骤是保持兼容性所必需的，因为目前市场上只有数量有限的设备支持这一功能。如果平台策略要求对设备进行认证或测量，PCI总线驱动程序就会检查设备的功能，然后执行认证或测量。只有在设备认证通过并收集了测量结果后，PCI总线驱动程序才会允许启用或使用该设备。如果设备不具备所需的能力或认证失败，PCI总线会将其视为违反策略，并拒绝该设备。这里的"允许"表示PCI总线驱动程序为设备分配资源（MMIO、I/O、总线），并通过EFI_PCI_IO_PROTOCOL使其可被发现；"拒绝"表示PCI总线驱动程序不分配资源，也不安装EFI_PCI_IO_PROTOCOL。

可信计算小组（TCG）PC客户端工作组正在将设备固件测量纳入其"TCG PC Client平台固件概要文件规范"中。来描述如何收集设备测量值、如何将测量值延伸到TPM中，并将测量结果记录在事件日志中。

将所有相关组件放在一起，我们就得到了图8-5。NIST SP800-193提供了一般平台固件弹性指南。NIST SP800-155规范提供了一般平台完整性测量指南。主机CPU可通过PCIe或USB上的SPDM消息与设备通信，来进行认证和测量。设备的测量延伸到TPM，并创建相应的事件日志。独立平台信任根设备可与关键启动设备通信，通过SMBus或I2C上的MCTP发送SPDM消息来进行认证和测量。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-5.jpg></img></div>
<div align=center>图 8-5 平台设备安全总结</div>

### 攻击与缓解

现在，让我们看一下安全通信攻击的一些实例和缓解措施。

#### 安全策略配置攻击

在UEFI安全启动中，一种攻击方式就是禁用UEFI安全启动功能。这也可用于设备安全。启用/禁用设备认证或测量的平台策略应该是静态设置或者是需要用户实际确认的运行时设置。

设备认证中的设备签名数据库与UEFI安全启动中的镜像签名数据库类似。它是一个记录被允许的设备证书和被禁止的设备证书的数据库。该数据库保存在UEFI变量中，记录可以注册或撤销。当用户要更新设备签名数据库时，必须在实际用户存在的情况下签署或更新新的数据库。

设备选择是一个新的攻击面。由于设备认证是一个新概念，并非所有现有设备都支持它。平台可能会选择采用一种策略，只对某些设备而不是所有设备进行认证。因此，平台需要有一种方法来记录哪些设备需要进行认证，哪些设备可以不进行认证。如果将此信息保存为UEFI变量，则必须将其锁定，否则攻击者可能会直接更新设备选择配置来绕过认证流程。

#### 畸形的输入：SPDM响应

在设备认证前，我们不知道设备是好的还是恶意的。一个受损的设备或恶意设备可能会发送畸形的响应消息给发起者，包括畸形的头部，畸形的证书，畸形的签名，畸形的测量值等。见图8-6。这些攻击可能会引起发起者的软件缓冲溢出。当解析来自设备的响应时必须小心。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-6.jpg></img></div>
<div align=center>图 8-6 SPDM消息攻击面</div>

## 设备攻击预防

在建立安全通信之前，基本的不安全通信可能已经发生。因此，必须注意预防对设备的攻击。

### 设备标识符数据

设备认证和测量是新技术。现有设备可能不支持这些功能。因此，应该检查来自设备的所有信息，确保其格式正确。当主机软件发现一个新设备时，主机软件需要知道它是哪个设备、支持哪些功能以及是什么属性。这些信息通常在设备规范中定义，并以类型-长度-值（TLV）格式报告。然而，恶意设备并不遵循规范，可能会发送畸形的TLV数据，从而导致主机软件出现缓冲区溢出或其他基于解析的漏洞。

### 攻击和缓解

现在，让我们看一下设备标识符数据攻击的一些实例和缓解措施。

#### USB描述符攻击

USB描述符用于报告USB设备属性。USB规范定义了一组标准描述符，包括设备描述符、二进制设备对象存储（BOS）描述符、配置描述符、接口描述符和端点描述符。每个描述符开头的长度字段表示描述符的总大小。

如果软件只是按照USB规范中定义的结构为描述符数据结构分配缓冲区，恶意USB设备可能会提供一个非常大的长度字段值，导致软件缓冲区溢出（见图 8-7）。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-7.jpg></img></div>
<div align=center>图 8-7 USB描述符攻击</div>

#### 蓝牙广告攻击

蓝牙广告是蓝牙从设备向蓝牙主设备报告信息时发送的信息。广告数据（AD）以长度字段开头，然后是类型和数据。如果主机软件对AD结构做出假设，并仅根据长度字段复制数据，恶意蓝牙设备可能会使用较大的长度字段值注入不良的广告数据，从而导致主机软件缓冲区溢出（见图8-8）。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-8.jpg></img></div>
<div align=center>图 8-8 蓝牙广告数据攻击</div>

### 直接内存访问（DMA）

直接内存访问（DMA）是设备与主机通信的一种机制。经主机许可，设备可访问任何系统内存来交换信息，与主机CPU独立。在主机环境中，大多数架构都支持内存管理单元（MMU），为CPU提供虚拟地址/物理地址转换。对于设备，系统可使用I/O内存管理单元（IOMMU）来执行设备地址/物理地址转换。请参见图8-9。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-9.jpg></img></div>
<div align=center>图 8-9 MMU和IOMMU转换</div>

IOMMU是一项可选功能。没有IOMMU，系统可能会将设备地址视作内存物理地址处理。IOMMU提供两个功能：

    1）地址转换：将设备地址重新映射到不同的物理地址。例如，设备可能只支持32位设备地址，最大地址为4GiB。通过IOMMU，设备地址可被映射到高于4GiB的64位物理地址。如果系统没有大的连续物理地址，IOMMU可将连续设备地址映射到分片的物理地址。
    2）访问控制：IOMMU可以控制哪些设备可以读取或写入哪些系统内存。这对于防止恶意设备攻击系统内存非常重要。

有了MMU，页表将虚拟地址转换为物理地址。以图8-10为例，页表指针指向页目录的地址。CPU使用虚拟地址的上部分作为页目录的索引，来检索页表的地址。然后，CPU使用虚拟地址的中间部分作为页表索引来检索物理页地址，再加上虚拟地址的下部分作为物理页偏移量。这就是最终的物理地址。每个页表表项都有精确的权限控制，来确定页面是可读、可写还是可执行。在实际应用中，根据虚拟地址大小，页表的层数是灵活的。对于32位架构，可以是2或3级；对于64位架构，可以是4或5级。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-10.jpg></img></div>
<div align=center>图 8-10 MMU地址转换</div>

如果平台启用了管理程序，管理程序控制最终物理地址访问（见图 8-11）。现代虚拟化技术支持两种不同的转换表。一个转换表位于客户操作系统中。它由客户操作系统控制，将客户虚拟地址转换为客户物理地址。这个客户转换表与没有虚拟化的转换表相同。另一个转换表位于虚拟机监控器中。它由管理程序控制，将客户物理地址转换为主机物理地址。双层转换的优势在于可以在不同的域中实现不同的控制。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-11.jpg></img></div>
<div align=center>图 8-11 管理程序中的MMU地址转换</div>

IOMMMU的转换过程更复杂，因为IOMMU需要考虑更多：
    
    1）IOMMU引擎

一个平台可能有多个IOMMU引擎。每个IOMMU引擎管理一组PCI设备。在大多数情况下，每个PCI段都有自己的IOMMU引擎。在一个PCI段中，也可能有多个IOMMU引擎。例如，在X86客户机系统上，图形控制器可能有一个专用的IOMMU引擎。所有其他PCI设备则由另一个IOMMU引擎管理。这是由硬件设计决定的。平台需要在IOMMU ACPI表中报告PCI设备范围信息。对于非PCI系统，每个设备都有一个唯一的ID，ID也会在IOMMU ACPI表中报告。每个IOMMU引擎都有一个设备表基址。

    2） 设备源标识符

每个设备都应有自己的转换表。两台设备可以参考相同的设备地址，但IOMMU应有能力为两台设备设置不同的物理地址。在IOMMU中，设备源标识符用于识别设备。PCI设备可通过段号、总线号、设备号和功能号来识别（见图8-12）。如果每个段都有自己的IOMMU引擎，则总线/设备/功能编号可用作该段中当前设备的设备源标识符。整个源标识符为16位，包括8位总线号、5位设备号和3位功能号。尽管这是为PCI设备设计的，但非PCI设备也有标识符号。IOMMU使用设备标识符作为设备表的索引，来检索转换表或进程地址空间ID（PASID）表。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-12.jpg></img></div>
<div align=center>图 8-12 设备源标识符</div>

    3） 进程地址空间ID（PASID）

PASID是PCI Express规范中定义的一项功能。有了PASID，一个设备可被多个进程共享，并为每个进程提供完整的64位虚拟地址空间。PASID的实现要求PCIe事务层数据包（TLP）的前缀包含20位PASID，并将其添加到内存事务TLP中。如果系统支持PASID，设备表中的地址就是PASID表地址。IOMMU使用PASID作为 PASID表的索引来检索转换表的地址。非PCI系统也有类似的概念。每个进程都可以使用一个唯一的ID来表示自己的转换表。

    4）嵌套转换表

每个设备都有一个独一无二的转换表。转换表的数据结构与MMU中的数据结构类似。设备地址的上部分用作查找下一级页表的索引。IOMMU使用叶子页表的地址作为最终物理页面地址，再加上设备地址的下部分作为最终物理页面偏移量。

在管理程序环境中，IOMMU引擎可以选择使用两个转换表。这种可选功能称为嵌套转换。为客户操作系统设置的一个客户机转换表将设备地址转换为客户机物理地址。然后，为管理程序设置的另一个主机转换表将客户机物理地址翻译为主机物理地址。IOMMU中这种双层转换的优势在于，它与当前大多数管理程序中的当前虚拟化设计相一致，即不同的域有不同的控制。

与MMU类似，每个页表项都有精确的权限控制，来确定页面是否可读、可写、可执行或甚至不存在。如果设备访问违反了转换表中预定义的策略控制，访问将被拒绝，IOMMU引擎将产生错误。

图8-13展示了全部的IOMMU地址转换流程。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-13.jpg></img></div>
<div align=center>图 8-13 IOMMU地址转换</div>

### 案例研究

现在，让我们看一下DMA保护的一些实例。

#### 英特尔VT-d

英特尔定向I/O虚拟化技术（VT-d）是IOMMU的一种实现。它支持DMA地址转换功能。VT-d引擎使用两级设备表。每个VT-d引擎只有一个根表（root table）。当进行地址转换时，VT-d使用高8位（总线编号）作为根表的索引，来检索上下文表的地址。然后，VT-d将低8位（设备编号和功能编号）作为上下文表的索引，来检索下一个转换表的地址。它可以是PASID表或在不支持PASID下是设备转换表。

如果系统支持PASID，则上下文表中的地址就是PASID目录。如果设备发送带有20位PASID的内存访问请求，VT-d将PASID[19:6]作为PASID目录的索引来检索PASID表的地址。然后，VT-d将PASID[5:0]作为PASID表的索引来检索设备转换表的地址。

VT-d支持嵌套转换。客户机转换表称为一级转换表。主机转换表称为二级转换表。转换表的两个地址都包含在PASID表项中。一级转换表和二级转换表的结构与其他页表类似。VT-d引擎使用地址的高位作为索引来检索下一级页表，直到包含最终物理页地址的叶子页。

图8-14显示了使用VT-d的地址转换。更多详细信息请参考英特尔VT-d规范。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-14.jpg></img></div>
<div align=center>图 8-14 英特尔VT-d地址转换</div>

通常，DMA访问可以通过两种方式阻止：转换和排除。除了转换页表之外，VT-d还包括两组寄存器以提供DMA排除。该寄存器被称为受保护的内存寄存器（PMR）。一个寄存器组低于4GB ——受保护的低内存寄存器（PLMR）。另一个是高于4GB ——受保护高内存寄存器（PHMR）。PMR覆盖的区域是不具有DMA功能的区域（见图8-15）。这种DMA排除机制在简单且资源受限的环境中是有用的，例如系统固件或认证代码模块（ACM）中的早期启动阶段。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-15.jpg></img></div>
<div align=center>图 8-15 英特尔VT-d PMR</div>

#### AMD I/O虚拟化

AMD IOMMU具有DMA转换能力，但使用不同的数据结构。IOMMU引擎可以有多个设备表段。每个设备表只是一个一级表。支持嵌套转换。每个设备表表项包括两个转换表地址：客户机CR3（GCR3）表和主机页表。客户机CR3表用于PASID转换，它可以是多级的。IOMMU使用PASID作为索引来检索最终客户机CR3级别1表中的客户机页表地址。然后IOMMU使用客户机页表客户机设备地址转换为客户机物理地址，并使用主机页表将客户机物理地址转换为系统物理地址。

除了DMA转换，AMD还通过DMA排除 ——设备排除矢量（DEV）支持了DMA保护。DEV表是物理存储器中一个连续比特位阵列，每个比特对应一个4K页。

图8-16显示了AMD IOMMU的地址转换。更多详细信息，请参考AMD IOMMU规范。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-16.jpg></img></div>
<div align=center>图 8-16 AMD IOMMU地址转换</div>

#### ARM System MMU

ARM系统使用系统内存管理单元（SMMU）进行DMA重映射。由于大多数ARM系统不支持PCI设备，故使用StreamID作为设备标识符，并使用SubStreamID作为PASID。StreamID命名空间是基于SMMU的。不同的SMMU后的设备可能被分配相同的StreamID。一个设备可能会以不止一个StreamID发送流量，这表示数据流是按设备特定状态区分的。SubStreamID用于区分来自同一逻辑块的流量来源，以便为每个流量关联不同的应用地址转换。每个SMMU都有一个数据流表。SMMU使用StreamID作为索引，从数据流表中获取数据流表项（STE）。数据流表项包括第一阶段上下文表（S1ContextPtr）的地址和第二阶段转换表（S2TTB）的地址。然后，SMMU使用SubStreamID作为索引，从第一阶段上下文表中获取上下文描述符（CD）。上下文描述符包括第一阶段转换表（TTB0/TTB1）的地址。第1阶段和第2阶段转换表如我们之前讨论的那样支持嵌套转换。阶段1转换表将客户机虚拟地址转换为中间物理地址，阶段2转换表将中间物理地址转换为最终物理地址。

图8-17显示了使用ARM SMMU的地址转换。更多细节信息请参考ARM SMMU规范。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-17.jpg></img></div>
<div align=center>图 8-17 ARM SMMU地址转换</div>

#### EDK II IOMMU支持

EDK II为系统固件实现了一个IOMMU协议（见图8-18）。IOMMU协议对IOMMU访问进行了抽象。典型的IOMMU驱动程序包括以下四个组件：

1) IOMMU ACPI表解析器：平台通过ACPI表报告IOMMU的存在。与平台无关的IOMMU驱动程序会解析ACPI表，确定IOMMU的位置和受IOMMU管理的设备。
2) IOMMU引擎管理器：该驱动程序需要控制IOMMU，包括启用、禁用和刷新转换表。
3) 转换表管理器：驱动程序也需要根据设备的请求更新转换表。默认情况下，IOMMU初始化后，任何内存都不支持DMA。当设备请求DMA缓冲区时，IOMMU驱动程序允许在IOMMU的转换表中进行DMA访问。一旦DMA缓冲区被释放，IOMMU驱动程序需要撤销IOMMU转换表中的访问权限。
4) IOMMU协议服务：驱动程序提供一个软件接口，以便其他设备驱动程序提交DMA请求。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-18.jpg></img></div>
<div align=center>图 8-18 EDK II中基于IOMMU的DMA保护</div>

提交DMA请求的设备可以是使用EFI_PCI_IO_PROTOCOL的PCI设备。它也可以是低功耗子系统（LPSS）ACPI设备，如通用异步接收器/发送器（UART），或通过串行外设接口（SPI）或内部集成电路（I2C）总线或安全数字输入输出（SDIO）总线连接的设备。这些设备使用设备特定的I/O接口。以图8-19中的PCI驱动程序为例。这里，PCI驱动程序使用AllocateBuffer/FreeBuffer来管理用于读取和写入的通用DMA缓冲区，或者分配系统内存，然后使用Map/Unmap将其用作读取DMA缓冲区或写入DMA缓冲区。所有这些操作都与IOMMU驱动程序挂钩。IOMMU驱动程序
在AllocateBuffer/FreeBuffer/Map/Unmap函数中分配DMA缓冲区。随后，PCI驱动程序使用IOMMU协议中的SetAttributes函数通知IOMMU 驱动程序访问权限，并修改DMA转换表中的访问权限。转换表是基于设备的，因此IOMMU驱动程序能通过设备句柄识别设备。IOMMU转换表是为细粒度保护而设置的。由于IOMMU驱动程序可通过UEFI设备句柄识别设备，因此每个设备都将分配一个转换表。

<div align=center><img src=Figures/Chapter-8-Screenshot/Figure-8-18.jpg></img></div>
<div align=center>图 8-18 EDK II中IOMMU钩子</div>

