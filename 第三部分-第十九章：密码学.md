## 第十九章

# 密码学

当实现固件并添加安全功能时，例如固件镜像验证和固件证明，我们需要运用密码学来保护系统。经典密码学可追溯至罗马帝国时期人们使用的凯撒密码，其发展历程终结于第二次世界大战 —— 当时德国人使用恩尼格玛密码机加密信息，而英国密码学家最终通过“炸弹”（一种机电设备）破译了该密码机。经典密码的两种类型是替换密码和置换密码。然而，大多数经典密码均可通过手工计算破解，更可被现代计算机与通信技术攻破。20世纪70年代，人类正式迈入现代密码学时代。

1972年，美国国家标准局（NBS）征集可用于消息加密的标准化密码提案。最终，NBS于1977年发布了数据加密标准（DES）。这标志着重大变革，因为这是首次实现密码学算法的标准化。如今，NBS已更名为美国国家标准与技术研究院（NIST）。DES已不再安全，已被高级加密标准（AES）取代。众多密码学著作介绍了这些标准化加密算法及其背后的数学原理。本章将不深入探讨加密算法细节，而是聚焦于如何运用这些标准化加密算法来强化系统安全性。

## 现代密码学

现代密码学包含两大领域：对称算法和非对称算法。对称算法自经典密码学时代便已存在。在对称算法中，发送方和接收方使用相同的密钥加密和解密数据。见图19-1。

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-1.jpg></img></div>
<div align=center>图 19-1 对称密码学</div>

长期以来，这被视为加密与解密的唯一方法。转折点出现在1976年，Whitfield Diffie与Martin Hellman发表《密码学的新方向》，提出了公钥密码学，也称为非对称密码学。借助非对称密码学，我们不仅能实现数据加密，还能实现数字签名和密钥建立等更多功能。见图19-2、图19-3和图19-4。

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-2.jpg></img></div>
<div align=center>图 19-2 非对称密码学 —— 数据加密</div>

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-3.jpg></img></div>
<div align=center>图 19-3 非对称密码学 —— 数字签名</div>

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-1.jpg></img></div>
<div align=center>图 19-4 非对称密码学 —— 密钥建立</div>

### 固件中的密码学应用

固件可能同时包含对称算法和非对称算法。表19-1展示了固件中加密算法的使用情况。从该表可见，最常见的应用是数字签名验证，包括哈希算法。数字签名是验证固件镜像或数据完整性与真实性的手段。在第3、4、5章中，我们已探讨过安全启动、固件更新以及固件恢复。这些功能均需要签名验证。虽然镜像加密并非完整性考虑的强制要求，但作为机密性考虑的有效手段，它能保护知识产权（IP）并提升攻击门槛。在第七章，我们探讨了可信启动功能。该功能虽不验证数字签名，但扩展了镜像或数据的哈希值，作为防篡改空间的测量值，例如可信平台模块（TPM），以便后续进行本地或远程证明。

在第8章中，我们探讨了主机与设备固件通过安全协议与数据模型（SPDM）进行交互。SPDM 1.0的测量与认证需要哈希函数和数字签名验证。SPDM 1.1新增了基于消息认证码（MAC）的密钥交换能力以建立会话。随后双方可使用分组密码来加密通信数据。

在第10章中，我们探讨了用户认证功能与硬盘驱动器（HDD）密码功能。为支持密码验证，需将哈希值与盐值数据保存至UEFI变量。第11章，我们用UEFI变量为例，探讨了配置保护。UEFI认证变量更新需要签名验证以维护变量区域完整性。UEFI变量还可采用分组密码加密数据，并使用消息认证码（MAC）防止回滚攻击。

最后，固件可能包含网络栈。iSCSI启动机制在质疑-握手认证协议（CHAP）中采用哈希算法。HTTPs启动则需要传输层安全（TLS）支持。TLS握手包括数字签名验证、密钥交换和消息认证码（MAC）。一旦会话密钥生成后，TLS驱动程序使用分组密码或流密码加密通信。

表 19-1 固件中的密码学应用

|    功能    |  对称算法  |        |        |        |  非对称算法  |        |        |
| :----- | :----- | :----- | :----- | :----- | :----- | :----- | :----- |
|        |  分组密码  |   流密码   |    哈希     | 消息认证码 |  数字签名  | 数字签名验证 |  密钥交换  |
| 安全启动（镜像验证）|    |     | V |          |         |   V   |        |
| 固件更新 |        |        |   V   |        |        |   V   |        |
| 固件恢复 |        |        |   V   |        |        |   V   |        |
| 镜像加密 |   V   |        |        |        |        |        |        |
| 可信启动（测量）|        |        |   V   |        |        |        |        |
|  SPDM  |   V   |        |   V   |   V   |  (V)  |        |   V   |
| 用户认证 |        |        |   V   |        |        |        |        |
| HDD密码 |        |        |   V   |        |        |        |        |
| 认证变量更新 |        |        |   V   |        |        |   V   |        |
| 变量加密和回滚预防 |   V   |        |        |   V   |        |        |        |
| iSCSI启动 |        |        |   V   |        |        |        |        |
| HTTPs |   V   |        |   V   |   V   |  (V)  |   V   |   V   |

### 算法推荐

加密算法可来源于不同渠道，包括互联网工程任务组（IETF）、国际标准化组织（ISO）以及美国国家标准与技术研究院（NIST）的联邦信息处理标准（FIPS）。NIST还发布SP800系列文档，为加密算法的使用提供建议或指导。国家安全局（NSA）发布了商用国家安全算法（CNSA）套件用于推荐算法保护绝密信息。见表19-2。

表 19-2 密码学的算法推荐

|   功能   |        |   算法   | NIST推荐（NIST SP800-131A）| NSA推荐（NSACNSA）|
| :----- | :----- | :----- | :----- | :----- |
| 对称算法 | 分组密码 | AES | AES-128 | AES-256 |
|        |   哈希   | SHA256 | SHA384 |
| 非对称算法 | 数字签名 | RSA | RSA-2048 | RSA-3072 |
|        |        | ECDSA | P-256 | P-384 |
|        | 密钥建立 | RSA | RSA-2048 | RSA-3072 |
|        |        | DH | DH 2048bit | DH 3072bit |
|        |        | EC_DH | P-256 | P-384 |

### 一些概念

除了选择合适的算法外，我们还需要理解密码学中的基本概念，才能设计出适用于生产环境的解决方案。

#### Kerckhoffs原则

1883年，Kerckhoffs发表论文提出：系统的安全性应基于密钥而非算法。算法应当公开，密钥才是唯一的秘密。

如今，大多数密码学家认同Kerckhoffs原则。他们认为应公开算法并开源实现，以便更多人能参与审查并尽早发现漏洞。

另一方面，隐藏算法可能具有某些优势。由于敌人无法知晓设计原理，他们需要投入更多时间和资源才能攻破系统。

以固件为例，多数固件二进制文件虽具有写保护功能却未加密。一旦攻击者获取二进制文件，便可进行逆向工程分析。我们也观察到部分固件二进制文件是加密的。即使攻击者成功获取二进制文件，二进制分析也变得不可行。这种方式或许对知识产权保护具有价值，但同时也提高了攻击系统的门槛。

#### 随机数与一次性密码本

固件中可能需要随机数，例如密码哈希的盐值或TLS握手中的随机数。从根本上讲，生成随机数有两种方式：

1) 基于不可预测的物理源生成随机数，例如噪声：这被称为非确定性随机数生成器（NDRNG）或真随机数生成器（TRNG）。
2) 基于预定义算法生成随机数：称为确定性随机数生成器（DRNG）或伪随机数生成器（PRNG）。

由于TRNG速度较慢而PRNG相对快速，典型的实现会将二者结合使用。正如冯·诺伊曼所言：“任何考虑用算术方法生成随机数字的人，当然都处于罪恶状态。”因此，TRNG用于生成首个随机数作为种子，随后由PRNG生成其余随机数。见图19-5。

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-5.jpg></img></div>
<div align=center>图 19-5 随机数生成器</div>

随机数生成器可由软件或硬件来支持。NIST SP800-90对随机数生成提供了详细要求。伪随机数生成的软件实现应遵循NIST SP800-90建议，例如基于哈希的伪随机数生成器（PRNG）、基于HMAC的伪随机数生成器，或基于分组密码计数器模式（CTR）的伪随机数生成器（PRNG）。当前英特尔X86架构定义了两个随机数指令：RDSEED和RDRNG。RDSEED返回由加密安全的增强型非确定性随机比特生成器（NDRBG）提供的随机数。RDRAND返回由加密安全的确定性随机比特生成器（DRBG）提供的随机数。ARMv8.5架构也定义了RNDR和RNDRRS指令。在条件允许时，软件应优先使用硬件指令作为真随机数生成器（TRNG）。

随机数可用于一次性密码本（OTP）。一次性密码本是完美安全性或无条件安全性的典范。若实施得当则无法被破解。OTP的核心要点在于：1) 密钥由真随机数发生器生成；2) 密钥仅为发送方和接收方所知；3) 密钥必须仅使用一次；4) 密钥长度必须与消息长度一致。

然而，由于那些严格要求，该方案在多数场景中难以实施。一次性密钥的分发与存储对固件应用是个重大挑战。

#### 分组密码及其操作模式

分组密码可在固件中用于加密和解密两个实体之间的消息。在安全通信协议中需要使用分组密码，例如网络协议栈中的传输层安全协议（TLS）或设备通信中的安全协议与数据模型（SPDM）。

目前，美国国家标准与技术研究院（NIST）FIPS-197标准定义的高级加密标准（AES）是推荐的分组密码算法。分组密码具有多种操作模式，必须为数据加密选择正确的操作模式，否则解决方案可能存在漏洞。操作模式见表19-3。

表 19-3 分组密码操作模式

|   操作模式   |    描述    |   属性   |
| :----- | :----- | :----- |
| 确定性加密 |        |        |
| 电子密码本（ECB）模式 | 每个数据块都单独加密。相同的明文块将产生相同的密文块。| 它可以并行化。没有错误传播。|
| 概率加密 | | |
| 密文块链（CBC）模式 | 所有块的加密过程相互关联。加密过程通过初始化向量（IV）实现随机化。| 它支持并行化解密。错误传播。|
| 密文反馈（CFB）模式 | 它用于构建流密文加密方案。| 它支持并行解密。错误传播。|
| 输出返库（OFB）模式 | 它用于构建流密文加密方案。| 它不能并行化。没有错误传播。|
| 计数器（CTR）模式 | 它用于构建流密文加密方案。IV + counters作为初始化输入。 | 它可以并行化。没有错误传播。|
| 关联数据附带的认证加密 | | |
| Galois计数器模式（GCM）| 它提供数据的机密性和真实性。IV和附加关联数据（ADD）作为输入。| - |
| 带CBC-MAC的计算器（CCM）| 它提供数据的机密性和真实性。Nonce和附加关联数据（ADD）作为输入。| - |

NIST SP800-38为每种模式提供了详细建议。确定性加密存在弱点：相同的明文会产生相同的密文块，且无法检测有效明文的重新排序。

通常而言，若仅需机密性要求，应采用概率加密方法。概率加密中的随机性基于初始化向量（IV），每次加密时该向量必须随机。

若同时需要数据机密性和数据真实性，则需同时采用加密和消息认证码（MAC）。鉴于加密-消息认证码（E&M）、加密后消息认证码（EtM）及消息认证码后加密（MtE）模式均存在问题，普遍建议采用现有标准认证关联数据附带加密（AEAD）算法，例如GCM或ChaCha20Poly1305。

不同模式可能需要不同输入。初始化向量（IV）必须以随机方式均匀生成；一次性使用数字（nonce）必须不可重复且不可预测；计数器（counter）在每条消息中递增且具有可预测性。从语义上讲，IV与nonce不同。若IV不是均匀性随机，解决方案可能存在漏洞。

#### 数字签名和签名方案

数字签名可能是固件中应用最广泛的密码学技术。NIST SP800-193标准要求固件弹性，其更新保护与检测功能均依赖于数字签名。

NIST FIPS-186描述了批准使用的数字签名标准，包括RSA（Rivest-Shamir-Adleman）、椭圆曲线数字签名算法（ECDSA）以及Edwards曲线数字签名算法（EdDSA）。

与分组密码加密类似，数字签名可分为确定性与概率性两类。表19-4展示了三种实例：RSA、ECDSA和EdDSA。

表 19-4 数字签名方案

|   签名方案   |    描述    |   属性   |
| :----- | :----- | :----- |
| 确定性签名 | | |
| RSASSA-PKCS1-v1_5 | 签名是包含哈希和算法IP的编码消息。| 快 |
| 确定性ECDSA | Weierstrass曲线。每条消息的秘密数值(k)由待签名的消息和私钥派生生成。K参与签名生成。| 较小的密钥长度 |
| EdDSA | 扭曲的Edwards曲线。一种不同的模型。在签名生成过程中，使用由私钥和消息的哈希值计算出的唯一值。| 比ECDSA更快更简单 |
| 概率性的签名 | | |
| RSASSA概率性签名方案（RSASSA-PSS）| 涉及一个随机盐值。签名是通过哈希和盐值对消息进行编码。| 快 |
| ECDSA | Weierstrass曲线。每条消息的密钥数值(k)是随机的。k参与签名生成过程。| 较小的密钥长度 |

通常而言，RSA签名方法比ECDSA更快。对于RSA，签名方案包含对消息的填充。由于填充的存在，最终签名可能是确定性的或非确定性的。RSASSA-PKCS1-v1_5是确定性的，即相同的明文会产生相同的签名。RSASSA概率性签名方案（RSASSA-PSS）在签名中添加随机盐值。因此相同明文将产生不同签名。当前推荐使用RSASSA-PSS方案。该方案中盐值长度介于0与哈希长度之间，实际应用中建议盐值长度与哈希长度一致。

设备通常采用ECDSA算法，因为其密钥长度较短。若设备具备生成每条消息对应随机数的能力，则应使用ECDSA。对于缺乏优质随机数源的设备，采用确定性ECDSA可能更为理想。每条消息的秘密数值由消息内容与私钥共同派生，因此最终签名结果具有确定性。

Edwards曲线在椭圆曲线计算中表现优异，并能抵御侧信道攻击，因为实现Edwards曲线时更易编写无分支、恒定时间的代码。然而，实现确定性签名时需格外谨慎，EdDSA计算中私钥的保密性至关重要。

RSA也可用于接收方公钥加密。表19-5展示了加密方案。

表 19-5 非对称加密方案

|   加密方案   |    描述    |   属性   |
| :----- | :----- | :----- |
| 概率性的方案 | | |
| RSAES-PKCS1-v1_5 | 加密消息中包含随机字节。| 已知缺陷 |
| RSAES最优非对称加密填充（RSAES-OAEP）| 加密消息中包含随机字节。可选标签(L)具有关联性，该标签在加密和解密均需要。| 推荐 |

与对称认证加密类似，某些解决方案可能需要非对称加密和签名。简单的非对称签名加密机制与对称加密具有不同的安全特性。从发送者角度看，两者相同：发送者确信 1) 接收者知晓创作者，且 2) 仅接收者能解密消息。但从接收者角度看，两者存在差异：接收对称加密消息的对象能知晓发送者身份。而简单非对称签名加密消息的收件人仅知晓创作者，却无法确认加密者身份。这种简单签名加密方案的漏洞被称为“隐蔽转发”。解决此问题的方案包括：1) 添加发件人及/或收件人姓名；2) 采用签名-加密-签名流程；3) 采用加密-签名-加密流程。

RFC 8017定义了加密方案（RSAES-OAEP与RSAES-PKCS1-v1_5）及签名方案（RSASSA-PSS与RSASSA-PKCS1-v1_5）。

#### 密钥建立和转发保密

密钥交换可在固件中用于在两个实体间交换预主密钥或共享密钥。这个在安全通信握手过程中是必要环节，例如网络协议栈中的传输层安全协议（TLS）或设备通信中的安全协议与数据模型（SPDM）。

从密码学角度而言，密钥建立过程可采用对称算法。例如，可设立可信密钥分发中心（KDC）向每位用户分发密钥。该密钥称为密钥加密密钥（KEK），用于加密会话密钥。但实际中，该解决方案存在诸多问题，例如初始化阶段需建立安全通道、单点故障并且缺乏转发安全性。因此，实际密钥建立应用多采用非对称算法。

NIST SP800-56标准为基于离散对数算法的密钥建立提供了推荐方案，例如Diffie-Hellman（DH）、椭圆曲线Diffie-Hellman（ECDH）等；同时涵盖基于整数分解的密钥建立方案，如RSA算法。

密钥建立过程中一项重要的安全保障是转发保密（FS）。转发保密意味着即使未来一方或双方的长期私钥遭到泄露，此前基于这些长期公钥/私钥对派生的会话密钥也不会受到影响。试想OpenSSL心脏出血漏洞这类安全缺陷。若启用转发保密，先前会话中的数据仍保持安全且无法被解密。转发保密仅提供保密性保护，不保障完整性。此外它仅能保护已建立的会话密钥，无法保护私钥本身。表19-6展示了启用与未启用转发保密时的密钥建立示例。

表 19-6 密钥建立

|   密钥建立   |    描述    |   属性   |
| :----- | :----- | :----- |
| 不带转发保密 | | |
| RSA | 客户端生成随机数(S)，并使用服务器公钥将其加密为C。服务器使用服务器私钥解密C。客户端和服务器均获得密钥S作为密钥。| 非常快 |
| 带转发保密 | | |
| DH Ephemeral（DHE）| 客户端生成随机数(a)，服务器生成随机数(b)，其中a和b将作为指数用于生成A和B。A和B被公开发布。客户端基于a和B生成密钥(S)，服务器基于b和A生成相同的密钥(S)。| 慢 |
| ECDH Ephemeral (ECDHE) | 与DHE类似，唯一的区别是随机数a和b用于椭圆曲线计算。| 比DHE快 |

若长期公钥/私钥对参与预主秘密生成，则不构成转发保密方案 —— 一旦长期密钥泄露，攻击者即可推算出秘密(S)。

转发保密中，临时密钥对（EK）作为随机数生成，其唯一用途是建立秘密(S)。长期公钥/私钥对绝不应参与秘密计算过程。

客户端/服务端长期公钥/私钥对对用户身份认证至关重要。若没有认证步骤，通信通道可能遭受中间人攻击。

若转发保密性需要，请确保选择支持生成临时密钥的正确密文套件。ECDHE比DHE高效。但若对方对椭圆曲线密码学（ECC）支持不足，则可改用DHE方案。

#### 哈希，消息认证码，和密钥派生

哈希是固件中的另一项常用功能。可信启动过程需要测量固件镜像和数据的哈希值，并写入可信平台模块（TPM）的平台配置寄存器（PCR），以此建立静态测量信任根（SRTM）。

哈希函数将任意长度的消息转换为固定长度的摘要。哈希函数的重要特性如下：
1) 原像抗性（或单向性）：已知X，容易计算Hash(X)，但已知Hash(X)，很难求解X。
2) 二次原像抗性（或弱碰撞抗性）：已知Hash(X)时，很难找到满足Hash(Y) == Hash(X)的Y。
3) 碰撞抗性（或强碰撞抗性）：难以同时找到满足Hash(X) == Hash(Y)的X和Y。

NIST在FIPS-184标准中定义了SHA2家族，并在FIPS-202文档中定义了SHA3家族。见表19-7。

表 19-7 哈希函数

|   哈希函数   |    描述    |   属性   |
| :----- | :----- | :----- |
| SHA2家族 | | |
| SHA224, SHA256 | 512位块大小，32位字长 | 如今使用中 |
| SHA384，SHA512 | 1024位块大小，64位字长 | 安全度更强 |
| SHA3家族 | | |
| SHA3224, SHA3256, SHA3384, SHA3512 | 基于KECCAK算法 | - |
| SHAKE128，SHAKE256 | 可扩展输出函数（XOF）| - |

SHA2是经典的哈希算法，至今仍被广泛使用。SHA3系列的核心是全新的KECCAK算法。SHA3还支持可扩展输出函数（XOF），这意味着哈希输出可扩展至任意所需长度。对于XOF函数，后缀128或256代表安全强度等级，而不是摘要长度。

哈希函数的两个典型应用是数字签名和消息认证码。消息认证码（MAC）又称密码学校验和。与哈希类似，MAC函数接受任意长度的消息并生成固定长度的认证标签。MAC可确保消息完整性和认证。MAC与数字签名的根本区别在于MAC不提供不可否认性。原因在于：MAC函数使用的密钥是两个实体共享的对称密钥，而数字签名函数使用的密钥是仅由发送方知晓的私钥。

MAC可基于哈希算法或分组密码实现，见表19-8。

表 19-8 消息认证码

|   MAC函数   |    描述    |   属性   |
| :----- | :----- | :----- |
| 基于哈希的MAC | | |
| 基于哈希的MAC (HMAC) | 基于已经批准的哈希算法。| 快 |
| KECCAK MAC (KMAC) | 基于SHA3 KECCAK。| - |
| 分组密码 - 基于MAC | | |
| 分组密码链MAC (CBC-MAC) | 基于已经批准的分组密码算法。| 已知不足 |
| CMAC | 这是CBC-MAC的增强版本。它是一键式CBC-MAC1（OMAC1）。| 替代CBC-MAC |
| Galois计数器MAC (GMAC) | 这是Galois计数模式（GCM）的变体，其中数据不加密。| - |

NIST FIPS-198定义了HMAC，NIST SP800-38B和SP800-38D则为CMAC和GMAC提供了建议。

若需生成认证码，则必须采用MAC函数。由于秘密前缀MAC与秘密后缀MAC方案存在已知缺陷，普遍建议是直接采用现有标准MAC函数，例如HMAC、KMAC或CMAC。

除了消息完整性与身份验证外，HMAC的重要用途之一是协助派生密钥。这可能是固件中的应用场景。固件可能包含基于密码的用户认证，并利用密码生成密钥来保护用户数据；或者固件可能从硬件引擎获取主密钥，进而派生密钥以保护平台数据。

RFC 8018 PKCS#5定义了基于密码的密钥派生函数（PBKDF）。通常密码选自相对有限的空间，无法直接用来作加密密钥。我们需要密钥派生函数将密码转换为密钥。首先需添加随机盐值以抵御密码彩虹表攻击，使攻击者预先构建的哈希表失效。盐值长度应与KDF中选定的摘要长度一致。其次需设置迭代次数以增加暴力破解耗时，最小迭代次数为1000次。

RFC 5869定义了一种基于HMAC的提取与扩展密钥派生函数（HKDF）。HKDF的典型用途是从密钥建立过程中的主共享密钥中派生会话密钥，或从根密钥中派生子密钥。HKDF包含两个阶段：HKDF_Extract和HKDF_Expand。HKDF_Extract添加随机盐值派生伪随机密钥（PRK）。HKDF_Expand添加固定上下文信息派生最终输出密钥。解决方案可选择包含两个阶段，或仅采用HKDF_Expand以确定性方式派生密钥。

HKDF禁止用来从用户密码派生密钥，因为其未包含迭代次数。对于密码，应采用PBKDF，通过添加迭代计数来延缓字典攻击。密钥派生函数见表19-9。

表 19-9 密钥派生函数

|   密钥派生函数   |    描述    |   属性   |
| :----- | :----- | :----- |
| PKCS5 基于密码密钥派生函数2 (PBKDF2) | 输入：密码，随机盐值，迭代次数 输出：密钥 | 包含迭代次数。慢。|
| 基于HMAC提取与扩展派生函数（HKDF）| 两个阶段： 1) HKDF_Exact 输入：输入密钥材料（IKM），随机盐值 输出：伪随机密钥（PRK）2) HKDF_Expand 输入：PRK，上下文信息 输出：输出密钥材料（OKM）| |

#### 数字证书与证书链

在之前的章节中，我们介绍了数字签名。实体可生成公钥与私钥对，使用私钥对消息进行签名，并发布公钥供其他实体验证签名。实际应用中，单个公钥不足以描述实体的身份，我们还需要更多信息，例如密钥持有者的身份信息。为了整合这些信息，我们可以生成证书。

证书应包含有效期、主体信息（例如国家、组织、名称等）以及主体的公钥。类似于驾驶执照或护照，必须由可信机构签发证书。该签发方称为证书颁发机构（CA）。主体需创建包含上述所有信息的证书签名请求，并将其发送至CA。随后CA添加签发者信息，使用CA私钥作为签名密钥对证书进行签名，并附加密钥ID与签名。最终生成的即为主体的有效证书。公钥证书格式定义在X.509标准。图19-6展示了如何从公钥/私钥对生成证书的流程。

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-6.jpg></img></div>
<div align=center>图 19-6 X.509证书生成</div>

为验证主体证书的有效性，验证者可使用CA的公钥证书检查该证书的数字签名。由于CA本身始终是可信任的，其证书是自签证书。主体与签发者相同，此类证书称为根CA。实际应用中无法让根CA签发所有证书，因此根CA可先签发中间CA，再由中间CA完成后续签发工作。由此可创建证书链，见图19-7。

证书链创建完成后，验证过程需要额外步骤。验证者需查明证书的签发者——即中间CA——并基于中间CA的证书验证主体证书的有效性。随后验证者需确定中间CA证书的签发者——根CA——并基于根CA的证书验证中间CA证书的有效性。

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-7.jpg></img></div>
<div align=center>图 19-7 X.509证书链</div>

我们已创建主体证书和证书链。现在可以使用私钥对数据进行签名。RFC2315 PKCS#7定义了数字签名和数字信封的加密消息语法。签名者需在证书链中添加证书，并使用私钥作为签名密钥生成数字签名。最终的PKCS#7签名数据可能包含原始数据（作为内容信息）、证书以及签名者信息（例如签发者信息、签名时间）和签名本身。见图19-8。最终的PKCS#7签名可发送给接收方用于验证。请注意：若数据被排除并通过其他方式发送给接收方，则PKCS#7签名可能成为分离式签名。

接收方获取数据和PKCS#7签名后，可使用根CA证书验证整个PKCS#7签名。根CA证书用于验证证书链，签名者证书则用于验证数据。见图19-9。

如今X.509公钥证书格式在行业广泛应用，例如网络传输层安全协议（TLS）。PKCS#7作为签名加密消息语法同样应用广泛，例如可执行镜像签名。但并非唯一选择。例如，在物联网（IoT）环境中，业界正考虑采用简洁二进制对象表示法（CBOR）对象签名与加密（COSE）语法，以替代在X.509和PKCS#7中使用的复杂的ASN.1格式。

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-8.jpg></img></div>
<div align=center>图 19-8 PKCS#7 数字签名生成</div>

<div align=center><img src=Figures/Chapter-19-Screenshot/Figure-19-9.jpg></img></div>
<div align=center>图 19-9 PKCS#7 数字签名验证 </div>

### 固件中的挑战

现在让我们看看在固件中实现密码学算法可能面临哪些挑战。

#### 证书管理

在固件中保存公共证书需要使用非易失性（NV）存储。典型固件仅有有限的NV存储，例如8MB的串行外设接口（SPI）NOR闪存。NAND闪存的重放保护存储区（RPMB）容量更大，但并非所有平台都包含RPMB闪存。操作系统（OS）磁盘的系统分区是固件的另一种非易失性存储选择，不幸的是，该区域缺乏保护机制。攻击者可能直接更新该区域的内容。

证书撤销同样也是挑战。对于具备网络功能的操作系统，可采用在线证书状态协议（OCSP）。然而，若固件不支持网络，则该方案对独立固件解决方案并不适用。固件可通过暴露接口，借助其他授权实体实现证书更新。UEFI规范将UEFI认证变量作为UEFI镜像签名数据库。任何用户均可读取该数据库，但仅认证用户可写。若操作系统在KEK中存在条目，则可更新允许证书或将撤销证书添加至禁止签名数据库中。Cerberus规范定义了一组信任根（RoT）命令用于更新平台清单和组件清单，其中部分命令已纳入用于设备管理的安全协议与数据模型（SPDM）规范中。

需要提醒的是，当最终生产镜像生成时，必须从生产镜像中移除预生产证书或测试证书。否则任何开发者都能生成新的签名镜像。固件可实现内置的自我检测机制。我们可以标准化预生产证书和测试证书，并让固件显示警告信息，告知用户该固件仅用于测试且不应发布，期望验证工程师在看到此信息时能报告问题。

并非所有固件都支持机密保护。在这种案例中，固件可能不包含用于数据签名的私有证书。这可能限制了相互认证场景的应用，例如传输层安全协议（TLS）或安全协议与数据模型（SPDM）的握手阶段。为实现该功能，可采用其他机制。例如，可让固件从其他安全协处理器获取私有证书，例如管理引擎（ME），使用后立即销毁。在此方案中，安全协处理器应该实现接口来锁定私有证书获取。另一种方案是借助硬件生成证书，例如软件防护扩展（SGX）。

#### 加密算法的敏捷性

世界上存在大量加密算法，单一固件无需支持所有算法。以可信平台模块（TPM）为例，TPM芯片可能支持三种不同的哈希算法——用于传统系统的SHA1、用于当前系统的SHA256，以及面向中国市场的SM3。最终平台只需选择其中一种即可。一方面，系统固件应仅启用单一哈希算法用于固件哈希计算，以节省系统启动时间；另一方面，系统固件需具备多种哈希算法支持能力。这很重要，因为它能实现算法间的平滑迁移。例如旧系统采用SHA1算法，在该算法被证实存在不安全后，可迁移至SHA256。当前系统配置采用RSA2048与SHA256。NSA建议未来生产应升级至RSA3072与SHA384。

除升级需求外，不同市场或政府可能存在差异化要求。表19-10列出了中国的加密算法。

表 19-10 中国的加密算法

|   函数   |        |    算法    |   参数   |
| :----- | :----- | :----- | :----- |
| 对称算法 | 分组密文 | SM4 | 128位 |
|        | 流密文 | ZUC | - |
|        | 哈希 | SM3 | 256位 |
| 非对称算法 | 数字签名 | SM2 | 256位ECC |
|        | 密钥建立 | SM2 | 256位ECC |

#### 性能与尺寸

大多数加密算法可能较为复杂且需要大量计算，这可能对固件代码尺寸和运行时性能产生影响。例如，OpenSSL是实现加密算法的优质选择，但因其专为操作系统应用设计，故尺寸较大。对于嵌入式系统，我们需要寻找更精简的方案，例如mbed TLS或wolfSSL。

硬件层面也可通过新增指令集来支持算法。除了真随机数生成，Intel X86架构定义了高级加密标准新指令（AES-NIs），例如AESENC、AESDEC、AESIMC、AESKEYGEN等，以及SHA扩展指令，例如如SHA256MSG1、SHA256MSG2等。ARMv8.0架构也定义了AES扩展指令，如AESD、AESE、AESIMC、AESMC等，以及SHA扩展指令，如SHA256H、SHA256H2等。固件可利用这些硬件能力。

硬件安全模块（HSM）是加密算法的另一种实现方案。由于其属于厂商专有解决方案，固件可能难以直接使用。

### 攻击与缓解

针对加密算法的攻击可分为两类：密码分析与实现攻击。

#### 密码分析

密码分析通常由密码学专家执行。我们需要关注的是：
1) 确保产品采用最新批准的推荐算法及其参数。必须避免使用已弃用的算法，如SHA1或MD5。
2) 确保算法应用于正确场景。例如对用户密码使用HKDF是错误选择，应改用PBKDF。
3) 遵循行业最佳实践。例如，基于转发保密性考虑，密钥交换过程应采用临时密钥（EK）。

最后但同样重要的是：切勿在未经密码学专家审查的情况下自行设计加密算法或协议。例如，若存在加密与认证需求，应采用标准AEAD方案，而非定制化的E&M、EtM或MtE方案。

#### 实现攻击

实现攻击意味着加密算法及其使用本身并无问题，但编码错误导致了安全声明被破坏。

##### 不可信的外部输入

由于软件存在内存安全问题，不可信的外部输入在实际中仍是最具破坏性的攻击手段。以OpenSSL心脏出血漏洞为例，其中未经检查的memcpy()操作暴露了可能包含机密的内存区域。AMD PSP fTPM中也存在类似案例：EkCheckCurrentCert函数的栈溢出漏洞可能导致远程代码执行。因此，任何外部输入都必须经过验证。

##### 数据在验证前使用

加密算法可用于数据验证。在此情况下，数据在验证前不可使用。违规操作可能引发安全问题。以FPGA starbleed为例：由于赛灵思FPGA比特流在HMAC验证前即被解析，导致整个解密后的比特流数据暴露。

##### 数据中包含密钥

FPGA starbleed漏洞的第二个问题在于，HMAC密钥存储在比特流数据内部。一旦比特流数据泄露，密钥也将随之暴露。攻击者便可构造出能通过HMAC验证的有效比特流。

##### 降级攻击

行业标准在不断进步。旧的实现可能存在安全隐患且已被弃用。但出于兼容性考虑，某些实现仍支持下载旧版本的功能。以降级旧版加密中的SSL填充预言攻击（POODLE）为例，若解决方案支持从TLS1.0降级至SSL3.0，则POODLE攻击可能窃取“安全”的HTTP Cookie。高通DSP Achilles漏洞是另一类降级漏洞示例。二进制文件签名验证过而非版本号，此类不安全的降级操作必须禁止。

可采用安全版本号（SVN）或最低支持版本号（LSN）等技术标记连续版本的安全关联性，从而构建“防护墙”：允许降级未包含安全修复的版本，但禁止跨越SVN或LSN的降级操作。

##### 安全策略

安全策略是确保安全检查必须执行的强制措施，涵盖所有必要步骤，例如公钥比对、版本比对和签名比对。我们已观察到，由于策略控制不善，UEFI安全启动机制被绕过。另一个典型案例是HP iLO BMC安全启动机制。它已失效，因为攻击者通过触发load_legacy_key()函数故障，找到了绕过签名验证的途径。当验证程序无法获取足够信息或策略（例如公钥或哈希值）进行验证时，结果必须判定为失败而非成功。

## 量子安全加密学

当今计算机基于经典物理学原理构建。然而在纳米尺度下，万物遵循量子物理而非经典物理。越来越多的研究者发现，基于量子力学原理构建机器成为可能，这种机器被称为量子计算机。

在经典计算中，信息存储的基本单位是比特。比特可以是0或1，但只能是0或1。然而，在量子计算中，基本单位可同时保持0和1两种状态，这种单位被称为“量子比特”。该状态称为“叠加态”。一旦测量量子比特的状态，测量行为就会扰乱叠加态，导致量子比特坍缩为0或1。量子位的特性改变了计算方式。单个量子位可实现多维处理，计算能力呈指数级增长。

近年来，越来越多企业开始研发量子计算机。在超级计算领域，D-Wave于2017年发布了拥有2048量子位的D-Wave 2000Q计算机，并宣布下一代Pegasus将具备5640量子位。针对小型计算机，IBM已研制出50量子位原型机。英特尔于2018年交付了49量子位的Tangle Lake原型机，谷歌同年宣布推出72量子位的Bristlecone系统。

### 安全挑战

根据香农理论，存在不同类型的安全性：

无条件安全性：这意味着即使攻击者拥有无限计算资源，也无法破解该密码系统。这是最强的密码算法，例如一次性密码本（OTP）密码，又称韦纳姆密码。

计算安全性：这意味着密码系统可在固定次数的运算内被破解。但由于次数极大，当前计算资源无法实现。例如暴力破解可能耗时极长。现实中难以证明仅需固定次数运算即可攻破系统。或许系统未被攻破，仅仅是因为尚未找到有效的破解算法。

可证明安全性：这意味着密码系统是基于经过充分研究的数学难题构建的，例如大整数分解、离散对数、椭圆曲线离散对数等问题。同样地，若有人能破解该数学难题，该密码系统便会失效。当今最普遍的非对称密码技术均基于此原理，例如Rivest-Shamir-Adleman（RSA）算法、椭圆曲线密码学（ECC）以及Diffie-Hellman（DH）密钥交换协议。

#### Shor算法

1994年，Shor发表了论文《量子计算算法：离散对数与因式分解》。该论文描述了一种用于整数分解问题和离散对数问题的多项式时间量子计算机算法。肖尔算法使Rivest-Shamir-Adleman (RSA)加密、椭圆曲线密码学（ECC）以及Diffie-Hellman (DH)在量子计算领域面临威胁。因为攻击者可利用该算法在多项式时间内解决这些数学难题，从而轻易重建私钥。见表19-11。

表 19-11 受Shor算法影响的加密算法

|   功能   |    算法    |    难题    |
| :----- | :----- | :----- |
| 数字签名 | RSA | 整数因式分解 |
|        | DSA | 有限域密码学 |
|        | ECDSA | 椭圆曲线离散对数 |
| 密钥建立 | RSA | 整数因式分解 |
|        | DH | 离散对数 |
|        | ECDH | 椭圆曲线离散对数 |

