## 第十四章

# 固件安全编码实践

在完成安全架构和设计之后，我们需要将安全问题带入开发阶段。一方面，固件仍然是一种用软件编程语言编写的软件，例如C语言。大多数软件安全编码实践也适用于固件开发。另一方面，固件是一类特殊的软件。它的工作是初始化芯片来启动操作系统，例如系统固件，或在隐藏的执行环境中提供特殊的运行时服务，例如设备固件。基于这些用途，固件具有独特的安全要求。如今，有很多介绍软件安全编码的书籍。两本经典书籍，即Steve McConnell的《代码大全（Code Complete）》和Steve Maguire的《编写健壮代码（Writing Solid Code）》，是C语言程序员强烈推荐的书籍。较新的书籍，如Michael Howard和David Le Blanc合著的《编写安全的代码（Writing Secure Code）》和John Viega和Gary McGraw合著的《构建安全软件（Building Secure Software）》，是Windows和Linux安全编程实践的绝佳资源。我们将不再重复这些部分的细节，而是举例说明这些指导对固件的影响。之后，我们将介绍针对固件的安全编码实践。

## 基本安全实践

首先，让我们看下基本安全事件和安全设计实践。

### 安全编码实践

固件的一般安全编码实践与软件类似。

#### 防止缓冲区超限

缓冲区超限是软件中最严重的安全问题之一。它也是固件中最严重的安全问题之一。缓冲区超限的原因之一是程序从不可信任的外部输入读取长度字段，并在未进行任何检查的情况下使用该字段。列表14-1显示了EDK II固件中GUID分区表（GPT）分区驱动程序旧的实现中的一个典型缓冲区问题。起初，PartEntry是以固定大小 —— sizeof(EFI_PARTION_ENTRY) —— 分配的。但随后，这个固定的缓冲区会被用来复制一个大小可变的缓冲区 ——(PrimaryHeader->SizeOfPartitionEntry)。PrimaryHeader->SizeOfPartitionEntry是磁盘镜像上的外部数据，例如硬盘驱动程序或USB磁盘驱动程序。因此，攻击可能只是将SizeOfPartitionEntry改为较大的大小，就能在固件启动时造成缓冲区溢出。

列表14-1
```
PartEntry = AllocatePool (PrimaryHeader->NumberOfPartitionEntries *
sizeof (EFI_PARTITION_ENTRY));
if (PartEntry == NULL) {
    DEBUG ((EFI_D_ERROR, "Allocate pool error\n"));
    goto Done;
}

Status = DiskIo->ReadDisk (
    DiskIo,
    MediaId,
    MultU64x32(PrimaryHeader->PartitionEntryLBA, BlockSize),
    PrimaryHeader->NumberOfPartitionEntries* (PrimaryHeader-
    >SizeOfPartitionEntry),
    PartEntry
    );

if (EFI_ERROR (Status)) {
    GptValidStatus = Status;
    DEBUG ((EFI_D_ERROR, " Partition Entry ReadDisk error\n"));
    goto Done;
}
```


