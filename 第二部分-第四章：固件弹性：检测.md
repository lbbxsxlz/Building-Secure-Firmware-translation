## 第四章

# 固件弹性：检测

检测是固件弹性的第二个要素。即使我们使用多种方法保护固件，软件或硬件中的漏洞仍然可能导致固件组件被修改或损坏。因此，我们需要有一种方法来通知检测信任根（RTD）在启动流程中执行完整性检测。检测可能对可变代码和数据组件进行，也可能只针对可配置数据进行。与保护类似，主要威胁来自软件攻击者和硬件攻击者。

## 安全启动

检测由检测信任根或用于检测的信任链（CTD）完成。当使用检测信任根时，检测信任根会同时验证所有的平台组件。使用检测信任链时，则启动组件会逐个检查。每个新组件都要经过当前组件的验证，以确保其可信。这一流程也称为安全启动。如果新组件验证失败，当前组件就会知道系统受到了攻击。在这种情况下，当前组件将停止启动新组件，并可能启动恢复处理流程。

### 可检测性

作为前提条件，当检测信任根或检测信任链在进行验证检查时，必须使用之前章节中介绍的机制之一保护自身并使用策略识别攻击（例如哈希值或公共证书）。如果发生攻击，检测信任根或检测信任链需要具备检测攻击的能力。例如，如果使用哈希值检查X层固件组件，则必须将该哈希值保存在 (x-1) 层固件组件中。

检测信任根或检测信任链还必须有办法区分受攻击状态和良好状态。数字签名（例如Rivest-Shamir-Adleman[RSA]或SM2）或加密散列（如SHA或SM3）是一种好方法，而校验码和或循环冗余校验（CRC）则是一种坏方法。攻击者可能可以创建正确的校验码或循环冗余校验，但黑客不可能在不知道私钥的情况下轻易地创建数字签名，也不可能在修改内容后创建相同的哈希值。对称加密（如AES）是提供可检测性证明的另一种好方法。与数字签名和哈希值相比，加密固件代码的一个缺点是无法支持就地执行（XIP），而这是某些早期启动代码的要求。因此，加密选项的用途有限。有关这些不同选项的详细比较，请参见表4-1。

表 4-1 安全启动都可检测性
| **机制** | **优点** | **缺点** | **可信计算基础** | **实例** |
| :--- | :--- | :--- | :--- | :--- |
| 数字签名 | 它能提供就地执行能力。PKCS7提供加密灵活性。新固件更新不需要检测信任根更新。| 如果使用PKCS7模式，算法可能需要更多资源来执行验证任务。| 验证代码 + 公钥或它的哈希。| UEFI安全启动 Cerberus项目 谷歌验证启动 苹果安全启动 英特尔已认证的代码模块（ACM）|
| 哈希 | 它支持就地执行。算法简单。适合资源受限的环境。| 如果固件新固件更新，哈希值随之更新。| 验证代码 + 新固件哈希值 | 英特尔Boot Guard |
| 加密 | 它提供额外的机密性。新固件更新不需要检测信任根更新。| 不支持就地执行代码。| 验证代码 + 加密密钥 | 英特尔microcode patch 英特尔BIOS Guard模块 一些物联网启动固件 FPGA比特流 |

### 版本

为了防止回滚攻击，需要检查安全版本号（SVN）。新组件的安全版本号数字必须等于或大于当前的安全版本号。当前的安全版本号信息必须储存在检测信任根的非易失性存储内。它可以储存在初始启动ROM或一些可信存储中，例如TPM。

### 策略撤销

有时可能会有多个安全启动策略存储在检测信任根中。例如，UEFI安全启动功能定义了一个签名证书数据库。该数据库包括一组公共证书。如果 UEFI镜像的证书与这数据库中的任一证书匹配，则验证通过。然而，有些证书可能在之后会被视为无效。在这种情况下，我们需要一种方法来撤销无效证书。一种可能的方法是从原始数据库中删除证书。删除过程比较复杂，因为我们需要读出较大的数据库，删除无效条目，然后写入新的数据库。UEFI规范定义了另一种方法：一个禁止的签名证书数据库。这个禁止数据库保存了所有的已撤销的证书。因此，当我们需要撤销旧证书时，只需将其附加到禁止数据库即可。

### 不可绕过

检测过程不得绕过。检测必须在所有可能的启动路径中进行，包括正常启动、S3恢复、S4恢复、热重启、代码重启、固件更新模式、恢复模式，甚至制造模式或"安全"模式。在检测阶段，保护应同时应用。例如，系统必须启用IOMMU以防止DMA攻击。如果没有DMA保护，攻击者可能会附加一个设备例如PCILeech设备，并在通过验证后更新固件代码。

另一种绕过检测的方法是对固件闪存设备使用检查时间/使用时间（TOC/TOU）攻击。在闪存上的固件代码加载到内存并通过验证后，攻击者可以附加闪存编程器并更新闪存设备上的代码。如果代码中存在漏洞，导致某些代码再次读取闪存内容，那么这些代码就会读取修改后的内容。被修改的内容可能是代码，也可能是数据，而且可能会影响进一步的启动流程。

### 额外的能力

除了可检测性，检测信任根或检测信任链可能提供额外的能力，例如通知终端用户验证失败，或在事件日志中记录此次失败。事件日志可能作为检测信任根或检测信任链的一部分保存或通过一些带外（OOB）机制转发到远程系统。

### 案例研究

现在，让我们看一下安全启动实现的一些实例。

#### UEFI安全启动

UEFI（统一可扩展固件接口）安全启动是定义在UEFI规范的一项功能。平台系统固件需要在启动任一第三方固件代码前验证它。系统固件镜像由平台制造商--原始设备制造商（OEM）创建。它被视为可信计算基础(TCB)的一部分。在启动过程中，系统固件可能需要执行独立硬件供应商（IHV）创建的PCI选项ROM或操作系统供应商（OSV）创建的操作系统加载程序。那些固件的其他部分不属于可信计算基础的一部分。平台OEM通过在固件镜像签名数据库中登记OSV和IHV的公共证书，选择要信任的OSV和IHV。最终用户也可以选择登记和撤销安全数据库中的条目。

UEFI规范支持可移植可执行文件（PE）映像格式。固件映像的签名通过签名工具附加到同一个PE镜像上（见图 4-1）。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-1.jpg></img></div>
<div align=center>图 4-1 PE镜像布局</div>

图4-2显示了UEFI安全启动验证流程。表4-2显示了在UEFI安全启动中使用的密钥/镜像安全数据库。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-2.jpg></img></div>
<div align=center>图 4-2 UEFI安全启动验证流程</div>

表 4-2 在UEFI安全启动中的密钥使用
| **密钥** | **验证的对象** | **更新由谁验证** | **评论** |
| :--- | :--- | :--- | :--- |
| PK | 新的PK 新的KEK 新的db/dbx/dbt/dbr 新的OsRecoveryOrder 新的OsRecovery#### | PK | 平台密钥 |
| KEK | 新的db/dbx/dbt/dbr 新的OsRecoveryOrder 新的OsRecovery#### | PK | 密钥交换密钥 |
| db | UEFI镜像 （操作系统加载程序/选项ROM）| PK/KEK | 授权的镜像数据库 |
| dbx | UEFI镜像 （操作系统加载程序/选项ROM）| PK/KEK | 禁止镜像数据库 |
| dbt | UEFI镜像 + dbx | PK/KEK | 时间戳数据库 |
| dbr | 新的OsRecoveryOrder 新的OsRecovery#### (操作系统恢复镜像) | PK/KEK | 恢复数据库 |

在UEFI安全启动中，非可信的数据是任何第三方固件代码，包括操作系统启动加载程序、PCI选项ROM或UEFI shell等工具。组件提供商需要用私钥签名这些镜像，并且公布公钥让OEM或最终用户注册。

OEM或最终用户可以注册公开密钥作为可信数据（UEFI安全启动镜像安全数据库）。数据库存储在UEFI已验证变量中。数据库可在启动期间更新。任何人都可以读取该数据库，但只能使用已签名的更新值进行写入。

UEFI规范定义了多种安全数据库。这些数据库的详细使用在UEFI规范中描述。

    • db：允许的镜像签名数据库
    • dbx：禁止镜像签名数据库
    • dbt：时间戳签名数据库
    • dbr：恢复镜像签名数据库

在启动期间，镜像验证程序验证第三方固件代码，将其签名与前面数据库中的签名比对。如果验证通过，则第三方固件代码将执行。如果验证失败，第三方固件代码将被丢弃。

图4-3显示了使用db/dbx的验证流程。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-3.jpg></img></div>
<div align=center>图 4-3 使用镜像签名数据库的镜像验证</div>

图4-4显示引入dbt的验证流程。基于dbx的签名需要额外的检查。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-4.jpg></img></div>
<div align=center>图 4-4 使用时间戳签名数据库的镜像验证</div>

##### 英特尔Boot Guard

UEFI安全启动假定OEM平台固件是可信计算基础（TCB），并对其进行隐式地信任。这一假设只对软件攻击有效。然而，对于简单的硬件攻击来说它是无效的。硬件攻击者可以物理访问系统主板，并且使用编程器更新闪存。一种改进的实现是使用硬件信任根验证OEM平台固件。一种解决方案是使用英特尔Boot Guard实现（见图 4-5）。该功能通过以下两个组件验证整个OEM平台固件镜像：

    •  英特尔已验证的代码模块（ACM）：他验证OEM初始化启动块（IBB）。
    •  CPU Microcode：它验证英特尔ACM二进制文件

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-5.jpg></img></div>
<div align=center>图 4-5 英特尔Boot Guard流程</div>

图4-6和图4-7显示了英特尔Boot Guard涉及的组件。表4-3显示了在英特尔Boot Guard中密钥使用。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-6.jpg></img></div>
<div align=center>图 4-6 英特尔Boot Guard示意图（内存中）</div>

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-7.jpg></img></div>
<div align=center>图 4-7 英特尔Boot Guard示意图（关系）</div>

表 4-3 英特尔Boot Guard中密钥使用
| **密钥** | **验证的对象** | **存储位置** | **由谁验证** |
| :--- | :--- | :--- | :--- |
| ACM密钥 | ACM | CPU | Microcode |
| 密钥哈希 | Boot Guard密钥 | PCH | ACM |
| Boot Guard密钥 | 密钥清单（KM）| 密钥清单（闪存）| ACM |
| 密钥清单密钥 | 启动策略清单（BPM）| 密钥清单（闪存）| ACM |
| IBB哈希 | IBB | 启动策略清单（BPM）| ACM |
