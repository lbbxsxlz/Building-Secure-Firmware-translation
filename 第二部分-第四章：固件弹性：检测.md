## 第四章

# 固件弹性：检测

检测是固件弹性的第二个要素。即使我们使用多种方法保护固件，软件或硬件中的漏洞仍然可能导致固件组件被修改或损坏。因此，我们需要有一种方法来通知检测信任根（RTD）在启动流程中执行完整性检测。检测可能对可变代码和数据组件进行，也可能只针对可配置数据进行。与保护类似，主要威胁来自软件攻击者和硬件攻击者。

## 安全启动

检测由检测信任根或用于检测的信任链（CTD）完成。当使用检测信任根时，检测信任根会同时验证所有的平台组件。使用检测信任链时，则启动组件会逐个检查。每个新组件都要经过当前组件的验证，以确保其可信。这一流程也称为安全启动。如果新组件验证失败，当前组件就会知道系统受到了攻击。在这种情况下，当前组件将停止启动新组件，并可能启动恢复处理流程。

### 可检测性

作为前提条件，当检测信任根或检测信任链在进行验证检查时，必须使用之前章节中介绍的机制之一保护自身并使用策略识别攻击（例如哈希值或公共证书）。如果发生攻击，检测信任根或检测信任链需要具备检测攻击的能力。例如，如果使用哈希值检查X层固件组件，则必须将该哈希值保存在 (x-1) 层固件组件中。

检测信任根或检测信任链还必须有办法区分受攻击状态和良好状态。数字签名（例如Rivest-Shamir-Adleman[RSA]或SM2）或加密散列（如SHA或SM3）是一种好方法，而校验码和或循环冗余校验（CRC）则是一种坏方法。攻击者可能可以创建正确的校验码或循环冗余校验，但黑客不可能在不知道私钥的情况下轻易地创建数字签名，也不可能在修改内容后创建相同的哈希值。对称加密（如AES）是提供可检测性证明的另一种好方法。与数字签名和哈希值相比，加密固件代码的一个缺点是无法支持就地执行（XIP），而这是某些早期启动代码的要求。因此，加密选项的用途有限。有关这些不同选项的详细比较，请参见表4-1。

表 4-1 安全启动都可检测性
| **机制** | **优点** | **缺点** | **可信计算基础** | **实例** |
| :--- | :--- | :--- | :--- | :--- |
| 数字签名 | 它能提供就地执行能力。PKCS7提供加密灵活性。新固件更新不需要检测信任根更新。| 如果使用PKCS7模式，算法可能需要更多资源来执行验证任务。| 验证代码 + 公钥或它的哈希。| UEFI安全启动 Cerberus项目 谷歌验证启动 苹果安全启动 英特尔已认证的代码模块（ACM）|
| 哈希 | 它支持就地执行。算法简单。适合资源受限的环境。| 如果固件新固件更新，哈希值随之更新。| 验证代码 + 新固件哈希值 | 英特尔Boot Guard |
| 加密 | 它提供额外的机密性。新固件更新不需要检测信任根更新。| 不支持就地执行代码。| 验证代码 + 加密密钥 | 英特尔microcode patch 英特尔BIOS Guard模块 一些物联网启动固件 FPGA比特流 |

### 版本

为了防止回滚攻击，需要检查安全版本号（SVN）。新组件的安全版本号数字必须等于或大于当前的安全版本号。当前的安全版本号信息必须储存在检测信任根的非易失性存储内。它可以储存在初始启动ROM或一些可信存储中，例如TPM。

### 策略撤销

有时可能会有多个安全启动策略存储在检测信任根中。例如，UEFI安全启动功能定义了一个签名证书数据库。该数据库包括一组公共证书。如果 UEFI镜像的证书与这数据库中的任一证书匹配，则验证通过。然而，有些证书可能在之后会被视为无效。在这种情况下，我们需要一种方法来撤销无效证书。一种可能的方法是从原始数据库中删除证书。删除过程比较复杂，因为我们需要读出较大的数据库，删除无效条目，然后写入新的数据库。UEFI规范定义了另一种方法：一个禁止的签名证书数据库。这个禁止数据库保存了所有的已撤销的证书。因此，当我们需要撤销旧证书时，只需将其附加到禁止数据库即可。

### 不可绕过

检测过程不得绕过。检测必须在所有可能的启动路径中进行，包括正常启动、S3恢复、S4恢复、热重启、代码重启、固件更新模式、恢复模式，甚至制造模式或"安全"模式。在检测阶段，保护应同时应用。例如，系统必须启用IOMMU以防止DMA攻击。如果没有DMA保护，攻击者可能会附加一个设备例如PCILeech设备，并在通过验证后更新固件代码。

另一种绕过检测的方法是对固件闪存设备使用检查时间/使用时间（TOC/TOU）攻击。在闪存上的固件代码加载到内存并通过验证后，攻击者可以附加闪存编程器并更新闪存设备上的代码。如果代码中存在漏洞，导致某些代码再次读取闪存内容，那么这些代码就会读取修改后的内容。被修改的内容可能是代码，也可能是数据，而且可能会影响进一步的启动流程。

### 额外的能力

除了可检测性，检测信任根或检测信任链可能提供额外的能力，例如通知终端用户验证失败，或在事件日志中记录此次失败。事件日志可能作为检测信任根或检测信任链的一部分保存或通过一些带外（OOB）机制转发到远程系统。

### 案例研究

现在，让我们看一下安全启动实现的一些实例。

#### UEFI安全启动

UEFI（统一可扩展固件接口）安全启动是定义在UEFI规范的一项功能。平台系统固件需要在启动任一第三方固件代码前验证它。系统固件镜像由平台制造商--原始设备制造商（OEM）创建。它被视为可信计算基础(TCB)的一部分。在启动过程中，系统固件可能需要执行独立硬件供应商（IHV）创建的PCI选项ROM或操作系统供应商（OSV）创建的操作系统加载程序。那些固件的其他部分不属于可信计算基础的一部分。平台OEM通过在固件镜像签名数据库中登记OSV和IHV的公共证书，选择要信任的OSV和IHV。最终用户也可以选择登记和撤销安全数据库中的条目。

UEFI规范支持可移植可执行文件（PE）映像格式。固件映像的签名通过签名工具附加到同一个PE镜像上（见图 4-1）。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-1.jpg></img></div>
<div align=center>图 4-1 PE镜像布局</div>

图4-2显示了UEFI安全启动验证流程。表4-2显示了在UEFI安全启动中使用的密钥/镜像安全数据库。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-2.jpg></img></div>
<div align=center>图 4-2 UEFI安全启动验证流程</div>

表 4-2 在UEFI安全启动中的密钥使用
| **密钥** | **验证的对象** | **更新由谁验证** | **评论** |
| :--- | :--- | :--- | :--- |
| PK | 新的PK 新的KEK 新的db/dbx/dbt/dbr 新的OsRecoveryOrder 新的OsRecovery#### | PK | 平台密钥 |
| KEK | 新的db/dbx/dbt/dbr 新的OsRecoveryOrder 新的OsRecovery#### | PK | 密钥交换密钥 |
| db | UEFI镜像 （操作系统加载程序/选项ROM）| PK/KEK | 授权的镜像数据库 |
| dbx | UEFI镜像 （操作系统加载程序/选项ROM）| PK/KEK | 禁止镜像数据库 |
| dbt | UEFI镜像 + dbx | PK/KEK | 时间戳数据库 |
| dbr | 新的OsRecoveryOrder 新的OsRecovery#### (操作系统恢复镜像) | PK/KEK | 恢复数据库 |

在UEFI安全启动中，非可信的数据是任何第三方固件代码，包括操作系统启动加载程序、PCI选项ROM或UEFI shell等工具。组件提供商需要用私钥签名这些镜像，并且公布公钥让OEM或最终用户注册。

OEM或最终用户可以注册公开密钥作为可信数据（UEFI安全启动镜像安全数据库）。数据库存储在UEFI已验证变量中。数据库可在启动期间更新。任何人都可以读取该数据库，但只能使用已签名的更新值进行写入。

UEFI规范定义了多种安全数据库。这些数据库的详细使用在UEFI规范中描述。

    • db：允许的镜像签名数据库
    • dbx：禁止镜像签名数据库
    • dbt：时间戳签名数据库
    • dbr：恢复镜像签名数据库

在启动期间，镜像验证程序验证第三方固件代码，将其签名与前面数据库中的签名比对。如果验证通过，则第三方固件代码将执行。如果验证失败，第三方固件代码将被丢弃。

图4-3显示了使用db/dbx的验证流程。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-3.jpg></img></div>
<div align=center>图 4-3 使用镜像签名数据库的镜像验证</div>

图4-4显示引入dbt的验证流程。基于dbx的签名需要额外的检查。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-4.jpg></img></div>
<div align=center>图 4-4 使用时间戳签名数据库的镜像验证</div>

##### 英特尔Boot Guard

UEFI安全启动假定OEM平台固件是可信计算基础（TCB），并对其进行隐式地信任。这一假设只对软件攻击有效。然而，对于简单的硬件攻击来说它是无效的。硬件攻击者可以物理访问系统主板，并且使用编程器更新闪存。一种改进的实现是使用硬件信任根验证OEM平台固件。一种解决方案是使用英特尔Boot Guard实现（见图 4-5）。该功能通过以下两个组件验证整个OEM平台固件镜像：

    •  英特尔已验证的代码模块（ACM）：他验证OEM初始化启动块（IBB）。
    •  CPU Microcode：它验证英特尔ACM二进制文件

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-5.jpg></img></div>
<div align=center>图 4-5 英特尔Boot Guard流程</div>

图4-6和图4-7显示了英特尔Boot Guard涉及的组件。表4-3显示了在英特尔Boot Guard中密钥使用。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-6.jpg></img></div>
<div align=center>图 4-6 英特尔Boot Guard示意图（内存中）</div>

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-7.jpg></img></div>
<div align=center>图 4-7 英特尔Boot Guard示意图（关系）</div>

表 4-3 英特尔Boot Guard中密钥使用
| **密钥** | **验证的对象** | **存储位置** | **由谁验证** |
| :--- | :--- | :--- | :--- |
| ACM密钥 | ACM | CPU | Microcode |
| 密钥哈希 | Boot Guard密钥 | PCH | ACM |
| Boot Guard密钥 | 密钥清单（KM）| 密钥清单（闪存）| ACM |
| 密钥清单密钥 | 启动策略清单（BPM）| 密钥清单（闪存）| ACM |
| IBB哈希 | IBB | 启动策略清单（BPM）| ACM |

英特尔推出了英特尔Boot Guard已验证代码模块（ACM），这是一个由英特尔签名的模块。ACM的职责是在主机CPU将控制权转移到OEM固件之前验证OEM平台固件。由于验证整个镜像非常耗时的，因此ACM只验证初始话启动块（IBB）代码。然后，IBB负责验证OEM启动块 (OBB)。

英特尔Boot Guard定义了一组清单来记录签名信息：

    • 固件接口表（FIT）：这是固件镜像中的一个表。固件接口表的地址被记录在一个地址位于0xFFFFFFC0（4GB - 64bytes）64位的指针中。固件接口表记录了ACM，BPM和KM的地址。
    • 启动策略清单（BPM）：它记录了IBB的哈希，并且它由密钥清单密钥签名。
    • 密钥清单（KM）：它记录了一组密钥对公钥的哈希，密钥对签名了启动策略清单，并且它由Boot Guard密钥签名。
    • Boot Guard密钥（BG Key）：这密钥用来签名密钥清单。
    • 密钥哈希：它记录了Boot Guard密钥公钥的哈希。它配置在PCH硬件中。

密钥哈希是只读的。它不能被更新。启动策略清单和密钥清单可以由固件更新。ACM公钥的哈希在CPU内部。调试的ACM由调试的密钥签名。生产型ACM由生产型的密钥签名。

在运行期间，CPU Mocrocode从固件接口表（FIT）中找到ACM位置，并将ACM加载到CPU缓存中的已验证代码执行区。然后，CPU Microcode对ACM进行验证。如果验证通过，ACM就开始执行。ACM IBB验证从PCH获取密钥哈希并验证密钥清单。如果验证通过，ACM从密钥清单中获取密钥哈希并验证启动策略清单。如果验证通过，ACM从启动策略清单中获取IBB哈希值，并验证固件的IBB代码。如果最终验证通过，则固件的IBB变为可信，ACM将控制权转移给IBB。

英特尔Boot Guard仅验证整个OEM固件的初始启动块（IBB）部分。为确保整个OEM固件是未经修改的，IBB需要验证OEM启动块 (OBB) 的其余部分。OBB的公共密钥哈希必须存储在IBB中，确保由ACM对其进行验证。作为一种实现选择，OEM可以直接将OBB的哈希存储在IBB中，而不是使用公钥。OBB验证码在IBB中。如果OBB通过验证，OBB将被IBB调用。如果OBB未通过验证，则跳过OBB。图 4-8显示了使用英特尔Boot Guard、OBB 验证和UEFI安全启动构建的完整安全启动链。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-8.jpg></img></div>
<div align=center>图 4-8 安全启动验证流程</div>

#### Cerberus项目

在服务器平台上，有更多的固件元素，例如基板管理控制器（BMC）、网络接口卡（NIC）、独立驱动器冗余阵列（RAID）控制器、非易失性存储器扩展（NVMe）存储设备等的固件。现有的安全启动解决方案无法验证所有设备的固件，因为安全启动逻辑只能验证系统固件的完整性。因此，我们需要一种新的解决方案来验证板上的所有固件，以满足NIST SP800-193的要求。服务器BMC可能有能力访问板上的其他固件。然而，BMC太大了，而且还包括很多可管理性功能。因此，我们需要一个较小的可信计算基础。

开放计算项目（OCP）定义了Cerberus安全架构。这是一个分层信任根（RoT）架构。在该架构中，Cerberus芯片是关键要素。它是一个专用的安全微处理器，具有内部SRAM和闪存。它可以通过例如串行外设接口（SPI）或系统管理总线（SMBus）/集成电路（I2C）等各种接口访问板上的所有固件。它拥有平台的重置控制逻辑，因此除非它对平台的安全状态感到满意，否则平台无法开启。从安全角度看，Cerberus芯片是一个设备标识符组合引擎（DICE）。它在物理上是不可克隆的，而且具有防篡改功能。

Cerberus芯片支持NIST SP800-193以下几个方面的要求：

    1） 保护：Cerberus芯片位于系统与SPI设备之间。它强制SPI区域保护并且拒绝无效的SPI访问。
    2） 检测：Cerberus芯片验证平台固件，例如BIOS和BMC固件。Cerberus芯片也可以验证组件固件，例如电源供电单元（PSU）。Cerberus也可以提供证明能力。DICE相关的证明概念细节见第7章。
    3） 恢复：如果检测到损坏，Cerberus芯片可以从已知的良好的镜像自动恢复BIOS或BMC。恢复的细节见第5章。

图4-9描述了Cerberus的组件。当系统上电时，Cerberus芯片首先启动，并使CPU和BMC重置。然后，Cerberus芯片会验证UEFI闪存和BMC闪存的数字签名。只有验证通过后，Cerberus芯片才允许访问闪存，然后释放CPU和BMC重置。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-9.jpg></img></div>
<div align=center>图 4-9 Cerberus组件</div>

图4-10显示了Cerberus芯片内部的Cerberus认证流程。Cerberus内部有一个不可改变ROM作为信任根、一个描述镜像属性的密钥清单、一个Cerberus启动程序和Cerberus固件。在启动过程中，不可改变的Cerberus ROM会认证密钥清单，从清单中选择密钥来验证Cerberus的启动程序，并将控制权传递给启动程序。然后，Cerberus启动程序从清单中选择密钥来验证Cerberus固件。这Cerberus固件会完成平台固件余下的保护、检测和恢复工作。平台固件由平台固件清单（PFM）描述。PFM包括固件信息，例如只读区域、读/写区域、版本、只读区域摘要和公共证书。Cerberus维护平台固件清单，根据平台固件清单验证固件，并为平台固件清单提供安全更新。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-10.jpg></img></div>
<div align=center>图 4-10 Cerberus认证流程</div>

Cerberus是平台的信任根。我们称这种解决方案为平台主动信任根（PA-RoT）。一个平台可能包括不同的组件，如电源供电单元（PSU）和非易失性存储器扩展（NVMe）存储设备。为了验证这些组件中的固件，PA-RoT需要与组件中的信任根通信来获取固件信息。组件中的信任根被命名为活动组件信任根（AC-RoT）。DMTF论坛为两个组件之间的通信定义了管理组件传输协议（MCTP）。PA-RoT可通过使用MCTP在SMBus或I2C上与AC-RoT通信来获取设备固件摘要或证书。与PFM类似，组件固件信息也在名为组件固件清单（CFM）的清单中描述。Cerberus解决方案维护组件固件清单，根据组件固件清单验证组件固件，并为组件固件清单提供安全更新。Cerberus中使用的密钥见表4-4。我们将在第8章讨论MCTP和设备认证的细节。

| **密钥** | **验证的对象** | **存储位置** | **由谁验证** |
| :--- | :--- | :--- | :--- |
| 根哈希 | 密钥清单 | Cerberus OTP | Cerberus ROM |
| 密钥清单 | Cerberus启动程序 | Cerberus NV | Cerberus ROM |
| 密钥清单 | Cerberus固件 | Cerberus NV | Cerberus启动程序 |
| 平台固件清单 | 平台固件（BIOS，BMC）| Cerberus NV | Cerberus |
| 组件固件清单 | 活动组件（NVMe, PSU等）| Cerberus NV | Cerberus |

一个平台上可能有多个组件。并非所有固件都需要由Cerberus解决方案验证。Cerberus解决方案可以维护一个信任链，让经过验证的固件镜像或甚至经过验证的操作系统验证其他组件固件。

#### 英特尔平台固件弹性（PFR）

为了降低与固件相关的安全风险，英特尔为服务器平台开发了英特尔PFR。该功能可保护关键固件在启动和运行期间免受攻击。它是为了（符合）NIST SP800-193的Cerberus项目的一种实现。

现在，我们已经听说了英特尔Boot Guard、英特尔BIOS Guard和英特尔PFR。表4-5显示了这三种功能的区别。

| **功能** | **英特尔Boot Guard** | **英特尔BIOS Guard** | **英特尔PFR** |
| :--- | :--- | :--- | :--- |
| 独立协处理器 | 否 | 否 | 是 |
| 保护/更新 | 否 | 是。英特尔BIOS Guard模块在闪存上更新BIOS镜像或EC镜像。它由在SMM中的MSR写入触发。| 是。PFR CPLD更新整个BIOS镜像、服务器平台服务（SPS）镜像或BMC镜像。|
| 检测 | 是。英特尔Boot Guard ACM检查BPM/KM并且验证IBB的哈希。| 否 | 是。PFR CPLD验证整个BIOS镜像，SPS镜像和BMC镜像。英特尔PFR依靠英特尔Boot Guard完成检查。｜
| 恢复 | 否。英特尔Boot Guard本身不提供恢复能力。它可以触发英特尔ME完成恢复。| 否 | 是。PFR CPLD可以恢复到熟知的BIOS镜像、SPS镜像、或BMC镜像。|

Intel PFR包括以下的硬件组件：

    1） PFR CPLD（复杂可编程逻辑设备）：CPLD是系统中的信任根，是根据英特尔PFR设计的。它用来检测其他平台固件组件的完整性。
    2） 连接PCH SPI闪存控制器的固件：这包括BIOS和服务器平台服务（SPS）镜像。这区域由PFR保护。SPS镜像相当于客户平台使用的英特尔管理引擎（ME）镜像。
    3） 连接BMC SPI闪存的镜像：BMC镜像。这区域由PFR保护。
    4） 通过SMBu连接的固件：电源供电单元（PSU）、数字电压调节器（VR）、热插拔背板 (HSBP)、射频 (RF) NVRAM。
    5） SPI多路复用：允许选择谁是BMC SPI闪存和PCH SPI闪存的主控。在平台的预启动环境（T-1）中，PFR CPLD是BMC闪存和PCH闪存的主控，因为它需要读取闪存内容并进行检查。在正常模式（T0）下，BMC和PCH是各自闪存设备的主控设备。

图4-11显示了英特尔PFR系统框图。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-11.jpg></img></div>
<div align=center>图 4-11 英特尔PFR组件</div>

图4-12显示了英特尔PFR启动流程。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-12.jpg></img></div>
<div align=center>图 4-12 英特尔PFR启动流程</div>

交流电上电后，系统进入预启动环境（T-1）。只有PFR CPLD有电。所有其他组件均处于静默。PFR CPLD ROM执行内部认证并加载PFR固件。然后，PFR固件对BIOS、SPS固件和BMC固件进行认证。如果PFR CPLD认证失败，PFR将进行恢复。PFR CPLD还可能检查是否有任何更新请求，并在对新镜像进行认证后执行镜像更新。只有前面的安全检查全部通过后，系统才会从T-1过渡到正常模式（T0）。在此模式下，CPLD监控平台启动进度。如果出现任何启动失败或看门狗被触发，系统将切换回T-1模式进行恢复。

英特尔PFR功能需要将闪存分为三个区域：活动镜像区、恢复镜像区和暂存区（见图 4-13）。当前工作固件被放入活动镜像区，例如当前BIOS、SPS固件和BMC固件。恢复备份镜像放入恢复镜像区。如果工作固件无法启动，PFR CPLD可以从恢复镜像区中加载镜像来覆盖损坏的工作固件。暂存区用来保存新镜像用于更新。PFR CPLD需要检查暂存区是否有新镜像，并执行认证和版本检查。如果所有检查都通过，PFR CPLD将新镜像从暂存区复制到工作区。

<div align=center><img src=Figures/Chapter-4-Screenshot/Figure-4-13.jpg></img></div>
<div align=center>图 4-13 英特尔PFR闪存布局</div>
