## 第七章

# 可信启动

对于开发人员来说，中情局的保密性、完整性和可用性三要素始终是最重要的。关于 "完整性"，安全启动是帮助维护平台完整性要求的珍贵功能。它也被称为验证启动。启用安全启动后，组件将在执行下一个组件之前对其进行验证。如果验证失败，下一个组件将不会被执行。这看起来非常有用。但其他软件如何知道安全启动是否已启用且启用正确？其他软件如何知道是否安全启动被错误禁用？

如今，即使我们相信系统是安全的，我们仍希望让其他实体有机会确认这种安全属性。一旦系统有办法证明它拥有这些属性，我们就可以说它是可信的。

| **注释** | “信任” 的定义不同于 “安全”。根据可信计算小组（TCG）的定义，如果一个实体总是以预期的方式达到预期的目的，那么它就是可信的。可信的系统可能不是安全的系统。例如，如果我们知道一个系统被病毒感染，而病毒每天下午5点扫描C盘，并通过http协议将所有doc文件上传到特定的 URL，那么我们就可以说这个系统是可信的，而不是安全的。|
| :--- | :--- |

TCG定义了一种让其他软件检查系统是否已启动到可信环境的方法。该过程称为TCG可信启动。

## 静态的测量信任根（SRTM）

TCG规范定义了特殊硬件 —— 可信平台模块（TPM）。TPM有一组加密引擎、非易失性存储、易失性存储和一组平台配置寄存器（PCR）。TCG规范定义了一组信任根（RoT）：

    • 测量信任根（RTM）：RTM执行初始测量过程。RTM是主机端的一些代码。在实际实现中，我们有两种不同类型的RTM —— 静态RTM（SRTM）或动态 RTM（DRTM）。我们将在后面讨论它们。RTM可能包括许多组件。在这些组件中，核心RTM（CRTM）指的是在平台重置后运行最初代码的组件。
    • 报告信任根（RTR）：RTR通过TPM PCR报告测量信息，并提供基于TPM身份验证PCR真实性的能力。
    • 存储信任根（RTS）：RTS为密钥和数据提供受保护的存储区域。

### 可信平台模块

TPM包括除了测量信任根之外的所有受信任功能。本书重点介绍如何在固件中使用TPM。有关TPM硬件及其功能的详细介绍，请参阅TPM规范或参考文献中列出的书籍。

TPM的平台配置寄存器(PCR)保存最终测量值。测量值遵循此处给出的等式。此操作为PCR扩展：

PCR<sub>(new)</sub> = HASH(PCR<sub>(old)</sub> || HASH(Data))

PCR扩展是修改PCR值的唯一方法。如果平台多次扩展PCR，所有数据都会散列到PCR中。

当平台使用SRTM时，C-SRTM是固件启动块代码。启动块固件可以是UEFI/PI BIOS中的PEI固件卷。它也可以是coreboot BIOS中的ROM阶段。如果启用了英特尔Boot Guard功能，它也可以是英特尔Boot Guard ACM。见图7-1。根据TCG平台固件概述规范，RTM需要测量所有的其他组件。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-1.jpg></img></div>
<div align=center>图 7-1 使用SRTM的固件测量</div>

根据TCG平台固件概述规范，该C-SRTM必须测量自身，并将测量值写入到PCR0中，其余组件（代码或数据）必须通过信任链测量，然后写入测量值到相应的PCR中。见表7-1。

表 7-1 SRTM PCR测量值
| PCR索引 | 用法 |
| :--- | :--- |
| 0 | SRTM，BIOS，主机平台扩展，嵌入式option ROM和PI驱动 |
| 1 | 主机平台配置 |
| 2 | UEFI驱动和应用代码 |
| 3 | UEFI驱动和应用配置和数据 |
| 4 | UEFI启动管理代码（或在主启动记录（MBR）中初始程序加载器（IPL））和启动尝试 |
| 5 | UEFI启动管理配置和数据（被启动管理代码使用）和GUID分区表（GPT）（或传统MBR分区表）|
| 6 | 主机平台特定制造商 |
| 7 | 安全启动策略 |

可信启动与安全启动不同。在安全启动中，一个组件需要认证下一个组件。安全启动需要在加载下一个组件前检查签名或哈希值。如果签名无效或哈希值不匹配，安全启动将停止平台启动。在可信启动中，一个组件在加载下一个组件之前，需要将测量下一个组件，把测量值写入到TPM PCR中。测量启动不会失败，因为在启动过程中不会执行验证。一旦系统完成启动后，其他软件将通过使用验证来检查当前状态是否与先前状态相同，从而做出安全决定。有关区别见图7-2和7-3。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-2.jpg></img></div>
<div align=center>图 7-2 安全启动和可信启动流程</div>

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-3.jpg></img></div>
<div align=center>图 7-3 安全启动对比可信启动</div>

### TPM设备类型

第一个TPM产品遵循TPM规范1.2版本，也称作TPM1.2。然而，随着时间的推移，发现，TPM1.2规范存在一些局限性。例如，TPM1.2只支持SHA1哈希算法和RSA非对称算法。一旦操作系统获得TPM1.2的所有权，平台BIOS就可能无法使用TPM。

为了解决这些限制，TCG定义了TPM规范系列2.0，又称TPM2.0。TPM2.0支持灵活的加密技术。TPM2.0设备可支持SHA1、SHA256、SM3_256或未来的算法，例如SHA3_256或SHA3_384。TPM2.0为平台固件使用定义了专用的平台层次结构。操作系统管理的存储层次结构独立于平台层次结构。TPM2.0为使用授权功能提供了统一的框架，并扩展了授权方法 —— 清晰的明文密码和基于哈希的消息验证码（HMAC）。

除了TPM1.2和TPM2.0，中国政府定义了可信密码模块（Trusted Cryptography Module，TCM）。TCM提供了报告信任根（RTR）和存储信任根（RTS），并支持可信启动。从功能角度看，它与TPM相似。例如，TCM定义了平台配置寄存器（PCR）、非易失性存储、担保密钥、身份密钥等。TCM仅支持中国加密学算法 —— SM2、SM3和SMS4。

与TPM类似，可信加密模块也是被动设备。为了支持主动测量，中国政府标准定义了可信平台控制模块（TPCM）。除了RTR和RTS外，TPCM 提供了测量信任根（RTM）。系统上电后，TPCM测量平台BIOS，并将结果记录到PCR中，然后TPCM将控制权转移给主机CPU。

### 测量值汇报

PCR保存测量组件（代码和/或数据）的最终哈希值。它可用于显示当前平台状态。然而，从PCR最终值中获取个别测量值是不可行的。但在某些情况下，可能需要单个测量值。因此，TCG定义了完整性测量事件日志来记录个别测量哈希值和测量描述。见图7-4。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-4.jpg></img></div>
<div align=center>图 7-4 TCG测量事件与PCR</div>

在系统启动期间，每当固件将测量值记录到PCR中时，相应的事件就会被添加到事件日志中。最后，事件日志将传递给操作系统（见图7-5）。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-5.jpg></img></div>
<div align=center>图 7-5 启动期间TCG测量事件日志记录</div>

由于事件日志在易失性存储中，而该内存不是报告的信任根或存储的信任根，因此事件日志不可信，必须小心谨慎。只有来自TPM芯片的PCR才是可信的。在使用事件日志时，验证者必须提取每个TCG事件，并从事件日志中重建PCR值，然后与TPM芯片中的PCR值进行比较。如果不匹配，则TCG事件日志不可信。如果两者匹配，来自TCG事件日志的摘要值才可信。

### 证明

证明是指在机器（证明人）上存在的供另一个实体（鉴定人或验证人）验证的证据。若有TPM，证据就是PCR的值。如果验证者要检查系统是否处于已知的良好状态，就必须信任PCR值的真实性。这可能发生在本地平台或远程的验证者中。如果PCR值是通过不可信的环境传输的，例如软件栈或网络，那么我们就需要TPM_Quote操作来提供保护。TPM_Quote是个命令，它使用TPM私钥给一组PCR值签名，并提供数字签名。然后，验证者可以执行数字签名验证，并信任收集到的PCR值。此时，验证器可将收集到的PCR值与一组参考PCR测量值比较，以确定这是否是预期的平台。

直接比较PCR值是一种简单的方法。但是，TPM只提供了八个PCR值供平台使用。可能有这样一种情况，平台希望在一个PCR中断言某些测量值，而跳过其他一些测量值。因此，可以使用TCG事件日志。

在基于TCG事件日志的验证中，第一步也是验证PCR值的真实性。然后，验证者需要从事件日志中重建PCR值，来验证事件日志中测量值的真实性。最后，验证者可以将收集到的完整性测量事件日志与极好的参考测量值列表进行比较。现在，可以根据验证策略支持部分比较。

图7-6显示了在NIST SP800-155中定义的验证示例。测量评估权威机构（MAA）—— 鉴定人 —— 从端设备（即证明者）处收集事件日志和 PCR。MAA还会从一组受支持的供应机构，例如原始设备制造商 (OEM) 和增值经销商 (VAR)，获取极好的测量值。然后，MAA 将事件日志与极好的测量值进行比较，看它们是否匹配。如果不匹配，MAA可以会让端设备开始修复。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-6.jpg></img></div>
<div align=center>图 7-6 使用良好的参考测量值进行测量值评估</div>

报文交换细节如图7-7所示。首先，MAA从端设备获取引用（Quote）。引用是用TPM证明密钥（AK）签名的TPM PCR值列表。引用是当前平台状态的证明。一旦MAA获取引用，MAA就会使用公开的验证密钥来验证引用值，这就是所谓的远程证明。然后，MAA从客户端收集完整的事件日志，并回放事件日志来生成PCR列表。如果生成的PCR与引用PCR匹配，则表示事件日志未被篡改。该事件日志可用于与极好的测量值比较。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-7.jpg></img></div>
<div align=center>图 7-7 TCG远程证明流程</div>

完整的远程证明还包括通过使用TPM担保密钥（EK）来验证TPM的过程。每个TPM都包含一个唯一的EK对，位于TPM上的保护位置。EK的公钥包含在EK证书中。一个EK证书用于协助验证CA签发仅用于签名目的的验证密钥 (AK)。EK证书可用提供证明AK与EK位于同一TPM上。

### S3恢复

为了提高能效，平台可能支持休眠，根据高级配置和电源接口（ACPI）规范中的定义，休眠也称为S3恢复。如果系统需要进入S3状态，操作系统会保存当前系统配置，设置操作系统唤醒向量，并写芯片专用寄存器。然后平台硬件进入S3状态。CPU和大多数设备处于关闭状态。系统内存处于自刷新状态，以保持内存内容的可用性。最终用户唤醒系统后，SRTM-BIOS开始运行。BIOS根据保存的配置初始化系统，并跳转到操作系统唤醒向量。

在正常的系统关机和系统启动过程中，操作系统向TPM发送TPM_Shutdown(CLEAR)命令，BIOS向TPM发送TPM_Startup(CLEAR)命令，它将TPM上下文重置为默认初始化状态。S3恢复则不同。为了维护信任链，操作系统需要在系统进入S3之前发送TPM_Shutdown(STATE)命令，然后TPM会保存当前上下文，包括所有PCR值。当BIOS启动时，BIOS会发送TPM_Startup(STATE)命令，将TPM恢复到进入S3之前的原始状态，包括所有PCR值。在正常的S3恢复中，不需要为SRTM执行PCR扩展。

然而，如果TPM_Startup(STATE)由于某种原因失败，SRTM需要尝试TPM_Startup(CLEAR)来重新启动TPM。如果TPM重启成功，SRTM需要向PCR扩展错误代码，因为SRTM在S3中以不同的启动路径运行，不可能重放正常启动流程以创建相同的PCR。

### 设备标识符合成引擎（DICE）

TPM广泛应用于个人计算、移动、和服务器平台。然而，物联网（IoT）市场可能会有不同的解决方案，应对功耗、安全性、资源和其他方面的挑战。并非所有物联网系统和组件都采用TPM。因此，TCG创建了设备标识符合成引擎（DICE）工作组，以开发新的方法来提高安全性和隐私性，同时将芯片要求降至最低。即使是最微小的微控制器也能支持DICE，以建立设备标识并执行证明和安全固件更新。

图7-8显示了DICE的基本思想。不可改变ROM —— DICE硬件引擎将唯一设备机密（UDS）和启动代码的哈希结合起来，创建一个基于哈希的消息认证码（HMAC）。该HMAC用作设备的复合设备标识（CDI）。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-8.jpg></img></div>
<div align=center>图 7-8 DICE SOC</div>

等式是：

    CDI = HMAC(UDS, Hash(Code))

如果更新了固件启动代码，就会自动生成新的CDI。这可能是一项功能。但是，如果旧CDI被用于设备标识，则补丁过的设备上的新CDI将无法识别。这可能会带来一些可管理性问题。更好的解决方案是将代码分层。见图7-9。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-9.jpg></img></div>
<div align=center>图 7-9 分层的DICE架构</div>

CDI由带有UDS的SOC硬件和启动代码的哈希值生成。然后，DICE核心（第0层）使用CDI派生设备ID密钥对。设备ID密钥对是设备的标识符，不应在DICE核心之外泄露。为了在不暴露设备ID密钥的情况下证明对设备ID私有部分的了解，DICE核心需要为下一层生成一个新的密钥对。这个密钥对被称为别名密钥。别名密钥对派生自CDI和下一层（设备固件）的标识。该密钥可传递给设备固件层，并且密钥的私有部分可在设备固件生命周期内使用。设备固件需要确保别名密钥不会泄露到设备固件之外。设备固件更新会导致别名密钥对更新，但不会影响设备ID密钥对。DICE核心也会为使用设备ID私钥签名的别名密钥创建证书和自签名设备ID证书。设备ID证书在设备生命周期内不会更改，而别名密钥证书则会在固件更新时频繁更改。

DICE核心实现可以容易的扩展到多层启动。每一层都会为下一层创建新的别名密钥和别名证书。签发给下一层的别名证书由当前层授予的别名密钥签名。

DICE和TPM使用不同的密钥保护机制。在TPM解决方案中，密钥存储和使用在一个由硬件和软件组合而成的隔离环境中，并且密钥可随时使用。这被称为*空间上*的保护。DICE设计依赖于密钥的*时间上*的保护。密钥来自于启动链中的前一个组件，仅在当前组件中使用，然后在将控制权转移到下一个组件之前从内存中删除。使用密钥的加密操作只能在有限的时间内执行。图7-10和7-11显示了两者的区别。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-10.jpg></img></div>
<div align=center>图 7-10 TPM密钥保护</div>

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-11.jpg></img></div>
<div align=center>图 7-11 DICE密钥保护</div>

DICE规范仍在开发中。更多的细节请参考最新的DICE文档。

### 案例研究

现在。让我们看一下SRTM实现的一些实例。

#### UEFI BIOS中的测量启动支持

当前的UEFI BIOS实现，例如基于EDK II的实现，支持TCG可信启动。UEFI BIOS测量所需的组件，例如PEI模块、DXE模块、SMM模块、UEFI驱动程序和数据（如配置变量）等，到相应的PCR。图7-12和表7-2显示了平台中的组件及其相应的PCR值。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-12.jpg></img></div>
<div align=center>图 7-12 UEFI BIOS中的PCR</div>

表 7-2 UEFI BIOS中的PCR测量
| PCR索引 | TCG定义的用法 | UEFI例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | CRTM，平台固件（PEI、DXE、SMM、UEFI启动服务、UEFI运行时服务、嵌入式去驱动），非主机固件存在（类型、版本）|
| 1 | 主机固件配置 | CMOS配置，UEFI启动变量，UEFI配置变量， ACPI表，SMBIOS表，Microcode，底座 |
| 2 | UEFI驱动代码 | Option ROM，设备固件，非主机固件 |
| 3 | UEFI驱动配置和数据 | Option ROM配置，设备固件配置，非主机固件配置 |
| 4 | UEFI启动管理代码 | 操作系统启动程序 |
| 5 | UEFI启动管理代码配置和数据 | UEFI启动操作，GPT分区 |
| 6 | 主机平台特定制造商 | 无 |
| 7 | 安全启动策略 | UEFI安全启动策略（PK、KEK、db、dbx、dbt、dbr、安全启动状态、审计模式、部署模式），安全状态，调试状态 |

系统固件贡献了大部分的PCR测量。非主机固件或设备上的任何运行代码也应该被测量。对于设备而言，可能有两种不同的代码 —— 系统固件和Option ROM。系统固件指的是设备上运行的代码，它为主机提供服务。Option ROM是一种特殊类型的固件，它在主机端运行，并在操作系统驱动程序可用之前作为BIOS环境中的设备驱动程序工作。通常情况下，PCI存储卡、PCI图形卡或PCI网卡都可能有一个Option ROM。

系统固件完成初始化后，它测量操作系统启动程序，并将控制权移交给操作系统启动程序。然后，操作系统启动程序测量操作系统内核和启动参数，然后操作系统启动程序将控制权转移给操作系统内核。为了让操作系统启动程序重新使用BIOS中的测量代码，BIOS需要暴露一个测量接口，例如传统的INT 1A TCPA服务、TPM1.2 EFI_TCG_PROTOCOL，或TPM2.0 EFI_TCG2_PROTOCOL。

BIOS还需要提供一种让操作系统获取TCG事件日志的方法。对于TPM1.2，事件日志通过TCPA ACPI表传递。TPM2.x支持多种散列算法，而 TPM1.2只支持SHA1散列算法。在引入TPM2.x时，TCG增加了第二类事件日志。一种与TPM1.2兼容，仅支持SHA1。另一种使用新格式，支持多种散列算法。如今，由于SHA1已被弃用，因此只使用新格式的事件日志。它可以通过TCG2_PROTOCOL的GetEventLog()函数或从TPM2 ACPI表中获取。

为了映射到现实世界，表7-3显示了在TCG可信启动流程中BIOS与操作系统的交互方式。

表 7-3 在操作系统启动期间的PCR测量步骤
| 步骤 | 传统操作系统（Windows/Linux） | UEFI Windows | UEFI Linux | 定制的BIOS/操作系统 |
| :--- | :--- | :--- | :--- | :--- |
| BIOS将测量操作系统启动程序。 | 传统的BIOS测量主启动记录（MBR）内容 | UEFI BIOS测量botmgr.efi | UEFI BIOS测量grub.efi | BIOS内部行为。它应该知道操作系统启动程序在哪，并且是什么格式。在传递控制权给它之前测量它。|
| BIOS暴露测量服务给操作系统启动程序。 |TPM1.2 INTA 1A TCPA（16位实模式）| EFI_TCG_PROTOCOL。TPM1.2 HashLogextendevent()。EFI_TCG2_PROTOCOL。TPM2.0 HashLogextendevent()。 | EFI_TCG_PROTOCOL。TPM1.2 HashLogextendevent()。EFI_TCG2_PROTOCOL。TPM2.0 HashLogextendevent()。 | 它可能不需要。如果操作系统启动程序知道怎样与测量设备交互。|
| BIOS暴露TCG日志事件给操作系统。 | TPM1.2 TCPA ACPI表 | TPM1.2 TCPA ACPI表。TPM2.0 EFI_TCG2_PROTOCOL GetEventLog()和FINAL_EVENTS_TABLES或TPM2 ACPI表 | TPM1.2 TCPA ACPI表。TPM2.0 EFI_TCG2_PROTOCOL GetEventLog()和FINAL_EVENTS_TABLES或TPM2 ACPI表 | ACPI表或可能使用私有接口 |
| 操作系统启动程序可能在操作系统驱动准备使用之前使用BIOS测量服务来延伸操作系统内核。| 传统的启动程序（MBR和其扩展）测量操作系统内核的其余部分。| bootmgr.efi测量Windows操作系统内核。| grub.efi测量命令和内核文件。| 厂商特定的加载程序测量厂商特定的内核。|
| 一旦控制权传递到操作系统，BIOS服务就不可用。操作系统使用自己的驱动来延伸更多的组件。| 传统的操作系统内核测量剩余的。| Windows操作系统内核测量剩余的。| Linux操作系统内核测量剩余的。| 内核测量剩余的。|

《超越BIOS之旅：在EDK II中实现TPM2.0支持》描述了关于在EDK II BIOS中TPM支持的更多细节。

#### 英特尔Boot Guard

之前介绍的UEFI实现假设PEI代码是测量的信任根。如果平台启用了英特尔Boot Guard，则Boot Guard ACM就是信任根。Boot Guard ACM不仅要验证初始启动块（IBB），还要测量IBB，并写测量值到TPM PCR中。由Boot Guard ACM延伸的PCR列在表7-4中。简而言之，PCR[0]记录详细信息，PCR[7]记录权限。

表 7-4 英特尔Boot Guard中的PCR测量值
| PCR索引 | TCG定义的用法 | Boot Guard ACM例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | 细节：ACM策略状态（测量启动，验证启动），ACM安全版本号（SVN），ACM签名，密钥清单签名，启动策略清单签名，初始化启动块（IBB）哈希 |
| 1 | 主机固件配置 | 无 |
| 2 | UEFI驱动代码 | 无 |
| 3 | UEFI驱动配置和数据 | 无 |
| 4 | UEFI启动管理代码 | 无 |
| 5 | UEFI启动管理代码配置和数据 | 无 |
| 6 | 主机平台特定制造商 | 无 |
| 7 | 安全启动策略 | 权限：ACM策略状态（测量启动，验证启动），ACM安全版本号（SVN），ACM公钥哈希，密钥清单公钥哈希，启动策略清单公钥哈希 |

由于Boot Guard ACM需要使用TPM，因此必须启动TPM。如果Boot Guard ACM在locality 3中启动TPM，则必须创建TCG_EFI_STARTUP_LOCALITY_EVENT来记录此类信息。

#### coreboot中的测量启动支持

coreboot也支持TCG可信启动。然而，coreboot解决方案不使用TCG平台固件概述，而是用自己的方式使用TPM替代。表7-5显示了coreboot中PCR的用法。

表 7-5 coreboot中的PCR测量值
| PCR索引 | TCG定义的用法 | coreboot例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | 谷歌VBoot GBB flags |
| 1 | 主机固件配置 | 谷歌VBoot GBB HWID |
| 2 | UEFI驱动代码 | 核心测量信任根，包括所有的阶段，数据和blobs，例如COREBOOT CBFS（启动块，fallback/verstage），FW_MAIN CBFS（fallback/romstage, fspm, fallback/postcar, fallback/ramstage, cpu_microcode_blob, fsps, vbt, fallback/dsdt.aml, fallback/payload），RD_VPD，GBB，SI_DESC，SI_GBE |
| 3 | UEFI驱动配置和数据 | 运行时数据，像hwinfo.hex或MRC缓存，例如SI_ME，RW_NVRAM |
| 4 | UEFI启动管理代码 | 无 |
| 5 | UEFI启动管理代码配置和数据 | 无 |
| 6 | 主机平台特定制造商 | 无 |
| 7 | 安全启动策略 | 无 |

与UEFI相似，coreboot解决方案使用ACPI表来传递事件日志信息。TCPA ACPI表包含TPM1.2的事件日志信息，TPM2 ACPI表包含TPM2.0的事件日志信息。

#### Windows BitLocker

BitLocker是在Windows操作系统中提供磁盘加密的一项功能。TPM作为一种硬件解决方案，可在不需要用户交互的情况下辅助密钥保护。TPM可以存储由PCR锁定的某些数据，并且只有在PCR匹配时才解锁数据。这就是所谓的密封。该密封过程用于在供给阶段保存BootLocker密钥加密密钥。在每次启动阶段，BitLocker都会尝试从TPM中解封密钥，并使用该密钥解密磁盘加密密钥。这一解封过程可确保在并且仅在当前系统状态（记录在PCR中）与密钥配置时的状态相同时，密钥才会被解密。见图7-13。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-13.jpg></img></div>
<div align=center>图 7-13 TMP使用PCR密封/解封</div>

默认情况下，BitLocker将密钥与PCR 0、2和4绑定，这些PCR会记录平台上运行的代码。由于系统固件更新会导致PCR0的值发生变化，因此BitLocker恢复功能将被触发，最终用户需要提供任何一个恢复密码或恢复密钥才能解锁设备。因此，如果UEFI安全启动已启用，且PCR7已正确延伸，则BitLocker 将密钥绑定到PCR7。BitLocker利用安全启动来完成完整性验证。表7-6显示了Windows操作系统中PCR的用法。关于BitLocker的详细信息，请参考Microsoft BitLocker文档。

表 7-6 BitLocker中的PCR测量值
| PCR索引 | Wndows操作系统 |
| :--- | :--- |
| 0 | 核心系统固件可执行代码 |
| 1 | 核心系统固件数据 |
| 2 | 扩展的或可插入可执行代码 |
| 3 | 扩展的或可插入固件数据 |
| 4 | 启动管理/传统的MBR |
| 5 | GPT/分区表/传统的MBR分区表 |
| 6 | 从S4和S5电源状态事件恢复 |
| 7 | 安全启动状态 |
| 8 | 保留的/传统的NTFS启动扇区 |
| 9 | 保留的/传统的NTFS启动块 |
| 10 | 保留的/传统的启动管理 |
| 11 | BitLocker访问控制 |
| 12 | 数据事件和高度不稳定事件 |
| 13 | 启动模块细节 |
| 14 | 启动权限 |
| 15~23 | 保留 |

#### Grub

Grub是大多数Linux系统的默认操作系统启动程序。如果系统中存在TPM，Grub会测量可执行的命令和文件，并将测量值记录到TPM中。表7-7显示了在Grub中的PCR用法。

表 7-7 Grub中的PCR测量值
| PCR索引 | Grub |
| :--- | :--- |
| 8 | Grub命令行: 所有带有前缀“grub_cmd:”的输入的可执行命令（包括那些来自配置文件的）会被记录并且被测量。内核命令行：任何带有前缀“kernel_cmdline:”输入的传递给内核的命令行将被记录和测量。模块命令行：任何带有前缀“module_cmdline:”的输入的传递给内核模块的命令行将被记录和测量。|
| 9 | 文件：任何以与文件名相对应的描述性文本的由Grub读取的文件将被记录与测量 |

#### Linux完整性测量架构

Linux完整性测量架构是为内核完整性设计的。内核完整性的目标是检测文件是否被意外或恶意修改，将文件的测量值与极好的值进行比较，并执行本地文件完整性。

完整性测量架构（IMA）在Linux 2.6.30内核中首次引入。它包括三个组件：IMA测量、IMA评估和IMA审计。IMA在TPM中维护运行时测量值列表和PCR聚合值。在TPM有聚合值的益处是，如果列表被修改，修改可以通过重建PCR值来检测到。IMA使用PCR[10]来记录文件的测量值。

#### OpenPOWER可信启动

IBM OpenPOWER服务器实现了可信启动过程让用户验证服务器仅运行来自IBM或其他可信供应商的授权固件组件。OpenPOWER中PCR的用法与TCG定义的PCR类似。PCR[0,1]用于主机平台；PCR[2,3]用于附加的组件；PCR[4,5]用于启动状态转换。表7-8显示了OpenPOWER中PCR的用法。

表 7-8 OpenPOWER中PCR测量值
| PCR索引 | TCG定义的用法 | OpenPOWER例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | Hostboot和其他固件组件 |
| 1 | 主机固件配置 | 配置数据和固件容器元数据 |
| 2 | UEFI驱动代码 | IBM一致性加速处理器接口（CAPI）代码 |
| 3 | UEFI驱动配置和数据 | IBM一致性加速处理器接口（CAPI）数据 |
| 4 | UEFI启动管理代码 | 开放式电源抽象层（oPAL）固件、静态操作系统（Linux内核和initramfs）|
| 5 | UEFI启动管理代码配置和数据 | TPM使能flags，开放式电源抽象层（oPAL）容器元数据，启动序列，静态操作系统配置（Linux内核命令行）|
| 6 | 主机平台特定制造商 | 保留 |
| 7 | 安全启动策略 | 保留 |

#### 供应链验证

供应链是公司与其供应商之间的网络，用于生产特定产品并将其分销给最终买家。攻击者可能会在供应商发货后、最终买家收到产品前篡改组件（硬件、固件或软件）。买家如何确保收到的产品是供应商发货的产品？

NIST SP800-155提供了BIOS完整性测量、报告、收集和传输的指导原则。测量评估机构（MAA）可以判断系统是否符合预期，这一点已在"验证和证明"章节进行了讨论。除了参考测量，TCG也定义了由OEM和/或VAR提供的平台证书。该证书描述了EK证书、平台属性（例如平台制造商字符串、平台型号、平台版本和TPM）以及平台断言（如测量根类型）。这概念如图7-6所示。

美国国家安全局（NSA）开源了一个名为在运行时和启动时的主机完整性（HIRS）的原型来说明供应链验证能力。平台制造商创建基础平台证书。系统集成商和增值经销商创建差异化平台证书。认证证书颁发机构（ACA）可为TPM提供认证身份凭证（AIC）。在运行时，ACA可以执行担保凭据证书链验证来验证TPM使用的担保密钥是否由原始设备制造商（OEM）放置；还可以执行平台凭据证书链验证，并通过将测量到的组件信息与平台凭证中列出的制造商、型号和序列号进行比较，来验证系统硬件组件的来源，例如主板和机箱。

英特尔透明供应链是供应链验证的另一种实现方式。它实现了英特尔vPro系统的平台级和组件级的可追溯性。

#### Project Cerberus

Cerberus平台要求活动组件通过设备标识符组合引擎（DICE）支持硬件和固件组合标识。见图7-14。每个DICE层的测量（由如下公式计算）：

    Measurement = HMAC(Seed, Hash(Code))

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-14.jpg></img></div>
<div align=center>图 7-14 Cerberus架构</div>

Seed通常来自上一层的测量结果或别名密钥证书。因此，最终测量结果是所有层的链式测量结果。

平台活动信任根（PA-RoT）可使用证明消息与主动组件信任根（AC-RoT）通信。证明消息接口使用在SMBus/I2C消息协议之上的管理组件传输协议（MCTP）。PA-RoT始终是MCTP主机。AC-RoT可配置为端点或端点和主机。通过使用MCTP RoT命令，PA-RoT和AC-RoT可以建立平台级信任根。表7-9列出了PA或AC可以使用的一组RoT命令。有关详细信息，请参阅Cerberuss规范。其中部分命令与我们将在第8章讨论的安全协议和数据模型（SPDM）消息相同。

表 7-9 Cerberus RoT命令列表
| 注册名 | 信任根 | 描述 |
| :--- | :--- | :--- |
| 固件版本（Firmware Version）| PA/AC | 接收固件版本信息 |
| 设备能力（Device Capabilities）| PA/AC | 接收设备能力 |
| 设备ID（Device ID）| PA/AC | 接收设备ID |
| 导出证书（Export Certificate）| PA/AC | 导出证书签名请求（CSR）|
| 获取摘要（GET_DIGEST）| PA/AC | PA/AC | PA-RoT接收会话信息 |
| 获取证书（GET_CERTIFICATE）| PA/AC | PA-RoT基于会话查询设置会话变量 |
| 质疑（CHALLENGE）| PA/AC | PA-RoT接收和验证证书 |
| 密钥交换（Key Exchange）| PA | 交换前置主会话密钥 |
| 获取日志（Get Log）| PA | 接收调试，证明和篡改日志 |
| 平台配置注册（Platform Configuration Register）| PA | 返回平台测量 |
| 延伸平台配置注册（Extend Platform Configuration Register）| PA | 延伸平台测量 |
| 解封消息（Unseal Message）| PA | 解封证明质疑 |
| 解封消息结果（Unseal Message Result）| PA | 获取解封的状态和结果 |

#### 微软Azure Sphere: Pluton

Microsoft Azure Sphere是一个安全的高级应用平台，它对链接互联网的设备具有内置通信和安全功能。它包括一个安全、连接、交叉的微控制器单元（MCU）。Pluton安全子系统是Azure Sphere的防篡改，基于硬件的信任根。它具有加密引擎，并为安全启动验证提供服务。

除了安全启动，Pluton安全子系统还支持芯片上的测量启动和远程验证。在启动过程中，Pluton会记录所有启动组件的哈希值。当Azure Sphere设备连接到Azure Sphere安全服务（AS3）时，设备会使用本地存储的证书验证服务器认证。同时，AS3也通过远程证明认证设备本身。Pluton会返回哈希值以及使用证明密钥的签名的哈希值的签名。由于AS3拥有设备证明密钥，AS3可以确定设备是否真实，以及设备是否使用正版软件启动。

#### 思科信任锚

思科使用信任锚技术为思科可信系统提供基础。除安全启动外，思科信任锚模块（TAm）还可用于验证硬件真实性。操作系统可以检查TAm是否有安全的唯一设备标识符 (SUDI)，该标识符只能来自思科。SUDI在制造过程中被永久编程到TAm中来支持供应链验证。

### 攻击与缓解

现在，让我们来看一下一些攻击SRTM的实例和缓解措施。

#### 完整性攻击

完整性是可信计算面临的最大挑战。最终解决方案必须测量所有可变组件和配置，以便进行验证。在实践中，一些固件可能无法测量所有固件代码。这样就无法检测到代码的变化。另外，有些固件可能无法测量所有与安全相关的设置。如果安全设置关闭，它也不会被检测到。

非主机固件也有问题。研究人员已经证明了替换键盘固件、嵌入式控制器（EC）固件、基板管理控制器（BMC）固件、电池固件和其他系统板固件的能力。因此，黑客可以记录用户的按键操作、远程控制系统或控制电池充电。不过，这些设备的固件可能无法在当前的大部分系统中测量到。

以Stuxnet病毒为例。Stuxnet病毒通常是由一个可以实际访问系统的人通过受感染的USB闪存盘引入供应网络的。然后，蠕虫在网络中传播，扫描计算机上的软件，控制可编程逻辑控制器（PLC）。Stuxnet将受感染的rootkit引入PLC，修改代码并向PLC发出意想不到的命令，同时向用户返回一个正常运行值反馈循环。问题如下：我们是否应该测量USB端口是否被阻塞？是否要测量USB闪存设备固件？是否应该测量USB闪存设备上的内容？是否应该测量控制PLC设备的软件？是否应该测量PLC代码？

测量中的任何缺失都是潜在的攻击点。

#### 攻击S3恢复

如前所述，正常的S3恢复过程包括TPM_Shutdown(STATE)和TPM_Startup(STATE)。如果操作系统被黑，操作系统在将系统置于S3状态时就可以跳过TPM_Shutdown(STATE)命令。在S3恢复状态下，当BIOS SRTM向TPM发送TPM_Startup(STATE)命令时，TPM就会失效。如果坏的SRTM实现忘记发送TPM_Startup(CLEAR)，或者忘记扩展错误代码，那么当系统启动时，TPM PCR全为零。之后，TPM PCR值就会被被攻击的操作系统伪造。根据PCR值，远程TPM引用操作将显示系统是可信的。但实际上，系统已经受到攻击。启动流程见图7-15。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-15.jpg></img></div>
<div align=center>图 7-15 S3恢复攻击</div>

#### 劫持设备

TPM连接到平台主板。它可以通过低引脚数（LPC）总线、串行外设接口（SPI）总线或I2C总线连接。TCG平台TPM概述规范描述了TPM硬件接口。目前，黑客已经演示了如何劫持TPM和平台主板之间的LPC总线或I2C总线。高保障平台可以选择不暴露TPM连接。或者，如果TPM连接暴露，那么所有命令都需要使用鉴权会话，并且需要TPM EK证书验证。

#### 攻击TPM设备

根据定义，TPM设备应具有防篡改功能。然而，TPM实现可能有安全流程。例如，有一些固件TPM（fTPM）实现存在通过精心制作的EK证书远程执行代码的安全问题的实例。fTPM或离散TPM（dTPM）实现存在时序和晶格漏洞。

## 动态的测量信任根（DRTM）

SRTM面临的最大问题是，平台必须确保每次启动时都对所需的每个组件进行测量。缺少一次测量就可能导致信任链断裂。

为了缓解这一问题，TCG引入了另一种RTM —— 动态RTM（DRTM）。有了DRTM，就不再需要在平台重置后构建RTM。DRTM可以在平台启动过程的中间创建。相比之下，静态测量信任根（SRTM）需要平台重启，然后从头开始构建信任根。SRTM和DRTM的区别见图7-16。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-16.jpg></img></div>
<div align=center>图 7-16 DRTM与SRTM启动流程对比</div>

### 基于CPU的动态信任根

TCG为动态信任根测量（DRTM）定义了一些新概念。DRTM配置环境（DCE）是执行动态启动CPU指令，并将控制权转移到动态启动测量环境（DLME）的软件。DCE由DCE前言启动，它是通过调用DRTM CPU指令启动DRTM进程的代码。DCE也会检查当前环境是否满足可信执行要求。如果要求不能满足，则DCE无法进入DLME，并返回进行补救。如果所有检查都通过，DCE就会调用DLME入口点。DLME是在DCE检查并设置环境后执行的软件。DLME启动测量虚拟机监控器（MVMM）。然后，MVMM启动客户操作系统并监控系统行为。图7-17显示了DRTM启动流程。通常，DCE由CPU芯片供应商提供，DLME由操作系统供应商提供。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-17.jpg></img></div>
<div align=center>图 7-17 DRTM启动流程</div>

系统进入DLME后，BSP需要唤醒所有AP，使它们在最终执行环境中会合。图7-18展示了一种实现方法。一旦BSP进入DCE，BSP就会将所有停止的AP拉入DCE并在那里等待。DCE将控制权转移到DLME后，DLME会使用另一条CPU指令，通过在DLME中给AP一个唤醒向量来唤醒AP。DCE中的AP收到指令后，会跳转到新地址，与DLME中的 BSP会合。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-18.jpg></img></div>
<div align=center>图 7-18 DRTM应用处理器启动流程</div>

TCG DRTM规范定义了一组特殊的PCR值为DRTM使用（见表7-10）。DCE和DRTM都可以延伸TPM PCR。

表 7-10 DRTM PCR测量值
| PCR索引 | TCG定义用法 |
| :--- | :--- |
| 17 | 细节：用于记录DRTM过程中涉及的所有组件的详细测量结果，包括芯片组制造商、平台制造商和操作系统供应商提供的组件。|
| 18 | 权限：用于记录芯片组制造商组件和平台制造商组件的权限测量值。|
| 19 | DLME.Authority: 用于记录在DRTM进程结束时启动的DLEM的权限。|
| 20~22 | 为DLME/MVMM预留 |

DRTM的测量报告和验证流程与SRTM相似。DRTM延伸了TPM PCR值，并为之后的证明生成了事件日志。

系统可根据需要选择使用SRTM解决方案或DRTM解决方案。在SRTM中，系统需要将OEM BIOS添加到TCB或信任链中。如果第一条指令是BIOS复位向量，那么BIOS的初始启动块（IBB）就是C-SRTM。在这种情况下，IBB需要将测量自己和BIOS的剩余部分，并将测量值写入同一个PCR中。如果我们不信任OEM BIOS IBB，可以使用基于处理器的C-SRTM，例如英特尔Boot Guard或AMD安全启动。

如果我们不信任OEM BIOS，则可以使用DRTM。DRTM解决方案需要测量虚拟机监控器（MVMM），并依靠测量后的虚拟机监控器监控系统。

### S3恢复

DRTM中的S3恢复与SRTM不同。在SRTM中，平台进入S3状态之前，操作系统会发送TPM_Shutdown(STATE)，让TPM保存上下文。从S3恢复时，BIOS会发送TPM_Startup(STATE)，让TPM恢复上下文。TPM上下文包括所有SRTM PCR，但不包括DRTM PCR。恢复后，所有DRTM PCR复位为0xFF。

DCE前言必须重新运行DRTM指令才能进入DCE。DCE必须重新检查环境，并重新测量自身和DLME，将结果写入到TPM中。之后DLME也必须重新测量所需的组件，并恢复原始执行环境。整个过程与正常启动非常相似。

动态操作系统调用DLME_Exit时必须小心。DLME_Exit不会修改任何PCR值。因此，动态操作系统必须将一些无用值延伸到DRTM PCR中来防止受DRTMPCR保护的数据在不信任环境中解封。

DLME还必须确保内存中没有秘密。如果存在需要保存的秘密，DLME可以选择将数据封存到TPM中，或者对数据进行加密并将密钥封存到TPM中。

### DCE执行环境

DCE负责确保平台处于CPU、芯片组和平台制造商定义的值得信赖的状态。例如，当DCE执行时，所有中断必须禁用，包括外部中断、非屏蔽中断和系统管理中断。只有启动带处理器（BSP）被允许执行此动态启动指令。所有其他应用处理器（AP）必须暂停。直接内存访问（DMA）控制器应该被停止，并且DCE进程将禁止对涉及DCE状态转换的关键内存进行DMA访问。

系统管理模式（SMM）是一种特殊的主机CPU执行模式。在这种特殊模式下，SMM代码可以访问所有内存或I/O资源。普通VMM无法捕获来自SMM的任何访问。SMM代码必须保护自己不被其他硬件设备篡改。SMM代码和设置SMM环境的BIOS代码应该被测量，结果写入SRTM PCR。然后这SRTM PCR应该在验证阶段被参考。如果我们不想依赖SRTM PCR，那么DCE可以阻止SMM代码的执行，或让DLME在SMM环境中设置另一个特殊的VMM，例如SMI传输监控器（STM），以监控SMM行为（见图7-19）。这种特殊的SMM VMM应视为MVMM的一部分，并测量它，罢结果写入到DRTM PCR中。我们将在第17章讨论SMM和STM的细节。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-19.jpg></img></div>
<div align=center>图 7-19 DLME和STM</div>

直接内存访问（DMA）设备是可以通过DMA访问系统内存的设备。在DRTM中，DMA设备位于可信计算基础（TCB）之外。DCE应关闭设备的DMA或设置I/O内存管理单元（IOMMU）来阻止设备的DMA。

如果硬件设备能被限制访问平台、DCE或DLME的内存或I/O资源，则称为外围设备。另一方面，如果硬件设备不能被限制访问平台、DCE或DLME的内存或I/O资源，则称为非主机平台（NHP）。NHP通常包括执行固件和软件的独立CPU或微控制器。如果NHP不可改变，则称为固定NHP。如果NHP是可变的，则称为可更新NHP。如果可更新的NHP的状态能被DCE可靠地报告，那么它就是可由DCE验证的NHP。如果DCE无法可靠地报告某个NHP的状态，那么它就是DCE无法验证的NHP。DCE应测量或验证DCE可验证的NHP。如果NHP无法验证，DCE就必须信任它，而NHP更新机制必须包括签名验证。

### 热插拔

根据设计，如果选择DRTM，BIOS就不在可信计算基础（TCB）中，也就不需要BIOS的测量值。但是，在某些特殊情况下，我们可能仍然需要在TCB中使用某些BIOS代码。SMM就是其中一个例子。现在我们来看另一个例子 —— CPU热插拔。普通CPU可以按照前面的流程启动MVMM。热添加的CPU无法直接在测量环境中运行代码。热添加的CPU需要像普通CPU一样运行CPU复位向量。因此，BIOS代码的初始启动块必须被信任和测量。更确切地说，热添加的CPU在加入现有测量环境之前运行的任何代码必须被测量。见图7-20。因此，对于具有热插拔能力的系统，DRTM PCR和SRTM PCR都需要被参考。例如，RAS服务器平台可选择测量SMM和初始BIOS代码,把测量值写入SRTM PCR[0]中，并参考SRTM PCR[0]。不具备RAS功能的客户机平台可选择在SMM中支持VMM，这样就无需参考PCR[0]记录。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-20.jpg></img></div>
<div align=center>图 7-20 DRTM热插拔支持</div>

### 案例研究

现在，让我们看下DRTM实现的一些实例。

#### 英特尔可信执行技术（TXT）

可信执行技术是在英特尔处理器上的DRTM实现。DCE代码由英特尔SINIT验证码模块（ACM）提供。进入SINIT-ACM的CPU指令是SENTER。TXT将DLME命名为测量启动环境（MLE）。当CPU执行SENTER指令时，它会验证SINIT-ACM的签名，并执行SINIT-ACM中的代码。SINIT-ACM验证系统状态，并将控制权转移到MLE。在TXT启动过程中，ACM测量ACM信息、STM和MLE，将测量值写入到TPM PCR17和18中。表7-11显示了英特尔TXT中的PCR测量值。

表 7-11 英特尔TXT中的PCR测量值
| PCR索引 | TCG定义用法 | 英特尔TXT例子 | 
| :--- | :--- | :--- |
| 17 | 细节 | BIOS-ACM注册信息，SCRTM状态代码，平台所有者（PO）策略策略控制字段，所有匹配的策略元素，STM，操作系统SINIT表能力字段，MLE |
| 18 | 权限 | SINIT-ACM公钥，SCRTM状态代码，操作系统SINIT表能力字段，平台所有者（PO）策略策略控制字段，所有匹配的启动控制策略（LCP）元素 |
| 19 | DLME.Authority | 无 |

除了平台硬件状态检查外，SINIT-ACM还使用启动控制策略（LCP）来验证启动的软件是否符合预定义的标准，如ACM版本、STM启用状态和MLE哈希值。LCP还延伸到PCR 17和18。LCP的配置比较复杂。详情请参阅《英特尔64和IA-32架构软件开发人员手册》和《英特尔TXT软件开发指南》。

#### AMD安全虚拟机（SVM）架构

安全虚拟机（SVM）架构是AMD处理器上的DRTM实现。DCE代码可称为AMD安全加载器（SL）。进入AMD-SL的CPU指令是SKINIT。当CPU执行SKINIT指令时，它会验证SL并执行SL中的代码。SL位于安全加载块(SLB)内存中。SL验证系统状态并初始化安全内核（SK）。最后，SL将控制权转移到SK。在SL启动期间，SLB的内容被测量到PCR 17中。表7-12显示了AMD SVM中的PCR测量值。

表 7-12 AMD SVM中的PCR测量值
| PCR索引 | TCG定义用法 | AMD SVM例子 | 
| :--- | :--- | :--- |
| 17 | 细节 | 安全加载块（SLB） |
| 18 | 权限 | 无 |
| 19 | DLME.Authority | 无 |

更多详细信息，请参阅《AMD64架构程序员手册》。

英特尔TXT和AMD SVM都通过CPU指令实现动态启动（DL）事件。表7-13显示了Intel TXT和AMD SVM对TCG DRTM定义的映射。

表 7-13 DRTM内容映射
| TCG | Intel TXT | AMD SVM | 
| :--- | :--- | :--- |
| 动态启动（DL）事件 | GETSEC[SENTER] | SKINIT |
| DRTM配置环境（DCE） | SINIT认证码模块（ACM） | 安全加载（SL）|
| 动态启动测量环境（DLME） | 测量启动环境（MLE） | 安全内核（SK）|

#### tboot

英特尔和AMD都支持DRTM DCE组件。现在的问题是，DLME组件在哪里？可信启动（tboot）项目是第一个可用于Xen或Linux的开源DLME项目。

在tboot启动期间，TPM PCR也由tboot延伸。见表7-14。

表 7-14 tboot中的PCR测量值
| PCR索引 | TCG定义用法 | tboot例子 | 
| :--- | :--- | :--- |
| 17 | 细节 | tboot策略控制值，tboot策略哈希，grub.conf中的第一个模块哈希（例如Xen或Linux），所有模块哈希（除了第一个）|
| 18 | 权限 | tboot策略控制值，tboot策略哈希 |
| 19 | DLME.Authority | 无 |

让我们以Linux VMM系统为例。BIOS启动时使用Grub作为操作系统加载器。Grub加载Xen虚拟机管理程序。然后，Xen虚拟机管理程序加载客户Linux操作系统。然而，当Xen虚拟机管理程序启动时，无法保证Xen是在可信环境中运行。tboot有助于缩小差距。tboot运行在Grub和Xen虚拟机管理程序之间。它有助于建立可信环境，并将控制权转移给Xen虚拟机管理程序。tboot的第一阶段是不可信的代码。根据TCG DRTM规范，它被称为缺口。然后，tboot代码执行SENTER指令来启动SINIT-ACM。该ACM即为C-DRTM，它测量tboot，结果写入TPM PCR，然后将控制权转移到tboot第二阶段 —— DLME，该阶段被视为可信代码。然后，tboot DLME代码再次测量Xen虚拟机管理程序，结果写入TPM PCR，并将控制权传输给Xen。之后，Xen虚拟机管理程序或远程代理可使用证明来了解Xen是否在可信的环境中运行。图7-21显示了tboot流程。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-21.jpg></img></div>
<div align=center>图 7-21 tboot流程</div>

目前tboot仅支持英特尔TXT，但也有其他开源项目支持AMD SVM，例如OSLO —— 开放安全加载器 —— 或TrenchBoot。tboot仅支持Linux，不支持Windows。

#### TrenchBoot

tboot是一个DRTM挺好的参考实现。然而，使用tboot有一些限制。例如，tboot只支持英特尔TXT。TrenchBoot是在Linux中支持DRTM的安全的启动项目。它同时支持英特尔TXT和AMD SVM。例如，在AMD SVM中，SINIT指令启动SL模块。这个SL模块就是C-DRTM，它测量TrenchBoot LandingZone，然后将控制权转移到LandingZone。然后，LandingZone代码测量可信引导加载器，结果写入到TPM PCR17中，并将控制权转移到引导加载器。图7-22显示了TrenchBoot流程。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-22.jpg></img></div>
<div align=center>图 7-22 TrenchBoot流程</div>

#### Windows防御系统保卫安全启动

在2019年，微软在Windows 10版本1809中发布了"Windows防御系统保卫安全启动"。这是在Windows操作系统上的第一个正式DRTM实现。它允许非可信的UEFI固件代码启动系统，并在可信的和测量过的状态下安全地传输到Windows操作系统。这似乎是下一代安全计算基础（NGSCB）的实现，代号为Palladium，于 2003年发布。

### 攻击与缓解

现在，让我们来看一下攻击DRTM的实例与相关的缓解措施。

#### DCE恶意软件输入

DCE在建立DRTM方面发挥着重要作用。它必须检查当前的运行环境，并且不能信任来自系统的任何输入，因为是DCE创建了信任根环境。然而，由于DCE也是软件，它可能存在漏洞。它是DRTM的攻击面。

以英特尔SINIT-ACM 为例。SINIT-ACM需要解析DMA重映射（DMAR）ACPI表来设置I/O内存管理单元（IOMMU），以保护内存免受DMA攻击。DMAR ACPI表是不可信的输入，并且它可能会被恶意攻击者修改。然而，DMAR表是在验证地址之前使用的。因此，攻击者可以控制复制的内存长度，并覆盖英特尔可信执行技术 (TXT) 堆和SINIT-ACM本身。

见图7-23。左侧为正常流程。BiosData、OsMleData、OsSinitData和SinitToMleData都在TXT堆区域。前三者由DCE间隙代码设置，SINIT-ACM设置SinitToMleData, 将验证后的数据传递给MLE。运行时，SINIT-ACM需要将DMAR表复制到SinitToMleData中并验证它。因此，MLE可以使用SinitToMleData区域中验证后的DMAR表，而不是DMAR ACPI表，后者是不可信的。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-23.jpg></img></div>
<div align=center>图 7-23 通过DMAR ACPI表的SINIT-ACM攻击</div>

右侧是攻击的流程。由于TXT堆上的BiosData、OsMleData和OsSinitData是不可信的，攻击者可能会给出BiosData大小的负值。这会使SINIT-ACM计算出OsMleData和OsSinitData高于SINIT-ACM。SINIT-ACM也会SinitToMleData置于SINIT-ACM之上。在DMAR表被入侵后，因为缺少对DMAR表长度的检查，SINIT-ACM会将恶意DMAR复制到SinitToMleData中。SINIT-ACM复制了DMAR表的大块内容，并用shellcode覆盖了SINIT-ACM的开头部分。

为了防止这种软件攻击，DCE必须仔细检查所有外部输入。

#### DCE恶意硬件配置

除了软件输入外，DCE的恶意硬件配置也可能致命的。下面是攻击SINIT-ACM的另一个例子。因为SINIT-ACM需要确保DMAR表中的IOMMU引擎被正确地汇报，因此SINIT-ACM会检查硬件配置，包括内存控制器集线器（MCH）基地址寄存器（BAR）值。请参见图7-24的左侧。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-24.jpg></img></div>
<div align=center>图 7-24 通过MCH-BAR的重新配置的SINIT-ACM攻击</div>

根据芯片定义，MCH-BAR为36位。在大多数系统中，该MCH-BAR的配置低于4GB，因为早期启动代码运行在32位保护模式下。不幸的是，SINIT-ACM只检查MCH-BAR的低32位。如果攻击者指定了一些高于4GB的真实值，但分配了一个虚假的IOMMU引擎，并在低于4GB的虚假MCH配置中报告了它，那么检查可能会通过，但IOMMU引擎无法阻止DMA攻击。见图7-24右侧。

DCE不得对硬件配置作任何假设，而且必须读取寄存器的全部值来进行检查。

#### 攻击DLME的完整性

完整性问题也可能存在于DRTM中。由于DRTM比SRTM测量的组件更少，因此情况稍好一些。但是，如果缺少某些关键组件，信任链也会断裂。

以tboot为例。tboot镜像是一个典型的可执行镜像，包括代码段、只读数据段、初始化数据段和未初始化数据段。然而，攻击者可能会发现，只有代码段和只读数据段被测量。然而，初始化数据段没有被测量，但初始化数据段可能有函数指针。因此，黑客可能会将函数指针覆盖到shellcode中来伪造测量结果。见图 7-25。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-25.jpg></img></div>
<div align=center>图 7-25 tboot攻击 —— 镜像布局</div>

延伸到TPM的哈希值可能是伪造的，而不是来自测量数据的真实哈希值。这不会被TPM证明流程检测到，因为TPM引用的PCR值在硬件中，而不是从数据中计算哈希值。见图7-26。左侧是预期流程。右侧显示的是如何在S3恢复启动路径中伪造测量结果。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-26.jpg></img></div>
<div align=center>图 7-26 tboot攻击 —— PCR伪造</div>

#### 通过SMM的攻击

正如我们在DCE的执行环境中所讨论的，DRTM解决方案可以选择监控SMM或信任SMM。在当前的大多数平台中，SMM监视器不存在。因此，信任SMM是唯一的选择。然而，SMM中的漏洞可能会破坏信任链。例如，Grub操作系统加载器可能会利用SMM漏洞向SMM注入shellcode。tboot测量Xen并将其加载到内存后，SMM可能会将邪恶代码注入Xen虚拟机管理程序。这不会被检测到，因为SMM代码是在Grub感染SMM之前的启动过程中测量的，而Xen代码也是在SMM感染Xen之前由tboot测量的。所有测量结果都显示了正确的值，但实际内容却不符预期。见图7-27。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-27.jpg></img></div>
<div align=center>图 7-27 tboot攻击 —— PCR伪造</div>

#### 通过硬件配置的攻击

我们将在第十八章讨论恶意硬件配置。

DCE必须检查硬件配置和寄存器锁存。

#### 通过外设或NHP的攻击

我们将在第八章讨论DMA攻击。

DCE必须在DMA执行时使能DMA保护。

## TCG内存覆写

许多人认为，计算机断电后内存会立即被清除。然而，典型的DRAM会在数秒内逐渐丢失内容，如果芯片处于低温状态，甚至会在数分钟或数小时内丢失内容。因此，攻击者可能会突然重置系统，使可信操作系统没有机会清除内存中的秘密。然后，在下一次启动时，内存控制器初始化后，恶意程序可能会读取内存内容，窃取秘密。

为了减少重置攻击，TCG定义了内存覆写机制。当BIOS启动时，BIOS会将UEFI变量MOR设置为0来表示没有内存覆盖请求。如果操作系统想在内存中创建秘密，则会将MOR变量置1，表示存在秘密，需要在下次启动时覆写内存。如果系统正常关机，操作系统需要从内存中删除秘密，并将MOR变量重置为0。这是为了节省启动时间，因为覆写所有系统内存可能是一项耗时的工作。

但是，如果攻击者利用内存中的秘密触发恶意重置，BIOS就会发现MOR变量中存在内存覆盖请求。然后，BIOS会在DRAM控制器初始化后清除所有系统内存，使后来的程序没有机会从DRAM中转储秘密。一旦BIOS清除了秘密，就会将MOR变量重置为0，与正常启动流程相同。图7-28显示了内存中有或没有秘密的启动流程。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-28.jpg></img></div>
<div align=center>图 7-28 tboot攻击 —— PCR伪造</div>

### 安全的MOR

如果系统包含管理程序和操作系统，事情就会变得更加复杂。秘密可能由管理程序设置，但操作系统可能有能力读写UEFI变量，包括MOR变量。即使管理程序设置MOR变量来标识内存覆盖请求，后续恶意操作系统也可能清除MOR变量，并触发重置，从管理程序中读取秘密。

为了缓解这一问题，我们引入了一个MOR控制变量。这个MOR控制变量用于锁定MOR变量。管理程序将一个随机值作为密钥设置给MOR控制变量标识锁定操作。一旦MOR被锁定，任何人都不能修改该值。后续在管理程序清除秘密后，可以清除MOR值。管理程序会再次向MOR控制变量设置相同的随机值，以表示解锁操作。然后，MOR再次变为可读/可写。由于恶意操作系统不知道管理程序的随机值，恶意操作系统无法控制MOR变量的解锁，也无法向其写入内容。图7-29显示了安全MOR流程。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-29.jpg></img></div>
<div align=center>图 7-29 安全的MOR流程</div>

### 存储MOR

如果存在MOR请求，BIOS代码不但会清除内存，也会通过IEEE 1667协议或通过本地的TCG存储协议发送TCG可信外设（TPer）重置命令给存储设备。这TPer重置命令是确保在非正常重置时保护范围是锁定的。

把它们放在一起，请见图7-30。内存初始化模块获取MOR变量，并在MOR被请求时，就清除内存。TCG MOR模块获取MOR变量，并在MOR被请求时发送TPer重置。操作系统可以通过ACPI ASL接口设置或清除MOR请求。管理程序能通过MOR控制变量控制MOR配置。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-30.jpg></img></div>
<div align=center>图 7-30 内存覆写组件</div>

### 攻击与缓解

现在，让我们看下攻击TCG内存覆写的实例和缓解措施。

#### 默认MOR策略

BIOS代码需要读取MOR变量，以确定是否有内存覆盖请求。可能有这样一种情形，BIOS代码找不到任何MOR变量。糟糕的BIOS实现可能会将此解释为没有内存覆盖请求。这样，攻击者就有机会操纵闪存区域，使BIOS无法使用变量。那么，内存覆盖就不会发生。正确的做法应该是，如果MOR变量不可用，则始终将MOR请求视为存在。

## TCG物理上存在的配置

TCG规范定义了物理上存在的接口，可让用户配置TPM。我们将在第10章对此进行讨论。

## TCG存储

TCG定义了一套存储扩展来允许用户使用物理上存在的接口配置TCG存储。我们将在第10章对此进行讨论。

## 总结

在本章中，我们讨论了两种形式的可信启动 —— 静态信任根和动态信任根。这两种形式业界都有实现。我们比较了可信启动和安全启动。它们用于不同的目的。下一章，我们将讨论设备固件的安全性。

## 参考

**书**

[B-1] Sean W. Smith, Trusted Computing Platforms: Design and Applications, Springer, 2004

[B-2] Graeme Proudler, Liqun Chen, Chris Dalton, Trusted Computing Platforms: TPM2.0 in Context, Springer, 2016

[B-3] Ariel Segall, Trusted Platform Modules: Why, when and how to use them, The Institution of Engineering and Technology, 2016

[B-4] Will Arthur, David Challener, A Practical Guide to TPM2.0, Apress, 2015

[B-5] David Challener, Kent Yoder, Ryan Catherman, David Safford, Leendert Van Doom, A Practical Guide to Trusted Computing, IBM Press, 2008

[B-6] William Futral, James Greene, Intel Trusted Execution Technology for Server Platforms: A Guide to More Secure Datacenters, Apress, 2013

[B-7] David Grawrock, Dynamics of a trusted platform: a building block approach, Intel Press, 2009

[B-8] David Grawrock, The Intel Safer Computing Initiative Building Blocks for Trusted Computing, Intel Press, 2006

**会议、期刊与论文**

[P-1] David Safford, Mimi Zohar, Reiner Sailer, “Using IMA for Integrity Measurement and Attestation,” IBM 2009, available at https://blog.linuxplumbersconf.org/2009/slides/David-Stafford-IMA_LPC.pdf

[P-2] Jiewen Yao, Vincent Zimmer, “A Tour Beyond BIOS with the UEFI TPM2 Support in EDKII,” Intel whitepaper, 2014, available at https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Security-White-Papers

[P-3] Tom Dodson, “Intel Transparent Supply Chain process,” in Software and Supply Chain Assurance Forum 2017, available at https://csrc.nist.gov/CSRC/media/Projects/Supply-Chain-Risk-Management/documents/ssca/2017-winter/TuePM1_3_%20Intel.pdf

[P-4] Eduardo Cabre, Tom Dodson, “Secure Your Business: End-to-End Supply Chain Traceability,” Intel Whitepaper 2019, available at https://tsc.intel.com/documents/TSCBlockchain_white_paperFINAL.PDF

[P-5] Paul England, Andrey Marochko, Dennis Mattoon, Rob Spiger, Stefan Thom, David Wooten, “RIoT – A Foundation for Trust in the Internet of Things,” Microsoft Whitepaper 2016, available at https://www.microsoft.com/en-us/research/publication/riot-a-foundation-for-trust-in-the-internet-of-things/

[P-6] Ronald Aigner, Paul England, Kevin Kane, Andrey Marochko, Dennis Mattoon, Rob Spiger, Stefan Thom, and Greg Zaverucha, “Device Identity with DICE and RIoT: Keys and Certificates,” Microsoft Whitepaper 2017, available at https://www.microsoft.com/en-us/research/publication/device-identity-dice-riot-keys-certificates/

[P-7] Rob Spiger, Stefan Thom, “Trusted Computing and Securing Devices,” in International Trusted Computing and Security Innovation Summit 2017, available https://trustedcomputinggroup.org/wp-content/uploads/3.4_Trusted-Computing-and-Securing-Devices-2017.04.06-Final.pdf

[P-8] Bryan Kelly, “Project Cerberus Hardware Security,” in OCP Summit 2018, available at https://f990335bdbb4aebc3131-b23f11c2c6da826ceb51b46551bfafdc.ssl.cf2.rackcdn.com/images/fbbdd5feceb6e6328373417e1ab7c06a13a2ef2c.pdf

[P-9] Doug Stiles, “The Hardware Security Platform Behind Azure Sphere,” in HC30, https://old.hotchips.org/hc30/1conf/1.13_Microsoft_Hardware_Security_Platform_Behind_Azure_Sphere.pdf

[P-10] Dave Heller, Tim Block, “OpenPOWER secure and trusted boot, Part 1: Using trusted boot on IBM OpenPOWER servers,” IBM Whitepaper, 2017, https://developer.ibm.com/articles/trusted-boot-openpower/ 【1】

[P-11] Joseph Cihula, “Trusted Boot: Verifying the Xen Launch,” in Xen Summit 2007, available at www-archive.xenproject.org/files/xensummit_fall07/23_JosephCihula.pdf 【1】

[P-12] Bernhard Kauer, “OSLO: Improving the security of Trusted Computing,” in USENIX Security 2007, available at http://os.inf.tu-dresden.de/papers_ps/kauer07-oslo.pdf

[P-13] Piotr Krol, “TrenchBoot – Open DRTM implementation for AMD platforms,” in OSFC 2019, https://shop.3mdeb.com/wp-content/uploads/2021/06/TrenchBoot-Open-DRTM-implementation-for-AMD-platforms.pdf

[P-14] Daniel Kiper, Daniel P. Smith, “TrenchBoot How to nicely boot system with Intel TXT and AMD SVM,” in Linux Security Summit 2019, https://static.sched.com/hosted_files/lssna19/75/trenchboot_ot_lss_20190815.final.ds.dk.pdf

[P-15] Seunghun Han, Jun-Hyeok Park, “I don’t want to sleep tonight: Subverting Intel TXT with S3 Sleep,” in Blackhat 2018, available at https://i.blackhat.com/briefings/asia/2018/asia-18-Seunghun-I_Dont_Want_to_Sleep_Tonight_Subverting_Intel_TXT_with_S3_Sleep.pdf

[P-16] Seunghun Han, Jun-Hyeok Park, “Finally I can sleep tonight: catching sleep mode vulnerabilities of the TPM with the napper,” in Blackhat 2019, available at https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Seunghun-Finally-I-Can-Sleep-Tonight-Catching-Sleep-Mode-Vulnerabilities-of-the-TPM-with-the-Napper.pdf

[P-17] Seunghun Han, Wook Shin, Jun-Hyeok Park, and HyoungChun Kim, “A Bad Dream: Subverting Trusted Platform Module While You Are Sleeping,” in USENIX Security 2018, available at https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-han.pdf

[P-18] Seunghun Han, Jun-Hyeok Park “BitLeaker: Subverting BitLocker with One Vulnerability,” in Blackhat EU 2019, available at https://i.blackhat.com/eu-19/Thursday/eu-19-Han-BitLeaker-Subverting-BitLocker-With-One-Vulnerability.pdf

[P-19] Sven Turpe, Andreas Poller, Jan Steffan, Jan-Peter Stotz, Jan Trukenmuller, “Attacking the BitLocker Boot Process,” International Conference on Trusted Computing, Trust 2009 Trusted Computing, pp 183-196 available at http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.149.5116&rep=rep1&type=pdf

[P-20] Evan R. Sparks, “A Security Assessment of Trusted Platform Modules,” Computer Science Technical Report TR2007-597, Dartmouth College, 2007, available at https://pdfs.semanticscholar.org/b6a1/802e356f7f900bbbe8b5dc0d8d3aa7fb0ad9.pdf

[P-21] Johannes Winter, Kurt Dietrich, “A Hijacker's Guide to the LPC bus,” in EuroPKI'11 Proceedings of the 8th European conference on Public Key Infrastructures, Services, and Applications, 2011, Pages 176-193, available at https://link.springer.com/
content/pdf/10.1007/978-3-642-29804-2_12.pdf, PPT available at https://online.tugraz.at/tug_online/voe_main2.getvolltext?pCurrPk=59565

[P-22] Johannes Winter, Kurt Dietrich, “A hijacker's guide to communication interfaces of the trusted platform module,” in Journal Computers & Mathematics with Applications Volume 65 Issue 5, March, 2013, Pages 748-761, available at https://www.sciencedirect.com/science/article/pii/S0898122112004634

[P-23] Johannes Winter, “Eavesdropping Trusted Platform Module Communication,” in 4th European Trusted Infrastructure Summerschool, ETISS, 2009, available at http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.464.6048&rep=rep1&type=pdf 【1】

[P-24] Jeremy Boone, “TPM Genie,” in CanSecWest 2018, available at https://github.com/nccgroup/TPMGenie/blob/master/docs/CanSecWest_2018_-_TPM_Genie_-_Jeremy_Boone.pdf

[P-25] Denis Andzakovic, “Extracting BitLocker Keys From a TPM,” in 2019, available at https://pulsesecurity.co.nz/articles/TPM-sniffing

[P-26] K. Chen, “Reversing and exploiting an Apple firmware update,” in Blackhat US 2009, available at https://www.blackhat.com/presentations/bh-usa-09/CHEN/BHUSA09-Chen-RevAppleFirm-SLIDES.pdf

[P-27] Ralf-Philipp Weinmann , “The hidden nemesis,” in 27th Chaos Communication Congress (27C3) 2010, available at https://comsecuris.com/slides/rpw-27c3-thmbec.pdf

[P-28] Charlie Miller, “Battery Firmware Hacking,” in BlackHat US 2011, available at https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf

[P-29] Nico Waisman, Matias Sebastian Soler, “The Unbearable Lightness of BMCs,” in BlackHat US 2018, available at http://i.blackhat.com/us-18/Wed-August-8/us-18-Waisman-Soler-The-Unbearable-Lightness-of-BMC.pdf

[P-30] Joanna Rutkowska, Rafal Wojtczuk, “Preventing and Detecting Xen Hypervisor Subversions,” in BlackHat US 2008, available at https://invisiblethingslab.com/resources/bh08/part2-full.pdf

[P-31] Rafal Wojtczuk, Joanna Rutkowska, “Attack Intel TXT,” in BlackHat DC 2009, available at https://www.blackhat.com/presentations/bh-dc-09/Wojtczuk_Rutkowska/BlackHat-DC-09-Rutkowska-Attacking-Intel-TXT-slides.pdf

[P-32] Rafal Wojtczuk, Joanna Rutkowska, Alexander Tereshkin, “Another Way to Circumvent Intel® Trusted Execution Technology,” in invisiblethingslab whitepaper 2009, available at https://invisiblethingslab.com/resources/misc09/Another%20TXT%20Attack.pdf

[P-33] Rafal Wojtczuk, Joanna Rutkowska, “Attacking Intel TXT via SINIT Hijacking,” in invisiblethingslab whitepaper 2011, available at https://invisiblethingslab.com/resources/2011/Attacking_Intel_TXT_via_SINIT_hijacking.pdf

[P-34] Joseph Sharkey, “Breaking Hardware-Enforced Security with Hypervisors,” in BlackHat US 2016, available at https://www.blackhat.com/docs/us-16/materials/us-16-Sharkey-Breaking-Hardware-Enforced-Security-With-Hypervisors.pdf

[P-35] J. Alex Halderman, Seth D. Schoen, Nadia Heninger, William Clarkson, William Paul, Joseph A. Calandrino, Ariel J. Feldman, Jacob Appelbaum, and Edward W. Felten, “Lest We Remember: Cold Boot Attacks on Encryption Keys,” in Proc. 17th USENIX Security Symposium 2008, available at https://www.usenix.org/legacy/event/sec08/tech/full_papers/halderman/halderman.pdf

[P-36] Yuriy Bulygin, “Evil Maid Just Got Angrier: Why Full-Disk Encryption With TPM is Insecure on Many Systems,” in CanSecWest 2013, available at https://www.c7zero.info/stuff/Evil%20Maid%20Just%20Got%20Angrier.pdf

[P-37] “AMD PSP: fTPM Remote Code Execution via crafted EK certificate,” 2018, https://seclists.org/fulldisclosure/2018/Jan/12

[P-38] Daniel Moghimi, Berk Sunar, Thomas Eisenbarth, Nadia Heninger, “TPM-FAIL: TPM meets Timing and Lattice Attacks,” in 29th USENIX Security Symposium 2020, available at https://arxiv.org/abs/1911.05673

[P-39] Matus Nemec, Marek Sys, Petr Svenda, Dusan Klinec, Vashek Matyas, “The Return of Coppersmith’s Attack: Practical Factorization of Widely Used RSA Moduli,” in ACM CCS 2017, available at https://crocs.fi.muni.cz/_media/public/papers/nemec_roca_ccs17_preprint.pdf, https://crocs.fi.muni.cz/_media/public/papers/ccs-nemec-handout.pdf

[P-40] Paul England, Butler Lampson, John Manferdelli, Marcus Peinado, Bryan Willman, “A Trusted Open Platform,” in IEEE Computer Society 2003, available at https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/68-TrustedOpenPlatform.pdf

[P-41] Magnus Nystrom, Martin Nicholes, Vincent Zimmer, “UEFI Networking and Pre-OS Security,” in Intel Technology Journal – UEFI Today: Bootstrapping the Continuum, Volume 15, Issue 1, available at https://www.techonline.com/electricalengineers/education-training/tech-papers/4231173/UEFI-Networking-and-PreOS-Security

**规范和指南**

[S-1] NIST SP800-155, “BIOS Integrity Measurement Guidelines,” 2011, available at https://csrc.nist.gov/publications/sp800

[S-2] Trusted Computing Group, “Trusted Platform Module Library,” 2016, available at https://trustedcomputinggroup.org/resource/tpm-library-specification/

[S-3] Trusted Computing Group, “TCG PC Client Platform firmware Profile Specification,” 2019, available at https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/

[S-4] Trusted Computing Group, “TCG PC Client Platform TPM Profile (PTP) Specification,” 2019, available at https://trustedcomputinggroup.org/resource/pc-client-platform-tpm-profile-ptp-specification/

[S-5] Trusted Computing Group, “TCG Server Management Domain Firmware Profile,” 2020, available at https://trustedcomputinggroup.org/wp-content/uploads/TCG_ServerManagementDomainFirmwareProfile_v1p00_11aug2020.pdf

[S-6] Trusted Computing Group, “TCG PC Client Platform Reset Attack Mitigation Specification,” 2019, available at https://trustedcomputinggroup.org/resource/pc-client-work-group-platform-reset-attack-mitigation-specification/

[S-7] Trusted Computing Group, “TCG EFI Protocol Specification,” 2016, available at https://trustedcomputinggroup.org/resource/tcg-efi-protocol-specification/

[S-8] Trusted Computing Group, “TCG ACPI Specification,” 2017, available at https://trustedcomputinggroup.org/resource/tcg-acpi-specification/

[S-9] Trusted Computing Group, “TCG Trusted Attestation Protocol (TAP) Information Model,” 2019, available at https://trustedcomputinggroup.org/resource/tcg-tap-information-model/

[S-10] Trusted Computing Group, “TCG Platform Certificate Profile,” 2018, available at https://trustedcomputinggroup.org/resource/tcg-platform-certificate-profile/

[S-11] Trusted Computing Group, “TCG EK Credential Profile,” 2018, available at https://trustedcomputinggroup.org/resource/http-trustedcomputinggroup-org-wp-content-uploads-tcg-ek-credential-profile-v-2-5-r2_published-pdf/

[S-12] Trusted Computing Group, “TCG Reference Integrity Manifest (RIM) Information Model,” 2019, available at https://trustedcomputinggroup.org/wp-content/uploads/TCG_RIM_Model_v1-r13_2feb20.pdf

[S-13] Trusted Computing Group, “TCG PC Client Reference Integrity Manifest,” 2020, available at https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_RIM_r0p15_15june2020.pdf

[S-14] Trusted Computing Group, “TCG PC Client Platform Firmware Integrity Measurement,” 2019, available at https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client-FIM_v1r24_3feb20.pdf

[S-15] Trusted Computing Group, “Hardware Requirements for a Device Identifier Composition Engine,” 2018, available at https://trustedcomputinggroup.org/resource/hardware-requirements-for-a-device-identifier-composition-engine/

[S-16] Trusted Computing Group, “Implicit Identity Based Device Attestation,” 2018, available at https://trustedcomputinggroup.org/resource/implicit-identity-based-device-attestation/

[S-17] Trusted Computing Group, “Symmetric Identity Based Device Attestation,” 2020, available at https://trustedcomputinggroup.org/resource/symmetric-identity-based-device-attestation/

[S-18] Trusted Computing Group, “TCG DICE Layering Architecture,” 2020, available at https://trustedcomputinggroup.org/resource/dice-layering-architecture/

[S-19] Trusted Computing Group, “TCG DICE Certificate Profile,” 2020, available at https://trustedcomputinggroup.org/resource/dice-certificate-profiles/

[S-20] Trusted Computing Group, “TCG Mobile Trusted Module Specification,” 2010, available at https://trustedcomputinggroup.org/resource/mobile-phone-work-group-mobile-trusted-module-specification/

[S-21] Trusted Computing Group, “TPM 2.0 Mobile Reference Architecture Specification,” 2014, available at https://trustedcomputinggroup.org/tpm-2-0-mobile-reference-architecture-specification/

[S-22] Trusted Computing Group, “TPM 2.0 Mobile Common Profile,” 2015, available at https://trustedcomputinggroup.org/tcg-tpm-2-0-mobile-common-profile/

[S-23] Trusted Computing Group, “TCG TPM 2.0 Mobile Command Response Buffer Interface Specification,” 2014, available at https://trustedcomputinggroup.org/resource/tpm-2-0-mobile-command-response-buffer-interface-specification/

[S-24] Trusted Computing Group, “TCG Runtime Integrity Preservation in Mobile Devices,” 2019, available at https://trustedcomputinggroup.org/wp-content/uploads/TCG_MPWG_RIP_r105_pubrev.pdf

[S-25] Trusted Computing Group, “TCG Remote Integrity Verification: Network Equipment Remote Attestation System,” 2019, available at https://trustedcomputinggroup.org/wp-content/uploads/TCG-NetEq-Attestation-Workflow-Outline_v1r9b_pubrev.pdf

[S-26] Trusted Computing Group, “TCG D-RTM Architecture,” 2013, available at https://trustedcomputinggroup.org/resource/d-rtm-architecture-specification/

[S-27] GB/T 36639, “Trusted Computing Specification: Trusted Support Platform for Server,” 2018, available at http://openstd.samr.gov.cn

[S-28] GB/T 29829, “Functionality and Interface Specification of Cryptographic Support Platform for Trusted Computing,” 2013, available at http://openstd.samr.gov.cn

[S-29] GB/T 29827, “Trusted Computing Specification: Motherboard Function and Interface of Trusted Platform,” 2013, available at http://openstd.samr.gov.cn

[S-30] NISTIR 8060, “Guidelines for the Creation of Interoperable Software Identification (SWID) Tags,” 2016, available at https://csrc.nist.gov/publications/nistir

[S-31] AMD, “AMD Architecture Programmer’s Manual,” 2019, available at https://www.amd.com/en/support/tech-docs

[S-32] Intel, “Intel 64 and IA-32 Architecture Software Developer Manuals,” 2019, available at https://software.intel.com/en-us/articles/intel-sdm

[S-33] Intel, “Intel TXT Software Development Guide,” 2017, available at https://www.intel.com/content/www/us/en/content-details/315168/intel-trusted-execution-technology-intel-txt-software-development-guide.html

[S-34] Microsoft, “Secure MOR implementation,” 2017, available at https://docs.microsoft.com/en-us/windows-hardware/drivers/bringup/device-guard-requirements

[S-35] Microsoft, “DICE – Device Identifier Composition Engine,” 2015, available at https://www.microsoft.com/en-us/research/project/dice-device-identifier-composition-engine/

[S-36] OCP, “Project Cerberus Architecture Overview Specification,” 2018, available at https://github.com/opencomputeproject/Project_Olympus/blob/master/Project_Cerberus

[S-37] OCP, “Project Cerberus Firmware Challenge Specification,” 2019, available at https://github.com/opencomputeproject/Project_Olympus/blob/master/Project_Cerberus

[S-38] DMTF org, “MCTP Base Specification,” 2016, available at https://www.dmtf.org/standards/pmci

[S-39] DMTF org, “Management Component Transport Protocol (MCTP) SMBus/I2C Transport Binding Specification,” 2017, available at https://www.dmtf.org/standards/pmci

[S-40] DMTF org, “Security Protocol and Data Model Specification,” 2019, available at https://www.dmtf.org/standards/pmci

[S-41] DMTF org, “SPDM over MCTP Binding Specification,” 2019, available at https://www.dmtf.org/standards/pmci

[S-42] DMTF org, “Secure MCTP Message over MCTP Binding Specification,” 2020, available at https://www.dmtf.org/standards/pmci

[S-43] DMTF org, “Secure Messages using SPDM Specification,” 2020, available at https://www.dmtf.org/standards/pmci

