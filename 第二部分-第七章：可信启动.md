## 第七章

# 可信启动

对于开发人员来说，中情局的保密性、完整性和可用性三要素始终是最重要的。关于 "完整性"，安全启动是帮助维护平台完整性要求的珍贵功能。它也被称为验证启动。启用安全启动后，组件将在执行下一个组件之前对其进行验证。如果验证失败，下一个组件将不会被执行。这看起来非常有用。但其他软件如何知道安全启动是否已启用且启用正确？其他软件如何知道是否安全启动被错误禁用？

如今，即使我们相信系统是安全的，我们仍希望让其他实体有机会确认这种安全属性。一旦系统有办法证明它拥有这些属性，我们就可以说它是可信的。

| **注释** | “信任” 的定义不同于 “安全”。根据可信计算小组（TCG）的定义，如果一个实体总是以预期的方式达到预期的目的，那么它就是可信的。可信的系统可能不是安全的系统。例如，如果我们知道一个系统被病毒感染，而病毒每天下午5点扫描C盘，并通过http协议将所有doc文件上传到特定的 URL，那么我们就可以说这个系统是可信的，而不是安全的。|
| :--- | :--- |

TCG定义了一种让其他软件检查系统是否已启动到可信环境的方法。该过程称为TCG可信启动。

## 静态的测量信任根（SRTM）

TCG规范定义了特殊硬件 —— 可信平台模块（TPM）。TPM有一组加密引擎、非易失性存储、易失性存储和一组平台配置寄存器（PCR）。TCG规范定义了一组信任根（RoT）：

    • 测量信任根（RTM）：RTM执行初始测量过程。RTM是主机端的一些代码。在实际实现中，我们有两种不同类型的RTM —— 静态RTM（SRTM）或动态 RTM（DRTM）。我们将在后面讨论它们。RTM可能包括许多组件。在这些组件中，核心RTM（CRTM）指的是在平台重置后运行最初代码的组件。
    • 报告信任根（RTR）：RTR通过TPM PCR报告测量信息，并提供基于TPM身份验证PCR真实性的能力。
    • 存储信任根（RTS）：RTS为密钥和数据提供受保护的存储区域。

### 可信平台模块

TPM包括除了测量信任根之外的所有受信任功能。本书重点介绍如何在固件中使用TPM。有关TPM硬件及其功能的详细介绍，请参阅TPM规范或参考文献中列出的书籍。

TPM的平台配置寄存器(PCR)保存最终测量值。测量值遵循此处给出的等式。此操作为PCR扩展：

PCR<sub>(new)</sub> = HASH(PCR<sub>(old)</sub> || HASH(Data))

PCR扩展是修改PCR值的唯一方法。如果平台多次扩展PCR，所有数据都会散列到PCR中。

当平台使用SRTM时，C-SRTM是固件启动块代码。启动块固件可以是UEFI/PI BIOS中的PEI固件卷。它也可以是coreboot BIOS中的ROM阶段。如果启用了英特尔Boot Guard功能，它也可以是英特尔Boot Guard ACM。见图7-1。根据TCG平台固件概述规范，RTM需要测量所有的其他组件。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-1.jpg></img></div>
<div align=center>图 7-1 使用SRTM的固件测量</div>

根据TCG平台固件概述规范，该C-SRTM必须测量自身，并将测量值写入到PCR0中，其余组件（代码或数据）必须通过信任链测量，然后写入测量值到相应的PCR中。见表7-1。

表 7-1 SRTM PCR测量值
| PCR索引 | 用法 |
| :--- | :--- |
| 0 | SRTM，BIOS，主机平台扩展，嵌入式option ROM和PI驱动 |
| 1 | 主机平台配置 |
| 2 | UEFI驱动和应用代码 |
| 3 | UEFI驱动和应用配置和数据 |
| 4 | UEFI启动管理代码（或在主启动记录（MBR）中初始程序加载器（IPL））和启动尝试 |
| 5 | UEFI启动管理配置和数据（被启动管理代码使用）和GUID分区表（GPT）（或传统MBR分区表）|
| 6 | 主机平台特定制造商 |
| 7 | 安全启动策略 |

可信启动与安全启动不同。在安全启动中，一个组件需要认证下一个组件。安全启动需要在加载下一个组件前检查签名或哈希值。如果签名无效或哈希值不匹配，安全启动将停止平台启动。在可信启动中，一个组件在加载下一个组件之前，需要将测量下一个组件，把测量值写入到TPM PCR中。测量启动不会失败，因为在启动过程中不会执行验证。一旦系统完成启动后，其他软件将通过使用验证来检查当前状态是否与先前状态相同，从而做出安全决定。有关区别见图7-2和7-3。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-2.jpg></img></div>
<div align=center>图 7-2 安全启动和可信启动流程</div>

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-3.jpg></img></div>
<div align=center>图 7-3 安全启动对比可信启动</div>

### TPM设备类型

第一个TPM产品遵循TPM规范1.2版本，也称作TPM1.2。然而，随着时间的推移，发现，TPM1.2规范存在一些局限性。例如，TPM1.2只支持SHA1哈希算法和RSA非对称算法。一旦操作系统获得TPM1.2的所有权，平台BIOS就可能无法使用TPM。

为了解决这些限制，TCG定义了TPM规范系列2.0，又称TPM2.0。TPM2.0支持灵活的加密技术。TPM2.0设备可支持SHA1、SHA256、SM3_256或未来的算法，例如SHA3_256或SHA3_384。TPM2.0为平台固件使用定义了专用的平台层次结构。操作系统管理的存储层次结构独立于平台层次结构。TPM2.0为使用授权功能提供了统一的框架，并扩展了授权方法 —— 清晰的明文密码和基于哈希的消息验证码（HMAC）。

除了TPM1.2和TPM2.0，中国政府定义了可信密码模块（Trusted Cryptography Module，TCM）。TCM提供了报告信任根（RTR）和存储信任根（RTS），并支持可信启动。从功能角度看，它与TPM相似。例如，TCM定义了平台配置寄存器（PCR）、非易失性存储、担保密钥、身份密钥等。TCM仅支持中国加密学算法 —— SM2、SM3和SMS4。

与TPM类似，可信加密模块也是被动设备。为了支持主动测量，中国政府标准定义了可信平台控制模块（TPCM）。除了RTR和RTS外，TPCM 提供了测量信任根（RTM）。系统上电后，TPCM测量平台BIOS，并将结果记录到PCR中，然后TPCM将控制权转移给主机CPU。

### 测量值汇报

PCR保存测量组件（代码和/或数据）的最终哈希值。它可用于显示当前平台状态。然而，从PCR最终值中获取个别测量值是不可行的。但在某些情况下，可能需要单个测量值。因此，TCG定义了完整性测量事件日志来记录个别测量哈希值和测量描述。见图7-4。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-4.jpg></img></div>
<div align=center>图 7-4 TCG测量事件与PCR</div>

在系统启动期间，每当固件将测量值记录到PCR中时，相应的事件就会被添加到事件日志中。最后，事件日志将传递给操作系统（见图7-5）。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-5.jpg></img></div>
<div align=center>图 7-5 启动期间TCG测量事件日志记录</div>

由于事件日志在易失性存储中，而该内存不是报告的信任根或存储的信任根，因此事件日志不可信，必须小心谨慎。只有来自TPM芯片的PCR才是可信的。在使用事件日志时，验证者必须提取每个TCG事件，并从事件日志中重建PCR值，然后与TPM芯片中的PCR值进行比较。如果不匹配，则TCG事件日志不可信。如果两者匹配，来自TCG事件日志的摘要值才可信。

### 证明

证明是指在机器（证明人）上存在的供另一个实体（鉴定人或验证人）验证的证据。若有TPM，证据就是PCR的值。如果验证者要检查系统是否处于已知的良好状态，就必须信任PCR值的真实性。这可能发生在本地平台或远程的验证者中。如果PCR值是通过不可信的环境传输的，例如软件栈或网络，那么我们就需要TPM_Quote操作来提供保护。TPM_Quote是个命令，它使用TPM私钥给一组PCR值签名，并提供数字签名。然后，验证者可以执行数字签名验证，并信任收集到的PCR值。此时，验证器可将收集到的PCR值与一组参考PCR测量值比较，以确定这是否是预期的平台。

直接比较PCR值是一种简单的方法。但是，TPM只提供了八个PCR值供平台使用。可能有这样一种情况，平台希望在一个PCR中断言某些测量值，而跳过其他一些测量值。因此，可以使用TCG事件日志。

在基于TCG事件日志的验证中，第一步也是验证PCR值的真实性。然后，验证者需要从事件日志中重建PCR值，来验证事件日志中测量值的真实性。最后，验证者可以将收集到的完整性测量事件日志与极好的参考测量值列表进行比较。现在，可以根据验证策略支持部分比较。

图7-6显示了在NIST SP800-155中定义的验证示例。测量评估权威机构（MAA）—— 鉴定人 —— 从端设备（即证明者）处收集事件日志和 PCR。MAA还会从一组受支持的供应机构，例如原始设备制造商 (OEM) 和增值经销商 (VAR)，获取极好的测量值。然后，MAA 将事件日志与极好的测量值进行比较，看它们是否匹配。如果不匹配，MAA可以会让端设备开始修复。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-6.jpg></img></div>
<div align=center>图 7-6 使用良好的参考测量值进行测量值评估</div>

报文交换细节如图7-7所示。首先，MAA从端设备获取引用（Quote）。引用是用TPM证明密钥（AK）签名的TPM PCR值列表。引用是当前平台状态的证明。一旦MAA获取引用，MAA就会使用公开的验证密钥来验证引用值，这就是所谓的远程证明。然后，MAA从客户端收集完整的事件日志，并回放事件日志来生成PCR列表。如果生成的PCR与引用PCR匹配，则表示事件日志未被篡改。该事件日志可用于与极好的测量值比较。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-7.jpg></img></div>
<div align=center>图 7-7 TCG远程证明流程</div>

完整的远程证明还包括通过使用TPM担保密钥（EK）来验证TPM的过程。每个TPM都包含一个唯一的EK对，位于TPM上的保护位置。EK的公钥包含在EK证书中。一个EK证书用于协助验证CA签发仅用于签名目的的验证密钥 (AK)。EK证书可用提供证明AK与EK位于同一TPM上。

### S3恢复

为了提高能效，平台可能支持休眠，根据高级配置和电源接口（ACPI）规范中的定义，休眠也称为S3恢复。如果系统需要进入S3状态，操作系统会保存当前系统配置，设置操作系统唤醒向量，并写芯片专用寄存器。然后平台硬件进入S3状态。CPU和大多数设备处于关闭状态。系统内存处于自刷新状态，以保持内存内容的可用性。最终用户唤醒系统后，SRTM-BIOS开始运行。BIOS根据保存的配置初始化系统，并跳转到操作系统唤醒向量。

在正常的系统关机和系统启动过程中，操作系统向TPM发送TPM_Shutdown(CLEAR)命令，BIOS向TPM发送TPM_Startup(CLEAR)命令，它将TPM上下文重置为默认初始化状态。S3恢复则不同。为了维护信任链，操作系统需要在系统进入S3之前发送TPM_Shutdown(STATE)命令，然后TPM会保存当前上下文，包括所有PCR值。当BIOS启动时，BIOS会发送TPM_Startup(STATE)命令，将TPM恢复到进入S3之前的原始状态，包括所有PCR值。在正常的S3恢复中，不需要为SRTM执行PCR扩展。

然而，如果TPM_Startup(STATE)由于某种原因失败，SRTM需要尝试TPM_Startup(CLEAR)来重新启动TPM。如果TPM重启成功，SRTM需要向PCR扩展错误代码，因为SRTM在S3中以不同的启动路径运行，不可能重放正常启动流程以创建相同的PCR。

### 设备标识符合成引擎（DICE）

TPM广泛应用于个人计算、移动、和服务器平台。然而，物联网（IoT）市场可能会有不同的解决方案，应对功耗、安全性、资源和其他方面的挑战。并非所有物联网系统和组件都采用TPM。因此，TCG创建了设备标识符合成引擎（DICE）工作组，以开发新的方法来提高安全性和隐私性，同时将芯片要求降至最低。即使是最微小的微控制器也能支持DICE，以建立设备标识并执行证明和安全固件更新。

图7-8显示了DICE的基本思想。不可改变ROM —— DICE硬件引擎将唯一设备机密（UDS）和启动代码的哈希结合起来，创建一个基于哈希的消息认证码（HMAC）。该HMAC用作设备的复合设备标识（CDI）。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-8.jpg></img></div>
<div align=center>图 7-8 DICE SOC</div>

等式是：

    CDI = HMAC(UDS, Hash(Code))

如果更新了固件启动代码，就会自动生成新的CDI。这可能是一项功能。但是，如果旧CDI被用于设备标识，则补丁过的设备上的新CDI将无法识别。这可能会带来一些可管理性问题。更好的解决方案是将代码分层。见图7-9。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-9.jpg></img></div>
<div align=center>图 7-9 分层的DICE架构</div>

CDI由带有UDS的SOC硬件和启动代码的哈希值生成。然后，DICE核心（第0层）使用CDI派生设备ID密钥对。设备ID密钥对是设备的标识符，不应在DICE核心之外泄露。为了在不暴露设备ID密钥的情况下证明对设备ID私有部分的了解，DICE核心需要为下一层生成一个新的密钥对。这个密钥对被称为别名密钥。别名密钥对派生自CDI和下一层（设备固件）的标识。该密钥可传递给设备固件层，并且密钥的私有部分可在设备固件生命周期内使用。设备固件需要确保别名密钥不会泄露到设备固件之外。设备固件更新会导致别名密钥对更新，但不会影响设备ID密钥对。DICE核心也会为使用设备ID私钥签名的别名密钥创建证书和自签名设备ID证书。设备ID证书在设备生命周期内不会更改，而别名密钥证书则会在固件更新时频繁更改。

DICE核心实现可以容易的扩展到多层启动。每一层都会为下一层创建新的别名密钥和别名证书。签发给下一层的别名证书由当前层授予的别名密钥签名。

DICE和TPM使用不同的密钥保护机制。在TPM解决方案中，密钥存储和使用在一个由硬件和软件组合而成的隔离环境中，并且密钥可随时使用。这被称为*空间上*的保护。DICE设计依赖于密钥的*时间上*的保护。密钥来自于启动链中的前一个组件，仅在当前组件中使用，然后在将控制权转移到下一个组件之前从内存中删除。使用密钥的加密操作只能在有限的时间内执行。图7-10和7-11显示了两者的区别。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-10.jpg></img></div>
<div align=center>图 7-10 TPM密钥保护</div>

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-11.jpg></img></div>
<div align=center>图 7-11 DICE密钥保护</div>

DICE规范仍在开发中。更多的细节请参考最新的DICE文档。

### 案例研究

现在。让我们看一下SRTM实现的一些实例。

#### UEFI BIOS中的测量启动支持

当前的UEFI BIOS实现，例如基于EDK II的实现，支持TCG可信启动。UEFI BIOS测量所需的组件，例如PEI模块、DXE模块、SMM模块、UEFI驱动程序和数据（如配置变量）等，到相应的PCR。图7-12和表7-2显示了平台中的组件及其相应的PCR值。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-12.jpg></img></div>
<div align=center>图 7-12 UEFI BIOS中的PCR</div>

表 7-2 UEFI BIOS中的PCR测量
| PCR索引 | TCG定义的用法 | UEFI例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | CRTM，平台固件（PEI、DXE、SMM、UEFI启动服务、UEFI运行时服务、嵌入式去驱动），非主机固件存在（类型、版本）|
| 1 | 主机固件配置 | CMOS配置，UEFI启动变量，UEFI配置变量， ACPI表，SMBIOS表，Microcode，底座 |
| 2 | UEFI驱动代码 | Option ROM，设备固件，非主机固件 |
| 3 | UEFI驱动配置和数据 | Option ROM配置，设备固件配置，非主机固件配置 |
| 4 | UEFI启动管理代码 | 操作系统启动程序 |
| 5 | UEFI启动管理代码配置和数据 | UEFI启动操作，GPT分区 |
| 6 | 主机平台特定制造商 | 无 |
| 7 | 安全启动策略 | UEFI安全启动策略（PK、KEK、db、dbx、dbt、dbr、安全启动状态、审计模式、部署模式），安全状态，调试状态 |

系统固件贡献了大部分的PCR测量。非主机固件或设备上的任何运行代码也应该被测量。对于设备而言，可能有两种不同的代码 —— 系统固件和Option ROM。系统固件指的是设备上运行的代码，它为主机提供服务。Option ROM是一种特殊类型的固件，它在主机端运行，并在操作系统驱动程序可用之前作为BIOS环境中的设备驱动程序工作。通常情况下，PCI存储卡、PCI图形卡或PCI网卡都可能有一个Option ROM。

系统固件完成初始化后，它测量操作系统启动程序，并将控制权移交给操作系统启动程序。然后，操作系统启动程序测量操作系统内核和启动参数，然后操作系统启动程序将控制权转移给操作系统内核。为了让操作系统启动程序重新使用BIOS中的测量代码，BIOS需要暴露一个测量接口，例如传统的INT 1A TCPA服务、TPM1.2 EFI_TCG_PROTOCOL，或TPM2.0 EFI_TCG2_PROTOCOL。

BIOS还需要提供一种让操作系统获取TCG事件日志的方法。对于TPM1.2，事件日志通过TCPA ACPI表传递。TPM2.x支持多种散列算法，而 TPM1.2只支持SHA1散列算法。在引入TPM2.x时，TCG增加了第二类事件日志。一种与TPM1.2兼容，仅支持SHA1。另一种使用新格式，支持多种散列算法。如今，由于SHA1已被弃用，因此只使用新格式的事件日志。它可以通过TCG2_PROTOCOL的GetEventLog()函数或从TPM2 ACPI表中获取。

为了映射到现实世界，表7-3显示了在TCG可信启动流程中BIOS与操作系统的交互方式。

表 7-3 在操作系统启动期间的PCR测量步骤
| 步骤 | 传统操作系统（Windows/Linux） | UEFI Windows | UEFI Linux | 定制的BIOS/操作系统 |
| :--- | :--- | :--- | :--- | :--- |
| BIOS将测量操作系统启动程序。 | 传统的BIOS测量主启动记录（MBR）内容 | UEFI BIOS测量botmgr.efi | UEFI BIOS测量grub.efi | BIOS内部行为。它应该知道操作系统启动程序在哪，并且是什么格式。在传递控制权给它之前测量它。|
| BIOS暴露测量服务给操作系统启动程序。 |TPM1.2 INTA 1A TCPA（16位实模式）| EFI_TCG_PROTOCOL。TPM1.2 HashLogextendevent()。EFI_TCG2_PROTOCOL。TPM2.0 HashLogextendevent()。 | EFI_TCG_PROTOCOL。TPM1.2 HashLogextendevent()。EFI_TCG2_PROTOCOL。TPM2.0 HashLogextendevent()。 | 它可能不需要。如果操作系统启动程序知道怎样与测量设备交互。|
| BIOS暴露TCG日志事件给操作系统。 | TPM1.2 TCPA ACPI表 | TPM1.2 TCPA ACPI表。TPM2.0 EFI_TCG2_PROTOCOL GetEventLog()和FINAL_EVENTS_TABLES或TPM2 ACPI表 | TPM1.2 TCPA ACPI表。TPM2.0 EFI_TCG2_PROTOCOL GetEventLog()和FINAL_EVENTS_TABLES或TPM2 ACPI表 | ACPI表或可能使用私有接口 |
| 操作系统启动程序可能在操作系统驱动准备使用之前使用BIOS测量服务来延伸操作系统内核。| 传统的启动程序（MBR和其扩展）测量操作系统内核的其余部分。| bootmgr.efi测量Windows操作系统内核。| grub.efi测量命令和内核文件。| 厂商特定的加载程序测量厂商特定的内核。|
| 一旦控制权传递到操作系统，BIOS服务就不可用。操作系统使用自己的驱动来延伸更多的组件。| 传统的操作系统内核测量剩余的。| Windows操作系统内核测量剩余的。| Linux操作系统内核测量剩余的。| 内核测量剩余的。|

《超越BIOS之旅：在EDK II中实现TPM2.0支持》描述了关于在EDK II BIOS中TPM支持的更多细节。

#### 英特尔Boot Guard

之前介绍的UEFI实现假设PEI代码是测量的信任根。如果平台启用了英特尔Boot Guard，则Boot Guard ACM就是信任根。Boot Guard ACM不仅要验证初始启动块（IBB），还要测量IBB，并写测量值到TPM PCR中。由Boot Guard ACM延伸的PCR列在表7-4中。简而言之，PCR[0]记录详细信息，PCR[7]记录权限。

表 7-4 英特尔Boot Guard中的PCR测量值
| PCR索引 | TCG定义的用法 | Boot Guard ACM例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | 细节：ACM策略状态（测量启动，验证启动），ACM安全版本号（SVN），ACM签名，密钥清单签名，启动策略清单签名，初始化启动块（IBB）哈希 |
| 1 | 主机固件配置 | 无 |
| 2 | UEFI驱动代码 | 无 |
| 3 | UEFI驱动配置和数据 | 无 |
| 4 | UEFI启动管理代码 | 无 |
| 5 | UEFI启动管理代码配置和数据 | 无 |
| 6 | 主机平台特定制造商 | 无 |
| 7 | 安全启动策略 | 权限：ACM策略状态（测量启动，验证启动），ACM安全版本号（SVN），ACM公钥哈希，密钥清单公钥哈希，启动策略清单公钥哈希 |

由于Boot Guard ACM需要使用TPM，因此必须启动TPM。如果Boot Guard ACM在locality 3中启动TPM，则必须创建TCG_EFI_STARTUP_LOCALITY_EVENT来记录此类信息。

#### coreboot中的测量启动支持

coreboot也支持TCG可信启动。然而，coreboot解决方案不使用TCG平台固件概述，而是用自己的方式使用TPM替代。表7-5显示了coreboot中PCR的用法。

表 7-5 coreboot中的PCR测量值
| PCR索引 | TCG定义的用法 | coreboot例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | 谷歌VBoot GBB flags |
| 1 | 主机固件配置 | 谷歌VBoot GBB HWID |
| 2 | UEFI驱动代码 | 核心测量信任根，包括所有的阶段，数据和blobs，例如COREBOOT CBFS（启动块，fallback/verstage），FW_MAIN CBFS（fallback/romstage, fspm, fallback/postcar, fallback/ramstage, cpu_microcode_blob, fsps, vbt, fallback/dsdt.aml, fallback/payload），RD_VPD，GBB，SI_DESC，SI_GBE |
| 3 | UEFI驱动配置和数据 | 运行时数据，像hwinfo.hex或MRC缓存，例如SI_ME，RW_NVRAM |
| 4 | UEFI启动管理代码 | 无 |
| 5 | UEFI启动管理代码配置和数据 | 无 |
| 6 | 主机平台特定制造商 | 无 |
| 7 | 安全启动策略 | 无 |

与UEFI相似，coreboot解决方案使用ACPI表来传递事件日志信息。TCPA ACPI表包含TPM1.2的事件日志信息，TPM2 ACPI表包含TPM2.0的事件日志信息。

#### Windows BitLocker

BitLocker是在Windows操作系统中提供磁盘加密的一项功能。TPM作为一种硬件解决方案，可在不需要用户交互的情况下辅助密钥保护。TPM可以存储由PCR锁定的某些数据，并且只有在PCR匹配时才解锁数据。这就是所谓的密封。该密封过程用于在供给阶段保存BootLocker密钥加密密钥。在每次启动阶段，BitLocker都会尝试从TPM中解封密钥，并使用该密钥解密磁盘加密密钥。这一解封过程可确保在并且仅在当前系统状态（记录在PCR中）与密钥配置时的状态相同时，密钥才会被解密。见图7-13。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-13.jpg></img></div>
<div align=center>图 7-13 TMP使用PCR密封/解封</div>

默认情况下，BitLocker将密钥与PCR 0、2和4绑定，这些PCR会记录平台上运行的代码。由于系统固件更新会导致PCR0的值发生变化，因此BitLocker恢复功能将被触发，最终用户需要提供任何一个恢复密码或恢复密钥才能解锁设备。因此，如果UEFI安全启动已启用，且PCR7已正确延伸，则BitLocker 将密钥绑定到PCR7。BitLocker利用安全启动来完成完整性验证。表7-6显示了Windows操作系统中PCR的用法。关于BitLocker的详细信息，请参考Microsoft BitLocker文档。

表 7-6 BitLocker中的PCR测量值
| PCR索引 | Wndows操作系统 |
| :--- | :--- |
| 0 | 核心系统固件可执行代码 |
| 1 | 核心系统固件数据 |
| 2 | 扩展的或可插入可执行代码 |
| 3 | 扩展的或可插入固件数据 |
| 4 | 启动管理/传统的MBR |
| 5 | GPT/分区表/传统的MBR分区表 |
| 6 | 从S4和S5电源状态事件恢复 |
| 7 | 安全启动状态 |
| 8 | 保留的/传统的NTFS启动扇区 |
| 9 | 保留的/传统的NTFS启动块 |
| 10 | 保留的/传统的启动管理 |
| 11 | BitLocker访问控制 |
| 12 | 数据事件和高度不稳定事件 |
| 13 | 启动模块细节 |
| 14 | 启动权限 |
| 15~23 | 保留 |

#### Grub

Grub是大多数Linux系统的默认操作系统启动程序。如果系统中存在TPM，Grub会测量可执行的命令和文件，并将测量值记录到TPM中。表7-7显示了在Grub中的PCR用法。

表 7-7 Grub中的PCR测量值
| PCR索引 | Grub |
| :--- | :--- |
| 8 | Grub命令行: 所有带有前缀“grub_cmd:”的输入的可执行命令（包括那些来自配置文件的）会被记录并且被测量。内核命令行：任何带有前缀“kernel_cmdline:”输入的传递给内核的命令行将被记录和测量。模块命令行：任何带有前缀“module_cmdline:”的输入的传递给内核模块的命令行将被记录和测量。|
| 9 | 文件：任何以与文件名相对应的描述性文本的由Grub读取的文件将被记录与测量 |

#### Linux完整性测量架构

Linux完整性测量架构是为内核完整性设计的。内核完整性的目标是检测文件是否被意外或恶意修改，将文件的测量值与极好的值进行比较，并执行本地文件完整性。

完整性测量架构（IMA）在Linux 2.6.30内核中首次引入。它包括三个组件：IMA测量、IMA评估和IMA审计。IMA在TPM中维护运行时测量值列表和PCR聚合值。在TPM有聚合值的益处是，如果列表被修改，修改可以通过重建PCR值来检测到。IMA使用PCR[10]来记录文件的测量值。

#### OpenPOWER可信启动

IBM OpenPOWER服务器实现了可信启动过程让用户验证服务器仅运行来自IBM或其他可信供应商的授权固件组件。OpenPOWER中PCR的用法与TCG定义的PCR类似。PCR[0,1]用于主机平台；PCR[2,3]用于附加的组件；PCR[4,5]用于启动状态转换。表7-8显示了OpenPOWER中PCR的用法。

表 7-8 OpenPOWER中PCR测量值
| PCR索引 | TCG定义的用法 | OpenPOWER例子 |
| :--- | :--- | :--- |
| 0 | CRTM，主机平台代码 | Hostboot和其他固件组件 |
| 1 | 主机固件配置 | 配置数据和固件容器元数据 |
| 2 | UEFI驱动代码 | IBM一致性加速处理器接口（CAPI）代码 |
| 3 | UEFI驱动配置和数据 | IBM一致性加速处理器接口（CAPI）数据 |
| 4 | UEFI启动管理代码 | 开放式电源抽象层（oPAL）固件、静态操作系统（Linux内核和initramfs）|
| 5 | UEFI启动管理代码配置和数据 | TPM使能flags，开放式电源抽象层（oPAL）容器元数据，启动序列，静态操作系统配置（Linux内核命令行）|
| 6 | 主机平台特定制造商 | 保留 |
| 7 | 安全启动策略 | 保留 |

#### 供应链验证

供应链是公司与其供应商之间的网络，用于生产特定产品并将其分销给最终买家。攻击者可能会在供应商发货后、最终买家收到产品前篡改组件（硬件、固件或软件）。买家如何确保收到的产品是供应商发货的产品？

NIST SP800-155提供了BIOS完整性测量、报告、收集和传输的指导原则。测量评估机构（MAA）可以判断系统是否符合预期，这一点已在"验证和证明"章节进行了讨论。除了参考测量，TCG也定义了由OEM和/或VAR提供的平台证书。该证书描述了EK证书、平台属性（例如平台制造商字符串、平台型号、平台版本和TPM）以及平台断言（如测量根类型）。这概念如图7-6所示。

美国国家安全局（NSA）开源了一个名为在运行时和启动时的主机完整性（HIRS）的原型来说明供应链验证能力。平台制造商创建基础平台证书。系统集成商和增值经销商创建差异化平台证书。认证证书颁发机构（ACA）可为TPM提供认证身份凭证（AIC）。在运行时，ACA可以执行担保凭据证书链验证来验证TPM使用的担保密钥是否由原始设备制造商（OEM）放置；还可以执行平台凭据证书链验证，并通过将测量到的组件信息与平台凭证中列出的制造商、型号和序列号进行比较，来验证系统硬件组件的来源，例如主板和机箱。

英特尔透明供应链是供应链验证的另一种实现方式。它实现了英特尔vPro系统的平台级和组件级的可追溯性。

#### Project Cerberus

Cerberus平台要求活动组件通过设备标识符组合引擎（DICE）支持硬件和固件组合标识。见图7-14。每个DICE层的测量（由如下公式计算）：

    Measurement = HMAC(Seed, Hash(Code))

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-14.jpg></img></div>
<div align=center>图 7-14 Cerberus架构</div>

Seed通常来自上一层的测量结果或别名密钥证书。因此，最终测量结果是所有层的链式测量结果。

平台活动信任根（PA-RoT）可使用证明消息与主动组件信任根（AC-RoT）通信。证明消息接口使用在SMBus/I2C消息协议之上的管理组件传输协议（MCTP）。PA-RoT始终是MCTP主机。AC-RoT可配置为端点或端点和主机。通过使用MCTP RoT命令，PA-RoT和AC-RoT可以建立平台级信任根。表7-9列出了PA或AC可以使用的一组RoT命令。有关详细信息，请参阅Cerberuss规范。其中部分命令与我们将在第8章讨论的安全协议和数据模型（SPDM）消息相同。

表 7-9 Cerberus RoT命令列表
| 注册名 | 信任根 | 描述 |
| :--- | :--- | :--- |
| 固件版本（Firmware Version）| PA/AC | 接收固件版本信息 |
| 设备能力（Device Capabilities）| PA/AC | 接收设备能力 |
| 设备ID（Device ID）| PA/AC | 接收设备ID |
| 导出证书（Export Certificate）| PA/AC | 导出证书签名请求（CSR）|
| 获取摘要（GET_DIGEST）| PA/AC | PA/AC | PA-RoT接收会话信息 |
| 获取证书（GET_CERTIFICATE）| PA/AC | PA-RoT基于会话查询设置会话变量 |
| 质疑（CHALLENGE）| PA/AC | PA-RoT接收和验证证书 |
| 密钥交换（Key Exchange）| PA | 交换前置主会话密钥 |
| 获取日志（Get Log）| PA | 接收调试，证明和篡改日志 |
| 平台配置注册（Platform Configuration Register）| PA | 返回平台测量 |
| 延伸平台配置注册（Extend Platform Configuration Register）| PA | 延伸平台测量 |
| 解封消息（Unseal Message）| PA | 解封证明质疑 |
| 解封消息结果（Unseal Message Result）| PA | 获取解封的状态和结果 |

#### 微软Azure Sphere: Pluton

Microsoft Azure Sphere是一个安全的高级应用平台，它对链接互联网的设备具有内置通信和安全功能。它包括一个安全、连接、交叉的微控制器单元（MCU）。Pluton安全子系统是Azure Sphere的防篡改，基于硬件的信任根。它具有加密引擎，并为安全启动验证提供服务。

除了安全启动，Pluton安全子系统还支持芯片上的测量启动和远程验证。在启动过程中，Pluton会记录所有启动组件的哈希值。当Azure Sphere设备连接到Azure Sphere安全服务（AS3）时，设备会使用本地存储的证书验证服务器认证。同时，AS3也通过远程证明认证设备本身。Pluton会返回哈希值以及使用证明密钥的签名的哈希值的签名。由于AS3拥有设备证明密钥，AS3可以确定设备是否真实，以及设备是否使用正版软件启动。

#### 思科信任锚

思科使用信任锚技术为思科可信系统提供基础。除安全启动外，思科信任锚模块（TAm）还可用于验证硬件真实性。操作系统可以检查TAm是否有安全的唯一设备标识符 (SUDI)，该标识符只能来自思科。SUDI在制造过程中被永久编程到TAm中来支持供应链验证。

### 攻击与缓解

现在，让我们来看一下一些攻击SRTM的实例和缓解措施。

#### 完整性攻击

完整性是可信计算面临的最大挑战。最终解决方案必须测量所有可变组件和配置，以便进行验证。在实践中，一些固件可能无法测量所有固件代码。这样就无法检测到代码的变化。另外，有些固件可能无法测量所有与安全相关的设置。如果安全设置关闭，它也不会被检测到。

非主机固件也有问题。研究人员已经证明了替换键盘固件、嵌入式控制器（EC）固件、基板管理控制器（BMC）固件、电池固件和其他系统板固件的能力。因此，黑客可以记录用户的按键操作、远程控制系统或控制电池充电。不过，这些设备的固件可能无法在当前的大部分系统中测量到。

以Stuxnet病毒为例。Stuxnet病毒通常是由一个可以实际访问系统的人通过受感染的USB闪存盘引入供应网络的。然后，蠕虫在网络中传播，扫描计算机上的软件，控制可编程逻辑控制器（PLC）。Stuxnet将受感染的rootkit引入PLC，修改代码并向PLC发出意想不到的命令，同时向用户返回一个正常运行值反馈循环。问题如下：我们是否应该测量USB端口是否被阻塞？是否要测量USB闪存设备固件？是否应该测量USB闪存设备上的内容？是否应该测量控制PLC设备的软件？是否应该测量PLC代码？

测量中的任何缺失都是潜在的攻击点。

#### 攻击S3恢复

如前所述，正常的S3恢复过程包括TPM_Shutdown(STATE)和TPM_Startup(STATE)。如果操作系统被黑，操作系统在将系统置于S3状态时就可以跳过TPM_Shutdown(STATE)命令。在S3恢复状态下，当BIOS SRTM向TPM发送TPM_Startup(STATE)命令时，TPM就会失效。如果坏的SRTM实现忘记发送TPM_Startup(CLEAR)，或者忘记扩展错误代码，那么当系统启动时，TPM PCR全为零。之后，TPM PCR值就会被被攻击的操作系统伪造。根据PCR值，远程TPM引用操作将显示系统是可信的。但实际上，系统已经受到攻击。启动流程见图7-15。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-15.jpg></img></div>
<div align=center>图 7-15 S3恢复攻击</div>

#### 劫持设备

TPM连接到平台主板。它可以通过低引脚数（LPC）总线、串行外设接口（SPI）总线或I2C总线连接。TCG平台TPM概述规范描述了TPM硬件接口。目前，黑客已经演示了如何劫持TPM和平台主板之间的LPC总线或I2C总线。高保障平台可以选择不暴露TPM连接。或者，如果TPM连接暴露，那么所有命令都需要使用鉴权会话，并且需要TPM EK证书验证。

#### 攻击TPM设备

根据定义，TPM设备应具有防篡改功能。然而，TPM实现可能有安全流程。例如，有一些固件TPM（fTPM）实现存在通过精心制作的EK证书远程执行代码的安全问题的实例。fTPM或离散TPM（dTPM）实现存在时序和晶格漏洞。

## 动态的测量信任根（DRTM）

SRTM面临的最大问题是，平台必须确保每次启动时都对所需的每个组件进行测量。缺少一次测量就可能导致信任链断裂。

为了缓解这一问题，TCG引入了另一种RTM —— 动态RTM（DRTM）。有了DRTM，就不再需要在平台重置后构建RTM。DRTM可以在平台启动过程的中间创建。相比之下，静态测量信任根（SRTM）需要平台重启，然后从头开始构建信任根。SRTM和DRTM的区别见图7-16。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-16.jpg></img></div>
<div align=center>图 7-16 DRTM与SRTM启动流程对比</div>

### 基于CPU的动态信任根

TCG为动态信任根测量（DRTM）定义了一些新概念。DRTM配置环境（DCE）是执行动态启动CPU指令，并将控制权转移到动态启动测量环境（DLME）的软件。DCE由DCE前言启动，它是通过调用DRTM CPU指令启动DRTM进程的代码。DCE也会检查当前环境是否满足可信执行要求。如果要求不能满足，则DCE无法进入DLME，并返回进行补救。如果所有检查都通过，DCE就会调用DLME入口点。DLME是在DCE检查并设置环境后执行的软件。DLME启动测量虚拟机监控器（MVMM）。然后，MVMM启动客户操作系统并监控系统行为。图7-17显示了DRTM启动流程。通常，DCE由CPU芯片供应商提供，DLME由操作系统供应商提供。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-17.jpg></img></div>
<div align=center>图 7-17 DRTM启动流程</div>

系统进入DLME后，BSP需要唤醒所有AP，使它们在最终执行环境中会合。图7-18展示了一种实现方法。一旦BSP进入DCE，BSP就会将所有停止的AP拉入DCE并在那里等待。DCE将控制权转移到DLME后，DLME会使用另一条CPU指令，通过在DLME中给AP一个唤醒向量来唤醒AP。DCE中的AP收到指令后，会跳转到新地址，与DLME中的 BSP会合。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-18.jpg></img></div>
<div align=center>图 7-18 DRTM应用处理器启动流程</div>

TCG DRTM规范定义了一组特殊的PCR值为DRTM使用（见表7-10）。DCE和DRTM都可以延伸TPM PCR。

表 7-10 DRTM PCR测量值
| PCR索引 | TCG定义用法 |
| :--- | :--- |
| 17 | 细节：用于记录DRTM过程中涉及的所有组件的详细测量结果，包括芯片组制造商、平台制造商和操作系统供应商提供的组件。|
| 18 | 权限：用于记录芯片组制造商组件和平台制造商组件的权限测量值。|
| 19 | DLME.Authority: 用于记录在DRTM进程结束时启动的DLEM的权限。|
| 20~22 | 为DLME/MVMM预留 |

DRTM的测量报告和验证流程与SRTM相似。DRTM延伸了TPM PCR值，并为之后的证明生成了事件日志。

系统可根据需要选择使用SRTM解决方案或DRTM解决方案。在SRTM中，系统需要将OEM BIOS添加到TCB或信任链中。如果第一条指令是BIOS复位向量，那么BIOS的初始启动块（IBB）就是C-SRTM。在这种情况下，IBB需要将测量自己和BIOS的剩余部分，并将测量值写入同一个PCR中。如果我们不信任OEM BIOS IBB，可以使用基于处理器的C-SRTM，例如英特尔Boot Guard或AMD安全启动。

如果我们不信任OEM BIOS，则可以使用DRTM。DRTM解决方案需要测量虚拟机监控器（MVMM），并依靠测量后的虚拟机监控器监控系统。

### S3恢复

DRTM中的S3恢复与SRTM不同。在SRTM中，平台进入S3状态之前，操作系统会发送TPM_Shutdown(STATE)，让TPM保存上下文。从S3恢复时，BIOS会发送TPM_Startup(STATE)，让TPM恢复上下文。TPM上下文包括所有SRTM PCR，但不包括DRTM PCR。恢复后，所有DRTM PCR复位为0xFF。

DCE前言必须重新运行DRTM指令才能进入DCE。DCE必须重新检查环境，并重新测量自身和DLME，将结果写入到TPM中。之后DLME也必须重新测量所需的组件，并恢复原始执行环境。整个过程与正常启动非常相似。

动态操作系统调用DLME_Exit时必须小心。DLME_Exit不会修改任何PCR值。因此，动态操作系统必须将一些无用值延伸到DRTM PCR中来防止受DRTMPCR保护的数据在不信任环境中解封。

DLME还必须确保内存中没有秘密。如果存在需要保存的秘密，DLME可以选择将数据封存到TPM中，或者对数据进行加密并将密钥封存到TPM中。

### DCE执行环境

DCE负责确保平台处于CPU、芯片组和平台制造商定义的值得信赖的状态。例如，当DCE执行时，所有中断必须禁用，包括外部中断、非屏蔽中断和系统管理中断。只有启动带处理器（BSP）被允许执行此动态启动指令。所有其他应用处理器（AP）必须暂停。直接内存访问（DMA）控制器应该被停止，并且DCE进程将禁止对涉及DCE状态转换的关键内存进行DMA访问。

系统管理模式（SMM）是一种特殊的主机CPU执行模式。在这种特殊模式下，SMM代码可以访问所有内存或I/O资源。普通VMM无法捕获来自SMM的任何访问。SMM代码必须保护自己不被其他硬件设备篡改。SMM代码和设置SMM环境的BIOS代码应该被测量，结果写入SRTM PCR。然后这SRTM PCR应该在验证阶段被参考。如果我们不想依赖SRTM PCR，那么DCE可以阻止SMM代码的执行，或让DLME在SMM环境中设置另一个特殊的VMM，例如SMI传输监控器（STM），以监控SMM行为（见图7-19）。这种特殊的SMM VMM应视为MVMM的一部分，并测量它，罢结果写入到DRTM PCR中。我们将在第17章讨论SMM和STM的细节。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-19.jpg></img></div>
<div align=center>图 7-19 DLME和STM</div>

直接内存访问（DMA）设备是可以通过DMA访问系统内存的设备。在DRTM中，DMA设备位于可信计算基石（TCB）之外。DCE应关闭设备的DMA或设置I/O内存管理单元（IOMMU）来阻止设备的DMA。

如果硬件设备能被限制访问平台、DCE或DLME的内存或I/O资源，则称为外围设备。另一方面，如果硬件设备不能被限制访问平台、DCE或DLME的内存或I/O资源，则称为非主机平台（NHP）。NHP通常包括执行固件和软件的独立CPU或微控制器。如果NHP不可改变，则称为固定NHP。如果NHP是可变的，则称为可更新NHP。如果可更新的NHP的状态能被DCE可靠地报告，那么它就是可由DCE验证的NHP。如果DCE无法可靠地报告某个NHP的状态，那么它就是DCE无法验证的NHP。DCE应测量或验证DCE可验证的NHP。如果NHP无法验证，DCE就必须信任它，而NHP更新机制必须包括签名验证。

### 热插拔

根据设计，如果选择DRTM，BIOS就不在可信计算基石（TCB）中，也就不需要BIOS的测量值。但是，在某些特殊情况下，我们可能仍然需要在TCB中使用某些BIOS代码。SMM就是其中一个例子。现在我们来看另一个例子 —— CPU热插拔。普通CPU可以按照前面的流程启动MVMM。热添加的CPU无法直接在测量环境中运行代码。热添加的CPU需要像普通CPU一样运行CPU复位向量。因此，BIOS代码的初始启动块必须被信任和测量。更确切地说，热添加的CPU在加入现有测量环境之前运行的任何代码必须被测量。见图7-20。因此，对于具有热插拔能力的系统，DRTM PCR和SRTM PCR都需要被参考。例如，RAS服务器平台可选择测量SMM和初始BIOS代码,把测量值写入SRTM PCR[0]中，并参考SRTM PCR[0]。不具备RAS功能的客户机平台可选择在SMM中支持VMM，这样就无需参考PCR[0]记录。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-20.jpg></img></div>
<div align=center>图 7-20 DRTM热插拔支持</div>

### 案例研究

现在，让我们看下DRTM实现的一些实例。

#### 英特尔可信执行技术（TXT）

可信执行技术是在英特尔处理器上的DRTM实现。DCE代码由英特尔SINIT验证码模块（ACM）提供。进入SINIT-ACM的CPU指令是SENTER。TXT将DLME命名为测量启动环境（MLE）。当CPU执行SENTER指令时，它会验证SINIT-ACM的签名，并执行SINIT-ACM中的代码。SINIT-ACM验证系统状态，并将控制权转移到MLE。在TXT启动过程中，ACM测量ACM信息、STM和MLE，将测量值写入到TPM PCR17和18中。表7-11显示了英特尔TXT中的PCR测量值。

表 7-11 英特尔TXT中的PCR测量值
| PCR索引 | TCG定义用法 | 英特尔TXT例子 | 
| :--- | :--- | :--- |
| 17 | 细节 | BIOS-ACM注册信息，SCRTM状态代码，平台所有者（PO）策略策略控制字段，所有匹配的策略元素，STM，操作系统SINIT表能力字段，MLE |
| 18 | 权限 | SINIT-ACM公钥，SCRTM状态代码，操作系统SINIT表能力字段，平台所有者（PO）策略策略控制字段，所有匹配的启动控制策略（LCP）元素 |
| 19 | DLME.Authority | 无 |

除了平台硬件状态检查外，SINIT-ACM还使用启动控制策略（LCP）来验证启动的软件是否符合预定义的标准，如ACM版本、STM启用状态和MLE哈希值。LCP还延伸到PCR 17和18。LCP的配置比较复杂。详情请参阅《英特尔64和IA-32架构软件开发人员手册》和《英特尔TXT软件开发指南》。

#### AMD安全虚拟机（SVM）架构

安全虚拟机（SVM）架构是AMD处理器上的DRTM实现。DCE代码可称为AMD安全加载器（SL）。进入AMD-SL的CPU指令是SKINIT。当CPU执行SKINIT指令时，它会验证SL并执行SL中的代码。SL位于安全加载块(SLB)内存中。SL验证系统状态并初始化安全内核（SK）。最后，SL将控制权转移到SK。在SL启动期间，SLB的内容被测量到PCR 17中。表7-12显示了AMD SVM中的PCR测量值。

表 7-12 AMD SVM中的PCR测量值
| PCR索引 | TCG定义用法 | AMD SVM例子 | 
| :--- | :--- | :--- |
| 17 | 细节 | 安全加载块（SLB） |
| 18 | 权限 | 无 |
| 19 | DLME.Authority | 无 |

更多详细信息，请参阅《AMD64架构程序员手册》。

英特尔TXT和AMD SVM都通过CPU指令实现动态启动（DL）事件。表7-13显示了Intel TXT和AMD SVM对TCG DRTM定义的映射。

表 7-13 DRTM内容映射
| TCG | Intel TXT | AMD SVM | 
| :--- | :--- | :--- |
| 动态启动（DL）事件 | GETSEC[SENTER] | SKINIT |
| DRTM配置环境（DCE） | SINIT认证码模块（ACM） | 安全加载（SL）|
| 动态启动测量环境（DLME） | 测量启动环境（MLE） | 安全内核（SK）|

#### tboot

英特尔和AMD都支持DRTM DCE组件。现在的问题是，DLME组件在哪里？可信启动（tboot）项目是第一个可用于Xen或Linux的开源DLME项目。

在tboot启动期间，TPM PCR也由tboot延伸。见表7-14。

表 7-14 tboot中的PCR测量值
| PCR索引 | TCG定义用法 | tboot例子 | 
| :--- | :--- | :--- |
| 17 | 细节 | tboot策略控制值，tboot策略哈希，grub.conf中的第一个模块哈希（例如Xen或Linux），所有模块哈希（除了第一个）|
| 18 | 权限 | tboot策略控制值，tboot策略哈希 |
| 19 | DLME.Authority | 无 |

让我们以Linux VMM系统为例。BIOS启动时使用Grub作为操作系统加载器。Grub加载Xen虚拟机管理程序。然后，Xen虚拟机管理程序加载客户Linux操作系统。然而，当Xen虚拟机管理程序启动时，无法保证Xen是在可信环境中运行。tboot有助于缩小差距。tboot运行在Grub和Xen虚拟机管理程序之间。它有助于建立可信环境，并将控制权转移给Xen虚拟机管理程序。tboot的第一阶段是不可信的代码。根据TCG DRTM规范，它被称为缺口。然后，tboot代码执行SENTER指令来启动SINIT-ACM。该ACM即为C-DRTM，它测量tboot，结果写入TPM PCR，然后将控制权转移到tboot第二阶段 —— DLME，该阶段被视为可信代码。然后，tboot DLME代码再次测量Xen虚拟机管理程序，结果写入TPM PCR，并将控制权传输给Xen。之后，Xen虚拟机管理程序或远程代理可使用证明来了解Xen是否在可信的环境中运行。图7-21显示了tboot流程。

<div align=center><img src=Figures/Chapter-7-Screenshot/Figure-7-21.jpg></img></div>
<div align=center>图 7-21 tboot流程</div>

目前tboot仅支持英特尔TXT，但也有其他开源项目支持AMD SVM，例如OSLO —— 开放安全加载器 —— 或TrenchBoot。tboot仅支持Linux，不支持Windows。

#### TrenchBoot