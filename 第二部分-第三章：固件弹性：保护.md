## 第三章

# 固件弹性：保护

固件弹性包括三个元素：保护、检测和恢复。保护是指保护固件组件免受攻击。保护是固件弹性的一个主动方面，而检测和恢复是被动机制。对于弹性而言，主要威胁来自软件攻击者和硬件攻击者。

## 弹性构建块

弹性构建块包括三个部分：

    1） 弹性目标：它是可改变的引擎，包括代码和数据。
    2） 弹性引擎：为弹性目标提供服务的不可改变的引擎，例如保护、验证、更新或恢复。
    3） 弹性授权机构：授权弹性引擎在弹性目标上执行服务的实体。

在弹性引擎内部存在三个主要块：

    1） 安全执行环境（SEE）：这是一个安全的执行立足点来确保一个妥协的弹性目标不会影响恢复。
    2） 保护锁存，例如写入锁和读取锁：这是为了确保在弹性引擎中的永久的储存不能被妥协的弹性目标篡改。
    3） 看门狗计时器：这是为了确保妥协的弹性目标不能影响弹性引擎执行恢复动作。

图3-1显示了弹性构建块。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-1.jpg></img></div>
<div align=center>图 3-1 弹性构建块</div>

为了支持关键弹性，我们需要定义一组信任根（RoTs）。这些信任根包括更新信任根（RTU）、检测信任根（RTD）、恢复信任根（RTRec）。一些功能也能在锚定在信任根中的信任链（CoT）中实现。我们也需要定义相关的更新信任链（CTU）、检测信任链（CTD）和恢复信任链（CTRec）。那些弹性信任根（RTRes）在弹性引擎中，并且提供服务，例如保护与更新、检测和恢复。我们将在第3、4和5章中逐一讨论。

一个平台可能有不同的固件组件。我们做了如下分类：

    • 不可改变的ROM（包括代码和数据）
    • 可更新的固件（包括代码和数据）
    • 配置数据

基于这些分类，我们可能使用不同的保护机制。

## 不可改变的ROM

一个不可改变的ROM在系统中是不能升级的逻辑。它被认为是信任根（RoT）。不可改变的ROM包括代码和数据。通常，不可改变的ROM的范围应该足够小，以便于审查与审计，以确保无bug。其优点是保护策略很简单 —— ROM必须永远锁定。其缺点是一旦发现在不可改变的ROM中发现安全问题，没有机会去修复，并且设备应该被丢弃。

### 完整性

基本的安全要求是ROM的完整性。一旦ROM被锁定，没有人可以写入它。通常，这种保护是由硬件端完成，以防止软件攻击。但我们也需要考虑硬件攻击。硬件攻击者可能劫持平台上的系统总线来绕过保护。平台可以锁定SPI控制器中的串行外围接口（SPI）闪存区块。因此，没有人可以向SPI设备发送命令，但硬件攻击者可能直接对SPI芯片添加闪存编程器，并且对整个SPI芯片烧录。或者硬件攻击者可能会附加一个额外的SPI芯片来提供备用代码和数据。作为一种缓解措施，平台需要确保ROM在平台内部，并且不暴露任何可编程接口。

### 机密性

机密性也需要考虑。如果不可改变的ROM包括私钥，则密钥任何时候都不得暴露。根据Kerckhoffs原则，除了私钥之外，整个不可改变的ROM都可以暴露。对于高度关键的设备或系统，整个不可改变的ROM也需要加密或不能被外部读取，因为保证ROM机密可以使破坏设备或系统变得困难。内部细节只能出于审计目的公开。

### 案例研究

现在，让我们看看不可改变的ROM的一些真实案例。

#### 移动、桌面和服务器中的不可改变的ROM

不可改变的ROM可能存在于个人的计算机或服务器中。片上ROM中的X86 CPU Microcode是不可改变的。会有CPU Microcode更新在运行时通过patch RAM来修补Microcode，但是基本的芯片内部的CPU Microcode是不可改变的。

平台可以设计一个单独的芯片作为信任根（RoT）。芯片上的不可改变的ROM验证系统固件和一些设备固件，因此，它创建了信任链（CoT）。例子包括谷歌设计的Titan芯片、苹果设计的T2芯片、AMD设计的AMD平台安全处理器、开源计算项目（OCP）定义的Cerberus安全架构和英特尔的平台固件弹性（PFR）。一个传统的X86系统见图3-2。这信任根固件验证主要的BIOS和关键启动固件，例如管理引擎（ME）固件，服务器的基板管理控制器（BMC）固件和客户端系统的嵌入式控制（EC）固件。然后主要的BIOS验证非关键启动固件（例如非易失性存储接口（NVMe）固件，传感器固件和音频固件）。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-1.jpg></img></div>
<div align=center>图 3-2 移动、桌面和服务器中的平台组件</div>

我们将在第4章讨论信任根和信任链的更多细节。

#### 嵌入式和物联网（IoT）领域中的不可改变的ROM

在嵌入式领域，ARM为A系列（应用处理器，AP）和M系列（微控制器）定义了平台安全架构（PSA）来提供针对物联网（IoT）设备的指南。平台安全架构的信任根包括硬件和不可改变的固件。可信固件A（Trusted-Firmware-A）是ARM系统A系列可信固件设计的参考实现（见图3-3）。可信的ROM是不可改变的固件。上电时，应用处理器（AP）在重置向量执行可信的ROM。然后可信的ROM验证并加载可信固件。可信固件验证和加载运行时固件的额外部分和非安全固件。可信固件可能也验证系统控制处理器（SCP）固件如果它存在。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-3.jpg></img></div>
<div align=center>图 3-3 ARM A系列中的平台组件</div>

可信固件M（Trusted-Firmware-M）是ARM系统M系列可信固件设计的参考实现（见图3-4）。因为微控制器（MC）只有受限的于执行环境，其启动流程就简单的多。微控制器在重置向量执行MCUBoot ROM。MCUBOOT验证所有重置的固件包括安全固件的安全分区管理（SPM）和非安全的固件。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-4.jpg></img></div>
<div align=center>图 3-4 ARM M系列中的平台组件</div>

我们将在第4章更详细地讨论平台安全架构。

#### 特别的恢复镜像

通常，系统固件没有不可改变的部分。为了修复安全问题，所有的固件必须可升级。唯一可能的例外称之为特别的恢复镜像。特别的恢复镜像是当系统固件不能启动时仅用在恢复阶段的固件。然而，制作不可改变的特别的恢复镜像是非常危险的。在特别的系统固件中任何安全漏洞都会成为致命弱点（阿喀琉斯之踵）。如果这类安全漏洞被暴露，所有的攻击者需要做的是在更新期间移除电源来触发恢复过程。然后他们能攻击特别的恢复镜像。

我们将在第5章中讨论恢复处理的更多细节。

### 攻击与缓解

现在，让我们看一下针对不可改变的ROM和可能的缓解措施的一些真实的案例。

#### 机密

不可改变的ROM可能包含机密 —— 平台的根密钥用来派生密钥的支撑物或用来证明身份的私钥。这机密不能以任何方式暴露。例如，如果机密保存在外部的非易失性存储或暴露在类似动态随机存取存储器（DRAM）或SPI总线等总线上，则可能意味着风险。

## 可升级的固件

通常，系统固件是可升级的。平台制造商可以发布新的固件来修复功能性问题或安全问题。板子上的任一设备固件是可升级的。这新的设备固件可以是设备制造商发布的独立包或是集成到平台制造商整个系统更新包的一部分。

根据NIST SP800-193，可升级固件的保护基于三个原则：

    • 已验证的更新机制
    • 完整性保护
    • 不可绕过

### 已验证的更新机制

已验证的更新机制的指导如下：

    • 更新镜像应该由经批准的数字签名算法进行签名
    • 更新镜像应该由经授权的实体进行签名，例如设备制造商、平台制造商或可信的第三方
    • 更新镜像应该在更新到非易失性存储前优先由信任根进行验证

当我们选择数字签名算法时，我们需要考虑政府对算法要求和密钥长度要求。当我们设计解决方案时，我们需要考虑加密灵活性。因此，当要求改变时，它能很容易地迁移到新的算法。实践上，使用PKCS#7是不错的选择，因为它定义了描述密码消息的语法。不同的算法，例如RSA2048/RSA3072或SHA256/SHA384，可以由PKCS#7证书描述。代码不需要显式地选择使用哪种算法。然而，PKCS#7可以包含X.509证书，解析X.509证书很复杂，并且需要大量内存。在资源受限的环境中，例如只有静态随机存取存储器（SRAM）或有限的动态随机存取存储器（DRAM），它可能需要直接使用没有任何封装的算法。

| **注释** | 校验或循环冗余校验在安全世界毫无意义。它们只能用于检测简单的错误，而不是攻击。|
| :--- | :--- |

验证和更新应该在可信执行环境中进行。可信执行环境可能是早期的没有任何第三方代码或不可信代码执行的启动阶段，或它可能是处理器特定的隔离环境，例如英特尔系统管理模式（SMM）或ARM TrustZone，或它可能使用服务器的基板管理控制器（BMC）。我们将在第17章讨论可信执行环境和管理模式的更多细节。

固件更新可以在操作系统环境中进行。例如，Windows和Linux提供了有关怎样使用UEFI定义的胶囊格式在操作系统环境中初始化系统固件更新的指导。

除了系统固件，设备固件可能也需要支持更新。IETF创建了物联网软件更新（SUIT）组为10KB以下随机存取存储器和100KB以下闪存的物联网设备提供了指导。TCG嵌入式工作组提供了TCG嵌入式系统软件和固件的安全更新指导。DMTF公布了固件更新平台级别数据模型（PLDM）规范，它定义了平台管理子系统设备上用于更新固件组件的消息和数据结构。

#### 案例研究

现在，让我们看一下已验证更新机制的一些真实案例。

##### 签名的UEFI胶囊更新

由于安全原因，大部分系统固件支持更新闪存，但是它可以锁定闪存，保护在某些启动过程中不被写入，而提供完整性保护（见图3-5）。因此，直接更新闪存是不可能。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-5.jpg></img></div>
<div align=center>图 3-5 正常启动禁止闪存更新</div>

UEFI规范定义了胶囊机制来让操作系统通过一个新的固件镜像压缩当前的固件并且发起一次重置。重置强制让系统在系统固件里开始执行。在下一次的启动中，固件检测到待定的固件镜像胶囊，然后它使闪存区块解锁，并且处理更新请求（见图3-6）。固件镜像胶囊必须放在可读写的非易失性存储中，因为内容必须保留，即使经过重置。候选者包括系统存储、硬驱、非易失性双列直插存储器模块（NVDIMMs），甚至是临时的闪存存储区域。非易失性存储的完整性不需要确保，因为固件在更新之前必须验证固件镜像胶囊。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-6.jpg></img></div>
<div align=center>图 3-6 更新模式下允许的闪存更新</div>

下文是UEFI胶囊更新在EDK II BIOS的实现。内存中的胶囊镜像见图3-7。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-7.jpg></img></div>
<div align=center>图 3-7 UEFI胶囊更新流程（胶囊在内存中）</div>

步骤0：在系统启动期间，CapsuleRuntimeDxe驱动暴露UEFI运行时更新胶囊服务。操作系统代理加载胶囊镜像到内存，然后调用这个服务来触发胶囊更新。最终，它把胶囊信息放置到UEFI变量中，并且使用重置系统运行时服务重置系统。

步骤1：在下一次启动中，PlatformPei模块检测固件镜像胶囊的存在并且设置启动模式为胶囊更新。

步骤2：内存初始化之后，MemoryInit驱动调用胶囊预先可扩展固件接口初始化（PEI）驱动合并分散的胶囊碎片。胶合并之后，在胶囊切换块（HOB）中汇报新的胶囊位置，切换块传递信息到驱动执行环境（DXE）阶段。然后MemoryInit安置永久的系统内存。

步骤3：所有的驱动程序在驱动执行环境（DXE）阶段完成后，系统进入启动设备选择（BDS）阶段。如果启动模式设置为胶囊更新，PlatformBds驱动将处理在胶囊切换块中汇报的胶囊镜像。然后，新的固件镜像将被验证，闪存区块将被更新。

内存中的胶囊解决方案要求内存中的内容即使经过重置也是保留的。如果系统支持S3恢复或内存内容保留的热重置，我们可以使用这方法。然而，一些嵌入式系统和服务器不支持那些选项。在这种情况下，我们可能把胶囊放在硬驱中。这方法有时候也被称之为磁盘上的胶囊。

磁盘上的胶囊镜像见图3-8。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-8.jpg></img></div>
<div align=center>图 3-8 UEFI胶囊更新流程（胶囊在磁盘上）</div>

步骤0：操作系统代理把胶囊镜像放在磁盘上，并且在UEFI变量中设置标志来表明磁盘上有新的胶囊（镜像）等待处理。然后操作系统代理调用重置系统UEFI运行时服务重置系统。

步骤1：在下一次启动中，PlatformPei模块通过读取UEFI变量检测固件镜像胶囊的存在并且设置启动模式为胶囊更新。

步骤2：由于胶囊不在内存中，内存初始化流程不受磁盘上的胶囊方法的影响。在预先可扩展固件接口初始化（PEI）阶段完成之前，DxeIpl模块调用CapsuleOnDiskLoader函数从磁盘加载胶囊到内存。在胶囊切换块（HOB）中汇报新的胶囊位置。

步骤3：所有的驱动程序完成后，系统进入启动设备选择（BDS）阶段。在胶囊更新启动模式下，PlatformBds驱动会在胶囊切换块中处理胶囊镜像。然后，新的固件镜像会被验证，闪存区块会被更新。

无论使用随机存取存储器中的胶囊还是磁盘上的胶囊，胶囊（磁盘或随机存取存储器）和胶囊UEFI变量被认为是外部输入。因此，UEFI变量在使用前必须检查，并且胶囊的内容必须签名。签名的胶囊格式在UEFI规范中定义。

UEFI规范定义了可扩展固件接口_固件_管理_协议（EFI_FIRMWARE_MANAGEMENT_PROTOCOL，EMP）作为系统固件或设备固件更新流程的标准接口。图3-9描述了UEFI固件管理协议胶囊镜像的数据结构。如果使用了UEFI固件管理协议基于胶囊的更新，平台厂商或设备厂商将发布遵循定义在UEFI规范中的数据结构的新固件。然后终端用户将使用操作系统的接口发送镜像到平台固件让它执行更新。旧的固件必须验证固件镜像的可靠性来确保它来自可信的来源。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-9.jpg></img></div>
<div align=center>图 3-9 UEFI胶囊数据结构</div>

《超越BIOS教程：EDK II中胶囊更新与恢复》详细的描述了整个更新流程。

新固件镜像的安全验证应该考虑两个部分：签名验证与版本验证。固件更新胶囊必须经过签名，如此更新机制能检查内容的完整性。UEFI固件管理协议要求可扩展固件接口_固件_镜像_认证（EFI_FIRMWARE_IMAGE_AUTHENTICATION）结构在实际的有效载荷的镜像之前，并且它要求证书类型为EFI_CERT_TYPE_PKCS7_GUID。认证信息是PKCS7签名。胶囊更新机制从固件中提取可信的证书，并且使用可信的证书验证PKCS7签名。如果胶囊没有EFI_FIRMWARE_IMAGE_AUTHENTICATION结构，或者签名验证失败，这个胶囊必须忽略。

除了签名验证，更新机制也应该检查胶囊版本来防止回滚攻击。版本检查要求胶囊镜像中的版本必须高于或等于当前固件的最小支持镜像版本。当前的UEFI规范没有定义版本和最小支持镜像版本值在胶囊镜像中如何存储。EDK II实现定义了FMP_PAYLOAD_HEADER在镜像数据之前。如果在FMP_PAYLOAD_HEADER中的版本小于当前固件的最小支持版本，这胶囊应该被忽略。

##### 操作系统运行时更新

之前的胶囊更新流程需要包括系统重置。有时系统重置花费较长时间。如果系统使用案例花费太长时间，运行时更新是迫切需要的。为了保持完整性，认证和更新流程必须在可信执行环境中进行，例如X86系统的系统管理模式（SMM）或ARM系统的TrustZone安全世界。图3-10显示了基于系统管理模式的操作系统运行时更新流程。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-10.jpg></img></div>
<div align=center>图 3-10 操作系统运行时更新</div>

##### 带外（OOB）更新

服务器平台通常在服务器机房内。当闪存需要更新时，我们可以希望使用系统发起更新的远程能力。DMTF RedFish规范提供了远程管理能力，并且支持通过网络上的RedFish协议进行远程固件更新。如果服务器有支持RedFish的基板管理控制器（BMC）[下文用BMC替代]，远程系统可以通过带外网络端口发送新的固件给BMC。BMC器保存固件镜像到BMC的内存中。如果BMC能访问系统固件闪存区块，BMC可以直接使用新的镜像更新闪存。或者BMC可以保存固件并且等待BIOS的下一次启动。BIOS RedFish驱动可以通过带内的端口从BMC那获取新的固件镜像，并且处理固件镜像。由于新的固件镜像来自于不可信的来源，在用新的镜像更新闪存区块前，要求BMC或BIOS完成镜像的认证。

图3-11显示了BIOS的基于BMC带外更新。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-11.jpg></img></div>
<div align=center>图 3-11 带外更新</div>

##### 英特尔BIOS Guard

在之前的解决方案中，BIOS，可信执行环境（SMM，TrustZone）或管理控制器（BMC）被视作是更新的信任根。然而，它们是更大的代码的一部分，它们可能提供较大的攻击面，因此，潜在的漏洞更多。在更新信任根中的漏洞可能影响固件的完整性。不幸的是，这种事件已经有了实际案例。例如，攻击者破坏了胶囊合并过程并更新了BIOS。攻击者削弱了系统管理模式保护并更新了BIOS（ThinkPwn）。因此，更小的更新信任根是迫切需要的，以减少攻击面。

英特尔BIOS Guard是固件更新的深度防御解决方案。它只允许英特尔BIOS Guard AC模块（BGMod）在系统管理模式环境中对闪存设备进行编程。这个模块在已验证的代码随机存取存储器（ACRAM）环境中执行固件验证与更新。这样设计是防止固件启动流程或系统管理模式中的早期问题影响验证与更新的流程（见图3-12）。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-12.jpg></img></div>
<div align=center>图 3-12 基于英特尔BIOS Guard的固件更新</div>

英特尔BIOS Guard定义了如下的数据结构（见图3-13）：

    • BIOS Guard目录：这是在系统管理模式中的动态构建数据结构。它记录了BiosGuard、BGPDT、BGUP与BGUPC的地址。
    • BIOS Guard平台数据表（BGPDT）：这是在系统管理模式中的动态构建数据结构。它记录了平台信息、安全版本号、嵌入式控制器（EC）描述符和已签名的闪存地址映射（SFAM）。嵌入式描述符仅用于带嵌入式控制器的平台。
    • BIOS Guard更新包（BGUP）：这包括BIOS镜像数据和闪存更新脚本。它应该在构建时创建。
    • BIOS Guard更新包证书：这是BIOS Guard更新包的签名证书。它应该在构建时创建。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-13.jpg></img></div>
<div align=center>图 3-13 英特尔BIOS Guard示意图</div>

表 3-1 英特尔BIOS Guard中的密钥使用
| **密钥** | **验证的对象** | **存储位置** | **由谁验证** |
| :--- | :--- | :--- | :--- |
| BGMod 密钥 | BIOS Guard模块 | CPU | Microcode |
| BIOS Guard公钥 | BIOS Guard更新包 | CPU MSR PROT_HASH，在启动期间编程 | BIOS Guard模块 |

图3-14显示了基于英特尔BIOS Guard的固件更新。表3-1显示了密钥在英特尔BIOS Guard的使用。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-14.jpg></img></div>
<div align=center>图 3-14 英特尔BIOS Guard流程</div>

步骤0：固件更新代理加载BIOS Guard更新包（BGUP）和证书到内存中，并且触发系统管理中断（SMI）。

步骤1：系统管理模式中断由BiosGuardSmm处理。

步骤2：BiosGuardSmm复制BIOS Guard更新包和BIOS Guard更新包证书到系统管理模式随机存取存储器（SMRAM），然后创建平台数据表（BGPDT）和BIOS Guard目录。BIOS Guard目录持有BGMod、BGPDT、BGUP、BGUPC的指针。

步骤3：BiosGuardSmm将BG目录放入BG参数特定模式寄存器（MSR）并写入BG更新触发器特定模式寄存器（MSR）。

步骤4：CPU验证BiosGuard模块的签名。如果验证通过，CPU加载BiosGuard模块到已验证的代码随机存取存储器（ACRAM）。BiosGuard模块使用BiosGuard目录获取BIOS Guard更新包和BIOS Guard更新包证书。BiosGuard模块依赖证书和版本信息完整验证。然后BiosGuard模块执行更新脚本更新闪存区域。

由于最后的验证和闪存更新是由BiosGuard模块在已验证的代码随机存取存储器中执行的，即使系统管理模式区域是受损的，验证也没法绕过。

##### Microcode更新

X86 CPU有片上的microcode和patch RAM，可以对micorcode修补和更新。这种更新可以通过重置时类似补丁等功能在早期的启动期间进项，其中micorcode的补丁由固件接口表（FIT）发现。或者，补丁由BIOS加载，例如DXE驱动使用PI多处理器协议为每个CPU更新。除了BIOS使用补丁，操作系统也可以使用补丁（修复）。由于patch RAM是易失性的，补丁更新必须在所有平台启动模式下执行。

##### ARM可信固件更新

在嵌入式与物联网领域，闪存更新机制与传统的客户端或服务器平台是不同的。ARM定义了平台安全架构用于可信启动和固件升级（TBFU）。它提供了ARM系统的安全固件更新的指导。除了规范，开源的ARM可信固件是ARM安全平台架构可信启动和固件升级的参考实现。

在Github上有两种类型的ARM可信固件。可信固件A是对应ARM A系列应用处理器的，可信固件M是对应ARM M系列微控制器的。

可信固件A定义了一组启动程序：

    • BL1：应用处理器可信ROM（S-EL3）
    • BL2：可信启动固件（S-EL1）
    • BL31：EL3运行时软件（S-EL3）
    • BL32：安全的EL1有效载荷（可信操作系统）（S-EL1）
    • BL33：非安全的固件，例如UEFI或U-Boot
    • SCP_BL1：系统控制处理器（SCP）启动ROM
    • SCP_BL2: 系统控制处理器（SCP）RAM固件

它也定义了固件更新镜像：

    • BL2U：应用处理器固件更新配置
    • NS_BL1U：应用处理器固件更新启动ROM
    • NS_BL2U：应用处理器更新程序
    • SCP_BL2U：系统控制处理器（SCP）固件更新配置

详细的可信启动流程将在第四章描述。这儿我们仅讨论固件更新的相关的信息。

在可信固件A中，BL1是更新信任根（RTU）。BL1启动ROM安全监控调用（SMC）处理者支持固件更新。这个处理者与NS_BL1U非安全世界启动ROM交互来验证BL2U、NS_BL2U、SCP_BL2U。验证通过后，BL1启动ROM加载相关的BL2U，让BL2U进行一些配置来完成固件更新操作。BL2U镜像也会传输SCP_BL2U到系统控制处理器的随机存取存储器，并且让SCP_BL2U进行一些配置来完成固件更新操作。图3-15显示了可信固件A的更新流程。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-15.jpg></img></div>
<div align=center>图 3-15 ARM可信固件A更新支持</div>

可信固件M使用不同的方式进行固件更新。它依赖如下的启动程序：

    BL2 MCUBoot: MCB启动ROM
    安全分区管理（SPM）：安全世界
    非安全世界固件

MCUBoot是更新的信任根（RTU）。闪存划分为不可改变ROM、插槽0、插槽1和擦写区（见图 3-16）。BL2 MCUBoot是不可改变的区域。当前的镜像（安全固件和非安全固件）在活跃的镜像内 —— 称之为插槽0。新的镜像（安全固件和非安全固件）放置在暂存区域 —— 称之为插槽1。在系统启动期间，BL2MCUBoot检查是否有新镜像在插槽1中，如果存在则验证新的镜像。如果新镜像通过认证，MCUBoot就会在更新过程中交换插槽0和插槽1。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-16.jpg></img></div>
<div align=center>图 3-16 ARM可信固件M更新支持</div>

##### 微软组件固件更新（CFU）

当设备固件需要更新时，新的固件应该签名，并且更新应该在可信环境中进行。当前，有不同的方式更新系统上的设备组件（见表3-2）。

表 3-2 组件更新机制
| **机制** | **优点** | **缺点** |
| :--- | :--- | :--- |
| 独立的工具 | 支持特定的组件协议。 | 需要用户找到并下载工具，并确认更新是否可用且适用。|
| UEFI更新胶囊驱动 | 可通过操作系统（Windows或Linux）更新流程推送。| 只能在启动期间更新组件，但那时组件可能不可用或不可连接。|
| 特定的组件更新驱动 | 可在设备枚举时运行 | 带来了为每个特定的组件协议编写固件更新驱动的负担。|

微软定义了组件固件更新 (CFU) 模型来统一操作系统环境中更新设备固件的不同方式（见图 3-17）。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-17.jpg></img></div>
<div align=center>图 3-17 组件固件更新</div>

在组件固件更新中，新的组件固件由windows更新发送给主要的组件。主要的固件可以将新的固件镜像发送给之一相连的子组件。

组件固件更新定义了一组固件更新的命令，如表3-3所示。

表 3-3 组件固件更新命令列表
| **命令** | **描述** |
| :--- | :--- |
| GET_FIRMWARE_VERSION | 获取主要的组件及其子组件的当前固件版本。|
| FIRMWARE_UPDATE_OFFER | 确定主组件是接受还是拒绝固件。|
| FIRMWARE_UPDATE_OFFER(Information) | 仅提供主机到组件的信息。它允许主机向设备提供特定的信息，例如START_OFFER_LIST, END_OFFER_LIST和START_ENTIRE_TRANSACTION。|
| FIRMWARE_UPDATE_OFFER(Extented) | 主机向设备固件提供命令。它具有可扩展性，是一种主机向设备提供特定信息的方式。|
| FIRMWARE_UPDATE_CONTENT | 提供固件内容（例如固件镜像）。整个镜像文件不要期望能在一条单一的命令里完成。主机必须将镜像分割成小块，每条命令一次发送一个小块。|

组件固件更新命令是基于人机接口设备协议（HID），它可以通过任何内部总线传输。如果总线在协议中规定了可靠传输，例如USB和蓝牙，上层可以直接发送命令。对于那些协议中不保证可靠传输的总线，例如通用异步接受/发送（UART），内部集成电路（I2C）或串行外设接口（SPI），上层需要在较低层的协议之上实现可靠的传输机制。

组件固件更新不指定认证策略、加密策略、回滚策略或受损固件的恢复。固件镜像验证必须由接受镜像的组件完成，而不是主机CPU驱动。一些组件固件可能只有有限的电池电量，并且下载固件可能耗费巨大的电量。因此，在下载固件之前，组件固件更新可以指定镜像的特殊属性作为镜像提供的一部分，例如版本、硬件平台等等。如果组件拒绝了提供的内容，下载可以避免。但即使组件接受了提供的内容，下载的镜像可能在之后因为完整性验证失败而被拒绝。

完整的更新流程显示在图3-18中。

<div align=center><img src=Figures/Chapter-3-Screenshot/Figure-3-18.jpg></img></div>
<div align=center>图 3-18 组件固件更新流程</div>
