## 第三章

# 固件弹性：保护

固件弹性包括三个元素：保护、检测和恢复。保护是指保护固件组件免受攻击。保护是固件弹性的一个主动方面，而检测和恢复是被动机制。对于弹性而言，主要威胁来自软件攻击者和硬件攻击者。

## 弹性构建块

弹性构建块包括三个部分：

    1） 弹性目标：它是可改变的引擎，包括代码和数据。
    2） 弹性引擎：为弹性目标提供服务的不可改变的引擎，例如保护、验证、更新或恢复。
    3） 弹性授权机构：授权弹性引擎在弹性目标上执行服务的实体。

在弹性引擎内部存在三个主要块：

    1） 安全执行环境（SEE）：这是一个安全的执行立足点来确保一个妥协的弹性目标不会影响恢复。
    2） 保护锁存，例如写入锁和读取锁：这是为了确保在弹性引擎中的永久的储存不能被妥协的弹性目标篡改。
    3） 看门狗计时器：这是为了确保妥协的弹性目标不能影响弹性引擎执行恢复动作。

图3-1显示了弹性构建块。

<div align=center><img src=Figures/Figure-3-1.jpg></img></div>
<div align=center>图 3-1 弹性构建块</div>

为了支持关键弹性，我们需要定义一组信任根（RoTs）。这些信任根包括更新信任根（RTU）、检测信任根（RTD）、恢复信任根（RTRec）。一些功能也能在锚定在信任根中的信任链（CoT）中实现。我们也需要定义相关的更新信任链（CTU）、检测信任链（CTD）和恢复信任链（CTRec）。那些弹性信任根（RTRes）在弹性引擎中，并且提供服务，例如保护与更新、检测和恢复。我们将在第3、4和5章中逐一讨论。

一个平台可能有不同的固件组件。我们做了如下分类：

    • 不可改变的ROM（包括代码和数据）
    • 可更新的固件（包括代码和数据）
    • 配置数据

基于这些分类，我们可能使用不同的保护机制。

## 不可改变的ROM

一个不可改变的ROM在系统中是不能升级的逻辑。它被认为是信任根（RoT）。不可改变的ROM包括代码和数据。通常，不可改变的ROM的范围应该足够小，以便于审查与审计，以确保无bug。其优点是保护策略很简单 —— ROM必须永远锁定。其缺点是一旦发现在不可改变的ROM中发现安全问题，没有机会去修复，并且设备应该被丢弃。

### 完整性

基本的安全要求是ROM的完整性。一旦ROM被锁定，没有人可以写入它。通常，这种保护是由硬件端完成，以防止软件攻击。但我们也需要考虑硬件攻击。硬件攻击者可能劫持平台上的系统总线来绕过保护。平台可以锁定SPI控制器中的串行外围接口（SPI）闪存区块。因此，没有人可以向SPI设备发送命令，但硬件攻击者可能直接对SPI芯片添加闪存编程器，并且对整个SPI芯片烧录。或者硬件攻击者可能会附加一个额外的SPI芯片来提供备用代码和数据。作为一种缓解措施，平台需要确保ROM在平台内部，并且不暴露任何可编程接口。

### 机密性

机密性也需要考虑。如果不可改变的ROM包括私钥，则密钥任何时候都不得暴露。根据Kerckhoffs原则，除了私钥之外，整个不可改变的ROM都可以暴露。对于高度关键的设备或系统，整个不可改变的ROM也需要加密或不能被外部读取，因为保证ROM机密可以使破坏设备或系统变得困难。内部细节只能出于审计目的公开。

### 案例研究

现在，让我们看看不可改变的ROM的一些真实案例。

#### 移动、桌面和服务器中的不可改变的ROM

不可改变的ROM可能存在于个人的计算机或服务器中。片上ROM中的X86 CPU Microcode是不可改变的。会有CPU Microcode更新在运行时通过patch RAM来修补Microcode，但是基本的芯片内部的CPU Microcode是不可改变的。

平台可以设计一个单独的芯片作为信任根（RoT）。芯片上的不可改变的ROM验证系统固件和一些设备固件，因此，它创建了信任链（CoT）。例子包括谷歌设计的Titan芯片、苹果设计的T2芯片、AMD设计的AMD平台安全处理器、开源计算项目（OCP）定义的Cerberus安全架构和英特尔的平台固件弹性（PFR）。一个传统的X86系统见图3-2。这信任根固件验证主要的BIOS和关键启动固件，例如管理引擎（ME）固件，服务器的基板管理控制器（BMC）固件和客户端系统的嵌入式控制（EC）固件。然后主要的BIOS验证非关键启动固件（例如非易失性存储接口（NVMe）固件，传感器固件和音频固件）。

<div align=center><img src=Figures/Figure-3-1.jpg></img></div>
<div align=center>图 3-2 移动、桌面和服务器中的平台组件</div>

我们将在第4章讨论信任根和信任链的更多细节。

#### 嵌入式和物联网（IoT）领域中的不可改变的ROM

在嵌入式领域，ARM为A系列（应用处理器，AP）和M系列（微控制器）定义了平台安全架构（PSA）来提供针对物联网（IoT）设备的指南。平台安全架构的信任根包括硬件和不可改变的固件。可信固件A（Trusted-Firmware-A）是ARM系统A系列可信固件设计的参考实现（见图3-3）。可信的ROM是不可改变的固件。上电时，应用处理器（AP）在重置向量执行可信的ROM。然后可信的ROM验证并加载可信固件。可信固件验证和加载运行时固件的额外部分和非安全固件。可信固件可能也验证系统控制处理器（SCP）固件如果它存在。

<div align=center><img src=Figures/Figure-3-3.jpg></img></div>
<div align=center>图 3-3 ARM A系列中的平台组件</div>

可信固件M（Trusted-Firmware-M）是ARM系统M系列可信固件设计的参考实现（见图3-4）。因为微控制器（MC）只有受限的于执行环境，其启动流程就简单的多。微控制器在重置向量执行MCUBoot ROM。MCUBOOT验证所有重置的固件包括安全固件的安全分区管理（SPM）和非安全的固件。

<div align=center><img src=Figures/Figure-3-4.jpg></img></div>
<div align=center>图 3-4 ARM M系列中的平台组件</div>

我们将在第4章更详细地讨论平台安全架构。

#### 特别的恢复镜像

通常，系统固件没有不可改变的部分。为了修复安全问题，所有的固件必须可升级。唯一可能的例外称之为特别的恢复镜像。特别的恢复镜像是当系统固件不能启动时仅用在恢复阶段的固件。然而，制作不可改变的特别的恢复镜像是非常危险的。在特别的系统固件中任何安全漏洞都会成为致命弱点（阿喀琉斯之踵）。如果这类安全漏洞被暴露，所有的攻击者需要做的是在更新期间移除电源来触发恢复过程。然后他们能攻击特别的恢复镜像。

我们将在第5章中讨论恢复处理的更多细节。

### 攻击与缓解

现在，让我们看一下针对不可改变的ROM和可能的缓解措施的一些真实的案例。

#### 机密

不可改变的ROM可能包含机密 —— 平台的根密钥用来派生密钥的支撑物或用来证明身份的私钥。这机密不能以任何方式暴露。例如，如果机密保存在外部的非易失性存储或暴露在类似动态随机存取存储器（DRAM）或SPI总线等总线上，则可能意味着风险。

## 可升级的固件

通常，系统固件是可升级的。平台制造商可以发布新的固件来修复功能性问题或安全问题。板子上的任一设备固件是可升级的。这新的设备固件可以是设备制造商发布的独立包或是集成到平台制造商整个系统更新包的一部分。

根据NIST SP800-193，可升级固件的保护基于三个原则：

    • 已验证的更新机制
    • 完整性保护
    • 不可绕过

### 已验证的更新机制

已验证的更新机制的指导如下：

    • 更新镜像应该由经批准的数字签名算法进行签名
    • 更新镜像应该由经授权的实体进行签名，例如设备制造商、平台制造商或可信的第三方
    • 更新镜像应该在更新到非易失性存储前优先由信任根进行验证

当我们选择数字签名算法时，我们需要考虑政府对算法要求和密钥长度要求。当我们设计解决方案时，我们需要考虑加密灵活性。因此，当要求改变时，它能很容易地迁移到新的算法。实践上，使用PKCS#7是不错的选择，因为它定义了描述密码消息的语法。不同的算法，例如RSA2048/RSA3072或SHA256/SHA384，可以由PKCS#7证书描述。代码不需要显式地选择使用哪种算法。然而，PKCS#7可以包含X.509证书，解析X.509证书很复杂，并且需要大量内存。在资源受限的环境中，例如只有静态随机存取存储器（SRAM）或有限的动态随机存取存储器（DRAM），它可能需要直接使用没有任何封装的算法。

| **注释** | 校验或循环冗余校验在安全世界毫无意义。它们只能用于检测简单的错误，而不是攻击。|
| :--- | :--- |

验证和更新应该在可信执行环境中进行。可信执行环境可能是早期的没有任何第三方代码或不可信代码执行的启动阶段，或它可能是处理器特定的隔离环境，例如英特尔系统管理模式（SMM）或ARM TrustZone，或它可能使用服务器的基板管理控制器（BMC）。我们将在第17章讨论可信执行环境和管理模式的更多细节。

固件更新可以在操作系统环境中进行。例如，Windows和Linux提供了有关怎样使用UEFI定义的胶囊格式在操作系统环境中初始化系统固件更新的指导。

除了系统固件，设备固件可能也需要支持更新。IETF创建了物联网软件更新（SUIT）组为10KB以下随机存取存储器和100KB以下闪存的物联网设备提供了指导。TCG嵌入式工作组提供了TCG嵌入式系统软件和固件的安全更新指导。DMTF公布了固件更新平台级别数据模型（PLDM）规范，它定义了平台管理子系统设备上用于更新固件组件的消息和数据结构。

#### 案例研究

现在，让我们看一下已验证更新机制的一些真实案例。

##### 签名的UEFI胶囊更新

由于安全原因，大部分系统固件支持更新闪存，但是它可以锁定闪存，保护在某些启动过程中不被写入，而提供完整性保护（见图3-5）。因此，直接更新闪存是不可能。

<div align=center><img src=Figures/Figure-3-5.jpg></img></div>
<div align=center>图 3-5 正常启动禁止闪存更新</div>

UEFI规范定义了胶囊机制来让操作系统通过一个新的固件镜像压缩当前的固件并且发起一次重置。重置强制让系统在系统固件里开始执行。在下一次的启动中，固件检测到待定的固件镜像胶囊，然后它使闪存区块解锁，并且处理更新请求（见图3-6）。固件镜像胶囊必须放在可读写的非易失性存储中，因为内容必须保留，即使经过重置。候选者包括系统存储、硬驱、非易失性双列直插存储器模块（NVDIMMs），甚至是临时的闪存存储区域。非易失性存储的完整性不需要确保，因为固件在更新之前必须验证固件镜像胶囊。

<div align=center><img src=Figures/Figure-3-6.jpg></img></div>
<div align=center>图 3-6 更新模式下允许的闪存更新</div>

下文是UEFI胶囊更新在EDK II BIOS的实现。内存中的胶囊镜像见图3-7。

<div align=center><img src=Figures/Figure-3-7.jpg></img></div>
<div align=center>图 3-7 UEFI胶囊更新流程（胶囊在内存中）</div>

步骤0：在系统启动期间，CapsuleRuntimeDxe驱动暴露UEFI运行时更新胶囊服务。操作系统代理加载胶囊镜像到内存，然后调用这个服务来触发胶囊更新。最终，它把胶囊信息放置到UEFI变量中，并且使用重置系统运行时服务重置系统。

步骤1：在下一次启动中，PlatformPei模块检测固件镜像胶囊的存在并且设置启动模式为胶囊更新。

步骤2：内存初始化之后，MemoryInit驱动调用胶囊预先可扩展固件接口初始化（PEI）驱动合并分散的胶囊碎片。胶合并之后，在胶囊切换块（HOB）中汇报新的胶囊位置，切换块传递信息到驱动执行环境（DXE）阶段。然后MemoryInit安置永久的系统内存。

步骤3：所有的驱动程序在驱动执行环境（DXE）阶段完成后，系统进入启动设备选择（BDS）阶段。如果启动模式设置为胶囊更新，PlatformBds驱动将处理在胶囊切换块中汇报的胶囊镜像。然后，新的固件镜像将被验证，闪存区块将被更新。

内存中的胶囊解决方案要求内存中的内容即使经过重置也是保留的。如果系统支持S3恢复或内存内容保留的热重置，我们可以使用这方法。然而，一些嵌入式系统和服务器不支持那些选项。在这种情况下，我们可能把胶囊放在硬驱中。这方法有时候也被称之为磁盘上的胶囊。

磁盘上的胶囊镜像见图3-8。

<div align=center><img src=Figures/Figure-3-8.jpg></img></div>
<div align=center>图 3-8 UEFI胶囊更新流程（胶囊在磁盘上）</div>

步骤0：操作系统代理把胶囊镜像放在磁盘上，并且在UEFI变量中设置标志来表明磁盘上有新的胶囊（镜像）等待处理。然后操作系统代理调用重置系统UEFI运行时服务重置系统。

步骤1：在下一次启动中，PlatformPei模块通过读取UEFI变量检测固件镜像胶囊的存在并且设置启动模式为胶囊更新。

步骤2：由于胶囊不在内存中，内存初始化流程不受磁盘上的胶囊方法的影响。在预先可扩展固件接口初始化（PEI）阶段完成之前，DxeIpl模块调用CapsuleOnDiskLoader函数从磁盘加载胶囊到内存。在胶囊切换块（HOB）中汇报新的胶囊位置。

步骤3：所有的驱动程序完成后，系统进入启动设备选择（BDS）阶段。在胶囊更新启动模式下，PlatformBds驱动会在胶囊切换块中处理胶囊镜像。然后，新的固件镜像会被验证，闪存区块会被更新。

无论使用随机存取存储器中的胶囊还是磁盘上的胶囊，胶囊（磁盘或随机存取存储器）和胶囊UEFI变量被认为是外部输入。因此，UEFI变量在使用前必须检查，并且胶囊的内容必须签名。签名的胶囊格式在UEFI规范中定义。

UEFI规范定义了可扩展固件接口_固件_管理_协议（EFI_FIRMWARE_MANAGEMENT_PROTOCOL，EMP）作为系统固件或设备固件更新流程的标准接口。图3-9描述了UEFI固件管理协议胶囊镜像的数据结构。如果使用了UEFI固件管理协议基于胶囊的更新，平台厂商或设备厂商将发布遵循定义在UEFI规范中的数据结构的新固件。然后终端用户将使用操作系统的接口发送镜像到平台固件让它执行更新。旧的固件必须验证固件镜像的可靠性来确保它来自可信的来源。

<div align=center><img src=Figures/Figure-3-9.jpg></img></div>
<div align=center>图 3-9 UEFI胶囊数据结构</div>

《超越BIOS教程：EDK II中胶囊更新与恢复》详细的描述了整个更新流程。

新固件镜像的安全验证应该考虑两个部分：签名验证与版本验证。固件更新胶囊必须经过签名，如此更新机制能检查内容的完整性。UEFI固件管理协议要求可扩展固件接口_固件_镜像_认证（EFI_FIRMWARE_IMAGE_AUTHENTICATION）结构在实际的有效载荷的镜像之前，并且它要求证书类型为EFI_CERT_TYPE_PKCS7_GUID。认证信息是PKCS7签名。胶囊更新机制从固件中提取可信的证书，并且使用可信的证书验证PKCS7签名。如果胶囊没有EFI_FIRMWARE_IMAGE_AUTHENTICATION结构，或者签名验证失败，这个胶囊必须忽略。

除了签名验证，更新机制也应该检查胶囊版本来防止回滚攻击。版本检查要求胶囊镜像中的版本必须高于或等于当前固件的最小支持镜像版本。当前的UEFI规范没有定义版本和最小支持镜像版本值在胶囊镜像中如何存储。EDK II实现定义了FMP_PAYLOAD_HEADER在镜像数据之前。如果在FMP_PAYLOAD_HEADER中的版本小于当前固件的最小支持版本，这胶囊应该被忽略。
