## 第十五章

# 编译器防御技术

如今，大多数固件实现都是用C语言编写的。同时，C 语言编译器提供了丰富的编译器选项来加固软件。部分编译器选项也可应用于固件。本章仅重点介绍C语言和C编译器。如果固件是用其他语言编写的，例如Rust或Forth，我们将在第20章讨论这些细节。

编译器的防御方法主要有两类 —— 消除漏洞和挫败漏洞利用。为支持消除漏洞，编译器可提供静态分析或动态分析功能，例如静态分析器、地址消毒器、未初始化数据检查和算术检查。因此，开发人员或测试工程师就可以在构建时发现问题，或在运行时调试镜像。然后，他们可以在产品固件发布之前修复问题。由于各种原因，编译器选项不会在最终的产品固件中使用，例如不适用、对性能影响太大或运行时内存消耗太多。

相反，为支持挫败漏洞利用，编译器可能会在最终产品镜像中注入一些代码，例如堆栈检查、代码保护（不可执行[NX]数据）、地址空间布局随机化或控制流保护。表15-1总结了Microsoft Visual C++ (MSVC)、GNU CC(GCC)和Clang编译器中的这些编译器防御技术。

表 15-1 编译器抵御技术总结
| 检测方法 | | MSVC | Clang/GCC |
| :--- | :--- | :--- | :--- |
| 破坏漏洞 | | | |
| 栈检查 | 栈溢出 | /GS | -fstack-protector |
| 代码保护 | 代码注入 | /NXCompat | LDFLAGS=-z noexecstack  LDFLAGS=-z relo -z now |
| 地址空间布局随机化 | 缓冲溢出 | /DynamicBase | -fPIE -fPIC LDFLAGS=-pie |
| 控制流（软件）| 控制流攻击 | /guard:cf | -fsanitize=cfi |
| 控制流（硬件）| 控制流攻击 | /CETCompat | -fcf-protection=full (LDFLAG=-z force-ibt -z shstk) -fcf-protction=branch -fsanitize=shadow-call-stack -mbranch-protection=pac-ret -mbranch-protection=bti |
| 侧信道 | 推测执行攻击 | /Qspectre /Qspectre-load /Qspectre-load-cf | -mspeculative-load-hardening |
| 消除漏洞 | | | |
| 静态分析 | 编码错误 | /analyze(?) | Clang static analyzer |
| 动态分析（地址分析器）| 栈/堆溢出 | /RTCs | -fsanitize=address |
| 动态分析（未初始化数据）| 随机数据 | /RTCu | -fsanitize=memory |
| 动态分析（算数检查）| 信息流失，整型溢出 | /RTCc | -fsanitize=undefined -fsanitize=signed-integer-overflow -fsanitize=unsigned-integer-overflow |

