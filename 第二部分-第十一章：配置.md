## 第十一章

# 配置

用户可配置数据在相同固件代码下可用于控制固件行为。配置数据被设计成可由终端用户更新和更改，而固件代码通常只能由平台制造商编辑。因此，对配置数据的保护不同于对固件代码的保护。

UEFI变量是存储UEFI固件配置的一种方式。让我们以UEFI变量为例，介绍不同的保护机制。这些机制可用于实现固件配置数据的替代实现选择。

## UEFI变量

根据UEFI规范，UEFI变量用于存储UEFI组件之间传递的数据，例如平台制造商的组件、UEFI应用程序或UEFI操作系统加载程序。经典的CIA（保密性、完整性、可用性）安全属性应被视为UEFI变量的属性。攻击UEFI变量的对手可分为软件攻击者和硬件攻击者。软件攻击可通过执行调用UEFI SetVariable/GetVariable API和使用代码直接读/写变量存储或缓存区域来实现；硬件攻击可通过在变量更新期间关闭系统电源或使用闪存编程器读/写变量存储的闪存区域来实现。有关UEFI变量保护机制，见表11-1。我们将逐一介绍。

表 11-1 UEFI变量保护机制
| 机制 | 软件攻击抵抗 | 硬件攻击抵抗 |
| :--- | :--- | :--- |
| 完整性保护 | 变量认证 可信执行环境 变量锁 变量合理性检查 | 带有RPMB的变量 带有RPMC的变量 TPM存储的变量 |
| 可用性保护 | 变量配额管理 闪存磨损保护 | 变量原子性 容错写入（FTW）|
| 机密性保护 | 用户密钥加密的变量 | 平台密钥加密的变量 用户密钥加密的变量 |

### 完整性保护

#### 变量认证

变量认证的目的是确保调用SetVariable() API来更新UEFI变量的实体拥有更新变量的授权。根据UEFI规范，调用者需要提供带有签名证书的更新的变量，才能更新认证过的变量。

存在三种认证过的变量格式：

    1）基于计数的认证过的变量，如果EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS属性设置（这是废弃的）
    2）基于时间的认证过的变量，如果EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS属性设置（当前使用的）
    3）可扩展的认证过的变量（基于时间或nonce），如果EFI_VARIABLE_ENHANCED_AUTHENTICATED_WRITE_ACCESS属性设置（新）

当用户调用SetVariable() API，将使用认证过的变量输入数据格式。认证描述符会关联一个时间戳或一个nonce。对于证书类型字段，基于时间的认证变量或可扩展认证变量只接受PKCS7。证书为DER编码的PKCS#7 1.5版本SignedData。最重要的字段是签名者的DER编码的X.509证书、元数据的SHA256哈希值（变量名、VariableGuid、属性）、第二个描述符（时间戳或nonce）、可选的附加nonce、可选的附加证书和新变量数据内容。描述符是一种可扩展结构，用于标识与给定变量相关的唯一X.509证书。它可以是一个时间戳或一个nonce值。在更新变量内容前，认证变量驱动程序会检查验证描述符。图11-1和11-2显示了基于时间的认证变量输入和基于nonce的认证变量输入的格式。（* 表示该字段为可选字段）。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-1.jpg></img></div>
<div align=center>图 11-1 认证变量输入格式（基于时间）</div>

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-2.jpg></img></div>
<div align=center>图 11-2 认证变量输入格式（基于Nonce）</div>

如我们在第4章讨论的，与安全启动相关的密钥，例如PK、KEK、db/dbx等，都是经过认证的变量。当系统固件被创建时，这些密钥可能尚未提供。根据UEFI规范，当PK未注册时系统处于设置模式，而PK注册时系统处于用户模式。安全启动功能只能在用户模式下启用。见图11-3。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-3.jpg></img></div>
<div align=center>图 11-3 UEFI安全启动设置模式vs.用户模式</div>

在UEFI 2.5规范中，新增了两种额外的模式 —— 部署模式和审计模式（见图 11-4）。审计模式是设置模式的扩展。审计模式启用签名列表组合的计划性发现，这些组合可成功认证已安装的EFI镜像，而不会导致系统无法启动。选定的签名列表配置可进行测试，以确保系统在脱离审核模式后仍能继续启动。在过渡到审计模式后，签名执行将被禁用，这样所有镜像都会被初始化，增强的执行映像执行信息表（IEIT）记录执行，包括多签名镜像的递归验证。

部署模式是用户模式的扩展。部署模式是最安全的模式。在设计上，用户模式和审计模式都支持未经认证的过渡到部署模式。然而，从部署模式转到任何其他模式都需要安全的平台特定的方法，或删除经过认证的PK。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-4.jpg></img></div>
<div align=center>图 11-4 UEFI 2.5安全启动模式（来源：UEFI规范）</div>

更新安全启动密钥（PK, KEK, db/dbx等）需要签名验证。然而，它阻止了终端用户更新安全启动密钥，因为终端用户没有PK或KEK。因此，EDK II引入了两种特殊的安全启动模式（见图11-5）：

    1）标准安全启动模式：默认的模式，遵循UEFI规范
    2）定制的安全启动模式：允许更多的灵活性，具体如下：
        • PK变量更新不需要旧的PK签名
        • KEK变量更新不需要PK签名
        • 镜像签名数据库（db/dbx），时间戳数据库（dbt）和恢复数据库（dbr）更新不需要PK或KEK签名

如我们在第十章讨论的，标准模式与定制模式之间的切换需要用户实际在场。必须有一种平台特定的方法来检测实际用户是否在场来执行这一操作。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-5.jpg></img></div>
<div align=center>图 11-5 标准安全启动模式vs.定制安全启动模式</div>

为了更新PK或KEK，需要使用以下认证流程。首先，如果系统处于用户实际存在（UserPhysicalPresent）的定制模式（CustomMode），则无需进行认证。其次，如果系统处于设置模式，则无需使用PK进行认证。第三，如果系统处于用户模式，则使用PK进行认证。最后，如果系统处于设置模式来注册PK，则使用此有效负载进行认证。见图11-6。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-6.jpg></img></div>
<div align=center>图 11-6 变量认证流程 —— ProcessVarWithPk</div>

为了更新图像签名数据库 (db/dbx)、时间戳数据库 (dbt) 或恢复数据库 (dbr)，系统会首先调用ProcessVarWithPk。如果此次执行失败，系统会调用ProcessVarWithKek。首先，如果处于用户实际存在（UserPhysicalPresent）的定制模式（CustomMode），则无需进行认证。其次，如果系统处于设置模式，则不需要认证。最后，执行KEK认证。见图11-7。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-7.jpg></img></div>
<div align=center>图 11-7 变量认证流程 —— ProcessVarWithKek</div>

其他认证过的变量（与安全启动相关的变量除外）不需要PK/KEK验证。验证流程有所不同。首先，如果变量要求实际在场，但用户并不在场，更新请求将被拒绝。其次，如果变量是基于时间的认证变量，则要执行时间与创建者密钥认证。最后，如果旧变量拥有AUTHENTICATED属性，但不给当前的变量打补丁，更新请求会被拒绝。或者表示不需要认证。见图11-8。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-8.jpg></img></div>
<div align=center>图 11-8 变量认证流程 —— ProcessVariable</div>

#### 可信执行环境

与固件镜像签名验证类似，变量认证和更新需要可信执行环境。这就实现了不可绕过的能力。

UEFI和操作系统运行时不是可信执行环境。对于X86系统，系统管理模式（SMM）是用来执行变量认证服务的。UEFI运行时服务SetVariable会将变量数据和签名放入SMM通信缓冲区，并触发SMI。然后SetVariableHandler会被调用。它将通信缓冲区的数据复制到SMM中，然后通过执行认证和更新来处理变量。见图11-9。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-9.jpg></img></div>
<div align=center>图 11-9 基于TEE的认证变量更新</div>

#### 变量锁定

除了用户配置变量外，系统可能还需要在运行时记录当前的平台数据。例如，它可以包括内存初始化训练数据。内存训练非常耗时，而且训练数据在热重置或S3恢复时都是相同的。因此，没有必要再次训练内存。我们可以将训练数据保存到非易失性存储器中，在热重置后或S3恢复期间直接恢复配置。

如何确保配置数据不被其他实体修改？最简单的方法就是锁定变量，并且及时地使其在某个时间点不可更改。

EDK II通过采用以下规则，实现了EDKII_VARIABLE_LOCK_PROTOCOL来支持标记某些变量：

    • 在EndOfDxe事件之前，EDKII_VARIABLE_LOCK_PROTOCOL.RequestToLock() API用来提交变量锁定请求。
    • 该锁定请求本身是易失的。那意味着每次启动都得调用RequestToLock()。
    • 在EndOfDxe事件之后，RequestToLock() API关闭。

变量锁定策略规则如下：

    • 在EndOfDxe事件之前，变量锁不会生效，因为只有OEM BIOS代码会被执行和信任。
    • EndOfDxe事件发生后，变量锁定会在DXE或操作系统运行阶段生效，因为第三方代码是不可信的。锁定的变量不能删除或更新。如果锁定变量之前不存在，则无法创建。
    • 变量锁定在SMM中没有任何作用，因为SMM是由OEM BIOS构建的，并且其中没有非平台代码。在SMM中，变量仍可更新。

完整的概要显示在图11-10中。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-10.jpg></img></div>
<div align=center>图 11-10 每个阶段的变量特征</div>

RO 表示只读。
RW 表示读/写。
RWC 表示读/写，带回收功能。
RWL 表示读/写，带锁定功能。
UEFI规范还定义了其他属性，如RUNTIME(RT)。带有RT属性的变量在退出启动服务事件后不可访问。

#### 变量合理性检查

平台可以定义一个设置变量，用于UEFI人机接口基础架构（HII），这样用户就可以通过更新设置用户界面（UI）来控制平台设置。例如，用户可以将SATA控制器配置为IDE模式、AHCI模式或RAID模式。设置变量字段SataMode被使用。1表示IDE模式，5表示AHCI模式，6表示RAID模式。其他值，例如0、2、3、4或7将被视为无效输入。

问题是没有办法检查某些变量字段是否有效，并拒绝无效的变量更新。在前面的示例中，当代码调用SetVariable()更新设置变量时，我们希望变量驱动程序能检查SataMode以查看设置是否有效（1、5或6），如果设置无效，则拒绝变量更新。

为了解决这问题，EDK II引入了“变量检测” —— 基于预设的策略检查变量内容的能力。

为了检查变量，驱动可以注册一个SetVariable检查处理程序来定义特定变量的特性：

    • 属性：UEFI定义的变量属性（BS，RT，NV等）
    • 特性：非UEFI定义的变量属性（只读READ_ONLY）
    • 最小尺寸：变量数据的最小尺寸
    • 最大尺寸：变量数据的最大尺寸

一个系统可以有多个变量检查器。基于UEFI人机接口基础结构（HII）的校验器和基于UEFI平台初始化（PI）平台配置数据库（PCD）的校验器就是校验器的两个例子：

    1）基于HII的检查器

UEFI规范的HII部分定义了HII操作码，允许设置UI与UEFI变量存储相关联。其他一些设置选项通过HII_CONFIG_ACCESS_PROTOCOL进行。它们可以关联到变量或其他存储空间。如果变量与设置选项相关联，我们可以使用HII IFR操作码中的数据来检查变量内容的合法配置。例如，映射到ONE_OF_OP、NUMERIC_OP、ORDERED_LIST_OP或CHECKBOX_OP的变量必须在预定义的范围内。

为了实现上述检查，VarCheckHii处理程序需要获得两个来源的HII数据：

    • 静态HII数据：固件卷内构建的HII数据。EDK II构建工具会将HII信息生成到FFS raw部分（见图 11-11）或UEFI专用PE/COFF资源。典型用途是设置配置数据。即使由于当前硬件配置的原因，某些特殊的设置数据没有安装到HII数据库中，也可以检索到这些信息。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-11.jpg></img></div>
<div align=center>图 11-11 HII构建时间信息</div>

    • 动态HII数据：HII_DATABASE_PROTOCOL公开的HII数据。这是由UEFI定义的，从HII数据库获取HII数据的方法。平台代码或第三方选项ROM可以通过C代码动态构建HII数据。所有HII数据HII_DATABASE_PROTOCOL公开。

图11-12显示了系统启动期间的VarCheckHii过程。在初始化期间，VarCheckHiiGen()从FV和HII_DATABASE_PROTOCOL中收集HII信息，并生成VarCheckHiiBin —— 一种用于存储ONE_OF、NUMERIC和CHECKBOX信息的紧凑型数据结构。在运行期间，SetVariableCheckHandlerHii()会引用VarCheckHiiBin来检查变量内容是否合法。如果变量属性不同、数据大小不同或内容不符合HII质询，变量内容将被视为非法，并向SetVariable()调用返回EFI_SECURITY_VIOLATION，以拒绝变量更新。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-12.jpg></img></div>
<div align=center>图 11-12 变量检查HII</div>

EDK II VarCheckHii处理程序只对ONE_OF、NUMERIC和CHECKBOX操作码使用简单策略，因为它们是平台设置中最常用的问题。一个已知的限制是不支持不一致错误检查操作码，因为评估这些操作码需要IFR表达式解析器来支持或读取其他变量存储空间或缓冲存储空间。这实现起来可能过于复杂。

    2）基于PCD的检查器

EDK II PCD被映射到UEFI变量，如果它是使用PcdDynamicHii访问类型实例化的。EDK II PCD实现还支持在DEC文件中为特定PCD定义一组有效配置。例如
    • @ValidList： 变量数据必须在列表中。
    • @ValidRange： 变量数据必须在范围内。

因此，我们拥有一种方法来检查PCD映射的变量是否合法。

EDK II构建工具会生成这些信息，这些信息可以会以二进制形式编码在FFS raw部分中。见图11-13。在初始化期间，LocateVarCheckPcdBin()会从FFS raw部分获取VarCheckPcdBin二进制文件。在运行期间，SetVariableCheckHandlerPcd()会参考VarCheckPcdBin来检查变量内容是否合法。如果变量属性不同、变量大小太小或内容不符合PCD的有效列表或有效范围，则变量内容将被视为非法，并返回EFI_SECURITY_VIOLATION状态码。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-13.jpg></img></div>
<div align=center>图 11-13 变量检查PCD</div>

PCD包括变量的偏移量，但不包括变量的大小。我们只能检查变量是否过小，却无法确定变量是否过大。这是VarCheckPcd的一个已知限制。

EDK II VarCheckPcd处理程序对@ValidList和@ValidRange使用了简单的策略。一个已知的限制是PCD的@Expression有效性检查是不支持的，因为这需要表达式解析器的支持。实现起来可能过于复杂。

变量检查程序只检查SetVariable() API中的变量格式。它不会在GetVariable() API 中检查变量格式，假定如果在Set中检查了变量数据，那么在Get中也一定是正确的。

如果我们的对手是软件攻击者，这一假设是正确的，但对于硬件攻击者，这一假设就不正确了，我们将在以下章节讨论。

