## 第十一章

# 配置

用户可配置数据在相同固件代码下可用于控制固件行为。配置数据被设计成可由终端用户更新和更改，而固件代码通常只能由平台制造商编辑。因此，对配置数据的保护不同于对固件代码的保护。

UEFI变量是存储UEFI固件配置的一种方式。让我们以UEFI变量为例，介绍不同的保护机制。这些机制可用于实现固件配置数据的替代实现选择。

## UEFI变量

根据UEFI规范，UEFI变量用于存储UEFI组件之间传递的数据，例如平台制造商的组件、UEFI应用程序或UEFI操作系统加载程序。经典的CIA（保密性、完整性、可用性）安全属性应被视为UEFI变量的属性。攻击UEFI变量的对手可分为软件攻击者和硬件攻击者。软件攻击可通过执行调用UEFI SetVariable/GetVariable API和使用代码直接读/写变量存储或缓存区域来实现；硬件攻击可通过在变量更新期间关闭系统电源或使用闪存编程器读/写变量存储的闪存区域来实现。有关UEFI变量保护机制，见表11-1。我们将逐一介绍。

表 11-1 UEFI变量保护机制
| 机制 | 软件攻击抵抗 | 硬件攻击抵抗 |
| :--- | :--- | :--- |
| 完整性保护 | 变量认证 可信执行环境 变量锁 变量合理性检查 | 带有RPMB的变量 带有RPMC的变量 TPM存储的变量 |
| 可用性保护 | 变量配额管理 闪存磨损保护 | 变量原子性 容错写入（FTW）|
| 机密性保护 | 用户密钥加密的变量 | 平台密钥加密的变量 用户密钥加密的变量 |

### 完整性保护

#### 变量认证

变量认证的目的是确保调用SetVariable() API来更新UEFI变量的实体拥有更新变量的授权。根据UEFI规范，调用者需要提供带有签名证书的更新的变量，才能更新认证过的变量。

存在三种认证过的变量格式：

    1）基于计数的认证过的变量，如果EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS属性设置（这是废弃的）
    2）基于时间的认证过的变量，如果EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS属性设置（当前使用的）
    3）可扩展的认证过的变量（基于时间或nonce），如果EFI_VARIABLE_ENHANCED_AUTHENTICATED_WRITE_ACCESS属性设置（新）

当用户调用SetVariable() API，将使用认证过的变量输入数据格式。认证描述符会关联一个时间戳或一个nonce。对于证书类型字段，基于时间的认证变量或可扩展认证变量只接受PKCS7。证书为DER编码的PKCS#7 1.5版本SignedData。最重要的字段是签名者的DER编码的X.509证书、元数据的SHA256哈希值（变量名、VariableGuid、属性）、第二个描述符（时间戳或nonce）、可选的附加nonce、可选的附加证书和新变量数据内容。描述符是一种可扩展结构，用于标识与给定变量相关的唯一X.509证书。它可以是一个时间戳或一个nonce值。在更新变量内容前，认证变量驱动程序会检查验证描述符。图11-1和11-2显示了基于时间的认证变量输入和基于nonce的认证变量输入的格式。（* 表示该字段为可选字段）。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-1.jpg></img></div>
<div align=center>图 11-1 认证变量输入格式（基于时间）</div>

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-2.jpg></img></div>
<div align=center>图 11-2 认证变量输入格式（基于Nonce）</div>

如我们在第4章讨论的，与安全启动相关的密钥，例如PK、KEK、db/dbx等，都是经过认证的变量。当系统固件被创建时，这些密钥可能尚未提供。根据UEFI规范，当PK未注册时系统处于设置模式，而PK注册时系统处于用户模式。安全启动功能只能在用户模式下启用。见图11-3。

<div align=center><img src=Figures/Chapter-11-Screenshot/Figure-11-3.jpg></img></div>
<div align=center>图 11-3 UEFI安全启动设置模式vs.用户模式</div>

