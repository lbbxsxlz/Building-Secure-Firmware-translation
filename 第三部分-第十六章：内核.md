## 第十六章

# 内核

固件的实现类似于嵌入式操作系统。它有一个内核来管理资源，例如系统内存，内核还负责分派任务。操作系统可以通过两种方式抵御软件攻击——破解漏洞和遏制破坏。与编译器防御技术类似，操作系统可以通过强制代码保护来破解漏洞，例如数据执行预防（DEP）、代码完整性防护（CIG）和任意代码防护（ACG）。地址空间布局随机化（ALSR）可使攻击者更难预测目标地址。如今，控制流防护（CFG）变得越来越重要，因为基于控制流的攻击可以绕过基本加固措施，如DEP。

如果内核无法破解漏洞利用，内核应将破坏控制在有限的范围内，并预防任何持续性破坏。权限隔离是遏制破坏的一种策略。在适当的硬件支持下，我们可以使用基于环的用户模式/监管模式隔离和基于虚拟机监控器（VMM）的隔离。加密域技术包括英特尔软件防护扩展（SGX）、AMD安全加密虚拟化（SEV）和英特尔信任域扩展（TDX）。域隔离也是另一种策略。可信执行环境（TEE）是另一个不错的选择，例如ARM TrustZone 技术和英特尔系统管理模式（SMM）。如果硬件支持域分区，一个平台可以独立运行两个或多个系统。表16-1列出了内核防御技术总结。

表 16-1 内核抵御技术总结
| 检测方法 | 检测预防 | 细节 |
| :--- | :--- | :--- |
| 破坏漏洞利用 | | |
| 代码保护（代码完整性防护）| 代码注入 | 内核只允许签名的可执行镜像执行。|
| 代码保护（数据执行预防）| 代码注入 | 内核将代码区标记为只读可执行，将数据区标记为可读写不可执行。执行环境，例如栈和堆，也应是不可执行的。|
| 代码保护（任意代码防护）| 代码注入 | 内核默认将内存区域标记为不可执行，例如栈，堆和释放内存。可执行内存不能被其他模块分配。|
| 地址空间布局随机化 | 缓存区溢出 | 内核会从堆中的随机位置分配数据，并移动镜像加载位置。|
| 控制流防护 | 控制流攻击 | 内核设置控制流执行环境，例如影子栈或分支目标保护。|
| 地址消毒器（栈防护）| 栈超限 | 内核会在栈底部设置一个防护页，来捕捉运行时堆栈超限。这种超限可能是由过多的递归函数调用或分配巨大的局部变量造成的。|
| 地址消毒器（堆防护）| 缓存区溢出 | 内核会为堆中已分配的内存设置防护页，来捕捉运行时的缓冲区溢出。|
| 地址消毒器（内存标记）| 缓存区溢出 | 内核会为已分配的内存分配一个特殊标签，来捕捉运行时缓冲区溢出。|
| 控制破坏 | | |
| 监管模式（内核内存保护）| 用户模式下的漏洞 | 内核会设置基于环的权限隔离，来防止用户模式代码访问内核模式数据。|
| 监督模式（用户内存执行/访问预防）| 用户模式下的漏洞 | 内核设置基于CPU的保护，以 防止内核执行用户代码和访问用户数据。|
| 监督模式（内核地址隔离）| 用户模式下的漏洞 | 内核会设置双页表，来防止来自用户模式代码的侧信道攻击。|
| 虚拟机监控器（管理程序保护的代码完整性）| 虚拟机中的漏洞 | 内核设置基于管理程序的权限隔离。管理程序验证内核代码的完整性，并设置数据执行防护。|
| 虚拟机监控器（内核数据保护KDP）| 虚拟机中的漏洞 | 内核设置基于管理程序的权限隔离。管理程序将关键内核内存标记为只读。|
| 虚拟机监控器（沙箱）| 虚拟机中的漏洞 | 虚拟机解释器为应用代码设置一个沙箱。|
| 可信执行环境 | 非可信环境中的漏洞 | 内核设置基于可信执行环境的域隔离。|
| 系统分区 | 在其他分区中的漏洞 | 内核设置基于硬件的域隔离。|
