## 第十六章

# 内核

固件的实现类似于嵌入式操作系统。它有一个内核来管理资源，例如系统内存，内核还负责分派任务。操作系统可以通过两种方式抵御软件攻击——破解漏洞和遏制破坏。与编译器防御技术类似，操作系统可以通过强制代码保护来破解漏洞，例如数据执行预防（DEP）、代码完整性防护（CIG）和任意代码防护（ACG）。地址空间布局随机化（ALSR）可使攻击者更难预测目标地址。如今，控制流防护（CFG）变得越来越重要，因为基于控制流的攻击可以绕过基本加固措施，如DEP。

如果内核无法破解漏洞利用，内核应将破坏控制在有限的范围内，并预防任何持续性破坏。权限隔离是遏制破坏的一种策略。在适当的硬件支持下，我们可以使用基于环的用户模式/监管模式隔离和基于虚拟机监控器（VMM）的隔离。加密域技术包括英特尔软件防护扩展（SGX）、AMD安全加密虚拟化（SEV）和英特尔信任域扩展（TDX）。域隔离也是另一种策略。可信执行环境（TEE）是另一个不错的选择，例如ARM TrustZone 技术和英特尔系统管理模式（SMM）。如果硬件支持域分区，一个平台可以独立运行两个或多个系统。表16-1列出了内核防御技术总结。

表 16-1 内核抵御技术总结
| 检测方法 | 检测预防 | 细节 |
| :--- | :--- | :--- |
| 破坏漏洞利用 | | |
| 代码保护（代码完整性防护）| 代码注入 | 内核只允许签名的可执行镜像执行。|
| 代码保护（数据执行预防）| 代码注入 | 内核将代码区标记为只读可执行，将数据区标记为可读写不可执行。执行环境，例如栈和堆，也应是不可执行的。|
| 代码保护（任意代码防护）| 代码注入 | 内核默认将内存区域标记为不可执行，例如栈，堆和释放内存。可执行内存不能被其他模块分配。|
| 地址空间布局随机化 | 缓存区溢出 | 内核会从堆中的随机位置分配数据，并移动镜像加载位置。|
| 控制流防护 | 控制流攻击 | 内核设置控制流执行环境，例如影子栈或分支目标保护。|
| 地址消毒器（栈防护）| 栈超限 | 内核会在栈底部设置一个防护页，来捕捉运行时堆栈超限。这种超限可能是由过多的递归函数调用或分配巨大的局部变量造成的。|
| 地址消毒器（堆防护）| 缓存区溢出 | 内核会为堆中已分配的内存设置防护页，来捕捉运行时的缓冲区溢出。|
| 地址消毒器（内存标记）| 缓存区溢出 | 内核会为已分配的内存分配一个特殊标签，来捕捉运行时缓冲区溢出。|
| 控制破坏 | | |
| 监管模式（内核内存保护）| 用户模式下的漏洞 | 内核会设置基于环的权限隔离，来防止用户模式代码访问内核模式数据。|
| 监督模式（用户内存执行/访问预防）| 用户模式下的漏洞 | 内核设置基于CPU的保护，以 防止内核执行用户代码和访问用户数据。|
| 监督模式（内核地址隔离）| 用户模式下的漏洞 | 内核会设置双页表，来防止来自用户模式代码的侧信道攻击。|
| 虚拟机监控器（管理程序保护的代码完整性）| 虚拟机中的漏洞 | 内核设置基于管理程序的权限隔离。管理程序验证内核代码的完整性，并设置数据执行防护。|
| 虚拟机监控器（内核数据保护KDP）| 虚拟机中的漏洞 | 内核设置基于管理程序的权限隔离。管理程序将关键内核内存标记为只读。|
| 虚拟机监控器（沙箱）| 虚拟机中的漏洞 | 虚拟机解释器为应用代码设置一个沙箱。|
| 可信执行环境 | 非可信环境中的漏洞 | 内核设置基于可信执行环境的域隔离。|
| 系统分区 | 在其他分区中的漏洞 | 内核设置基于硬件的域隔离。|

## 破坏漏洞利用

首先，让我们看看内核如何在运行时预防漏洞利用。

### 代码保护

代码保护技术用于防止代码注入攻击。代码保护包括三个方面：代码完整性防护（CIG）、数据执行预防（DEP）和任意代码防护（ACG）。图16-1以UEFI固件中带有DEP/CIG/ACG的内存布局为例进行说明。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-1.jpg></img></div>
<div align=center>图 16-1 UEFI固件中的代码保护（DEP，CIG，ACG）</div>

#### 代码完整性防护

代码完整性保护意味着固件只能加载已签名的代码。如果代码没有签名或由未知实体签名，则不会加载代码。

在第4、6和8章中，我们讨论了代码完整性检查程序的不同变体。表16-2列出了校验器的总结和需要校验的组件。最终的固件解决方案可根据威胁模型选择全部或部分子集。

表 16-2 代码完整性防护总结
| 技术 | 验证者 | 要验证的组件 |
| :--- | :--- | :--- |
| Cerberus, Titan | 平台信任根 | 主机或非主机可变固件的全部内容，包括平台OEM固件、基板管理控制器（BMC）等。|
| Intel Boot Guard | 硅片认证的代码模块 | 主机平台OEM固件 |
| UEFI Secure Boot | 平台原始设备制造商（OEM）固件 | 第三方固件代码，包括PCI选项ROM和操作系统加载器。|
| Linux Secure Boot Shim | Linux Shim作为加载器 | Linux操作系统加载器，Linux内核。|
| Windows CIG，Integrity Policy Enforcement(IPE) | 操作系统 | Windows可执行文件，Linux可执行文件。|
| SPDM，PCI Component Authentication | 主机固件和软件，非主机或设备启动器 | 设备固件。|

例如，如果您的平台信任非主机固件，但不信任平台OEM固件，那么您可以使用Cerberus或Titan作为平台信任根，或使用Intel Boot Guard作为硅片认证代码模块来执行验证。但如果也要验证非主机固件，则不能选择Intel Boot Guard，因为它不具备这种功能。

如果平台固件需要从其他存储区域，例如磁盘或PCI主机总线适配器卡，加载第三方组件，则可以使用UEFI安全启动来验证PCI选项ROM或操作系统加载器的完整性。如果系统非常特殊，没有PCI卡，且操作系统加载器已集成到系统固件中，则不需要UEFI安全启动。您可以选择平台信任根来验证OEM固件和操作系统内核，然后依靠操作系统内核来验证磁盘中的驱动程序。

最后，如果一个平台信任所有设备，那么就可以跳过设备认证过程。如果您正在设计一个高可靠性平台，并且需要验证任何硬件组件，那么您就需要一个平台信任根（PRoT）来验证非主机固件。这些非主机固件实体包括基板管理控制器（BMC）和管理引擎（ME），也称为服务器平台服务（SPS）等。这些非主机固件实体的设备固件可通过PCI数据交换（DOE）上的安全协议和数据模型（SPDM）协议或SMBus上的管理组件传输协议（PMCI）访问其设备固件。

根据镜像是否可读，有两种典型的代码完整性验证方式：

1. 加载镜像并验证:

验证器可以将镜像哈希值作为验证策略。见图16-2。这种技术的缺点是，每当镜像更新时，都需要更新镜像哈希值。另一种替代方法是使用镜像数字签名。镜像可以包含公钥和镜像签名。验证者可以携带公钥的哈希值，并用它来验证镜像的公钥，以便在识别过程中使用。然后，验证者可以使用公钥本身来验证签名，以用于认证过程。见图16-3。当验证者有能力加载镜像时，就可以使用这种方法。Cerberus、Intel Boot Guard 和UEFI安全启动都采用了这种技术。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-2.jpg></img></div>
<div align=center>图 16-2 通过哈希的可读的固件镜像验证</div>

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-3.jpg></img></div>
<div align=center>图 16-3 通过数字签名的可读的固件镜像验证</div>

2. 读取密钥和质疑/响应。

有时验证器没有能力读取镜像。例如，主机系统固件无法访问设备固件。因此，我们可以依靠设备信任根来验证设备固件镜像，并依靠设备信任根向主机系统固件提供验证证据。主机验证器可以请求设备公钥，然后向设备发送带有随机数的质疑。然后，主机依据设备私钥签发的随机数签名来验证响应。见图16-4。这种技术不同于直接验证镜像的解决方案#1，因为在这里我们验证的是设备信任根的身份。既然是信任根，我们就相信它会验证设备固件镜像。该协议在安全协议和数据模型（SPDM）规范中定义，用于设备测量、认证和会话创建。硬件设备标准也采用了该协议，如外围组件互连接口（PCIe）、计算接口链接（CXL）和通用串行总线（USB）。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-4.jpg></img></div>
<div align=center>图 16-4 通过质疑/响应的设备固件镜像验证</div>

#### 数据执行预防

数据执行预防（DEP）是指系统内核将代码区域标记为写保护（WP），将数据区域标记为不可执行（NX）。这一规则可应用于任何可执行镜像，例如可移植和可执行（PE）通用对象文件格式（COFF）镜像或可执行和可链接格式（ELF）镜像。它还应适用于执行环境，例如栈或堆。见图16-5。

操作系统直接支持DEP。我们需要注意一些固件的特殊启用区域：

1) 大多数固件都有严格的大小要求。因此，链接脚本可能会将代码区与数据区合并，并使用最小对齐设置，如32字节。DEP技术无法应用于这种配置。DEP的最低要求是将代码区与数据区分开，并使用最小的页大小作为对齐方式，如4K字节。
2) 某些固件镜像可能包含自修改代码，尤其是模式切换代码，因为只有在运行时才能确定段的位置。一般不建议这样做。栈或全局数据区可用于保存此类信息。
3) 闪存区域上的就地执行（XIP）镜像可在常驻DRAM初始化之前的固件启动早期阶段使用。系统的页表空间可能有限。如果仍然需要应用该规则，我们需要将多个镜像合并为一个大镜像。因此，我们需要减少可执行区域页表中的条目数。
区域。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-5.jpg></img></div>
<div align=center>图 16-5 固件DEP环境</div>

#### 任意代码防护

任意代码防护意味着系统内核会将所有内存区域标记为不可执行，包括栈、堆和任何未使用的页。系统内核是调度镜像时唯一可以分配可执行内存的实体。其他模块无法自行分配可执行内存。

ACG技术是DEP的扩展。它可以阻止代码注入，因为其他模块无法分配代码页，而且所有现有代码页都被标记为只读。

在实践中，我们确实看到一些驱动程序可能会分配可执行代码的使用例子。例如，64位模式的UEFI代码模块可能需要切换到32位模式，来调用32位固件支持包（FSP）API。如果该模块检测到自己位于4GB以上的内存中，它将在4GB以下的内存中分配一个可执行代码区域，以便执行模式切换。因此，内核可以选择在调度所有模块后锁定代码区域分配，以防止任意代码的执行。

独立固件实现可以轻松应用这一规则，因为在调度所有镜像后，不需要加载额外的镜像，也不需要可执行内存。然而，当固件需要从另一个域（如操作系统）加载组件时，情况就变得复杂了。以UEFI固件为例，在UEFI内核加载操作系统加载器后，操作系统加载器可以为操作系统内核分配LoaderCode内存类型的内存，并跳转到操作系统内核。操作系统加载器必须具备为操作系统内核分配可执行内存的能力。内核需要了解新加载的模块，并在允许执行前验证代码的完整性。否则，任意代码将无法执行。

### 地址空间布局随机化

地址空间布局随机化（ASLR）是一种随机化执行环境内存的技术，例如可执行镜像或共享库的基地址、程序栈和程序堆。即使程序中存在漏洞，ASLR也能使攻击者更难预测目标地址。随机化技术可包括洗牌（最有可能用于镜像）或移位（最有可能用于数据）。图16-6以UEFI固件中的内存布局为例，展示了图像洗牌和数据移位。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-6.jpg></img></div>
<div align=center>图 16-6 UEFI固件中的ASLR</div>

#### 数据移位

数据移位用于堆或栈随机化。固件内核可以为堆保留一大块内存。当内核收到分配内存的请求时，内核会分配更多内存，并用随机数移位返回地址。随机数被测量作为熵。参见图16-7。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-7.jpg></img></div>
<div align=center>图 16-7 ASLR——数据移位</div>

我们来看一个例子。我们有页级分配，对齐方式为4K。如果我们将熵设为3位，那么最大随机数就是8。随机数有八种可能，0、1、2、3、4、5、6和7。因此，最终地址有八种可能：基地址 + 0、+ 0x1000、+ 0x2000、+ 0x3000、+ 0x4000、+ 0x5000、+0x6000 和 + 0x7000。如果攻击者想要猜测地址，他们只有八分之一的概率猜对。

在操作系统中，熵可能相当大，因为操作系统使用虚拟内存管理和多进程。而固件可能只有有限的资源用于简单的内存管理和单一进程。因此，我们可以考虑对固件采用不同的随机化策略。

1) 随机移位一次

内核可以在顶部分配一个随机大小的未使用内存区域，并始终分配精确的大小。见图16-8。假设内存分配算法是自上而下的。如果内存分配算法是自下而上的，那么不可用的内存就在底部。这是最简单的策略。风险在于，如果攻击者知道差异，他们就能计算出其余部分。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-8.jpg></img></div>
<div align=center>图 16-8 ASLR —— 随机移位一次</div>

2) 设置随机的栏

内核可以使用随机大小进行移位，并为空闲内存搜索设置一个栏。然后，内核会分配精确的大小。见图16-9。采用这种方法时，熵必须是一个大数，因为小数可能导致栏设置非常接近，不会带来太多随机性。然而，也可能出现这样的情况，系统有足够的内存，但栏设置得太低，导致内核无法找到已释放的内存。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-9.jpg></img></div>
<div align=center>图 16-9 ASLR —— 设置随机栏</div>

3) 扩大到固定分配大小

内核可以根据熵位 —— 最大随机数 —— 来扩大分配大小。然后，内核会移动一个随机大小，并返回最终数据。见图16-10。这种方法的优点是内存分配是确定的。这种方法的风险在于，如果熵太大，可能会导致较大的内存分配出现资源不足的情况。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-10.jpg></img></div>
<div align=center>图 16-10 ASLR —— 扩大到固定分配大小</div>

4) 扩大到随机的分配大小

对于#3，更好的解决方案是让内核根据随机数来扩大分配的内存大小。然后，内核会返回最终数据，并释放剩余的已分配内存。见图16-11。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-11.jpg></img></div>
<div align=center>图 16-11 ASLR —— 扩大到随机的分配大小</div>

不同的固件组件可能使用不同的策略。以UEFI固件为例。保留的内存、ACPI内存和运行时内存不能随机分配，因为我们必须为S4恢复流程保持相同的内存布局。因此，我们需要在顶部为这些用途预先分配一个大内存仓。在预EFI初始化（PEI）阶段，内存相当有限，而且PEI内核不支持内存释放操作。因此，我们可以使用#1 —— 随机移位一次。在UEFI环境中，整个系统内存都是可用的。然后，我们可以使用#4 —— 放大到随机分配大小。当系统管理模式存在到操作系统运行时，我们最好使用确定性技术，如#3。见图16-12和16-13。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-12.jpg></img></div>
<div align=center>图 16-12 ASLR —— PEI和UEFI内存</div>

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-13.jpg></img></div>
<div align=center>图 16-13 ASLR —— SMM内存</div>

ALSR的最大挑战在于熵的选择。熵值过小可能会导致保护不力。熵值过小也可能导致地址在多次系统重启后仍可预测。以前面为例，攻击者可以重启系统八次，然后他们可能会得到一次正确的地址并成功攻击系统。然而，较大的熵值可能会影响系统的稳定性。固件通常在资源有限的环境中运行。例如，X86系统管理模式（SMM）只有4至8MB的内存。微控制器可能只有几千字节。非常激进的随机化可能会过度浪费系统内存，并在某些特殊情况下导致资源耗尽。由于随机性，也很难调试这些情况。

#### 数据洗牌

为了在资源有限的情况下实现随机化，我们可以使用数据洗牌而不是移位。这是一个更好的解决方案，因为数据洗牌可以保证预留的内存使用，消除随机资源不足的问题。图16-14展示了一个采用镜像洗牌的系统示例。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-14.jpg></img></div>
<div align=center>图 16-14 ASLR —— 镜像洗牌</div>

内核可能会计算所有镜像所需的空间，并一次性分配一大块。然后，内核使用随机顺序逐个加载镜像。除了镜像位置随机外，内核还可以选择随机顺序来执行镜像。这种方法的好处是，镜像分配的数据也可以自动洗牌。

### 控制流防护

控制流防护可通过编译器防御技术启用，第15章已对此进行了讨论。下面我们讨论一些需要内核设置的控制流防御。

##### 后向边缘控制流

编译器可在目标函数中插入栈cookie或ARM指针验证码（PAC）的检查器，来支持后向控制流防护。英特尔控制流强制执行技术（CET）采用了另一种方法。利用CET，内核可以设置一个影子栈来捕捉栈溢出。无需编译器在目标函数中注入任何检查器。我们在第15章“英特尔控制流强制执行技术”一节中讨论了影子栈的概念。

由于内核需要建立栈，因此内核可以同时建立一个影子栈。运行时，影子栈保存函数返回地址。影子栈中的函数返回地址将被弹出，与正常栈中的函数返回地址进行比较，来查看返回地址是否被恶意代码修改。见图16-15。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-15.jpg></img></div>
<div align=center>图 16-15 英特尔CET —— 影子栈</div>

固件实现可能会执行C标准库函数 —— setjump()和longjump()。如果是这样，则必须更新实现来支持影子栈。除了将正常易失性寄存器（RBX、RSP、RBP、RDI、RSI、R12、R13、R14、R15、XMM6~XMM15、MXCSR）保存在跳转缓冲区上下文中外，setjump()实现还必须将影子栈指针（SSP）添加到跳转缓冲区中。因此，longjump()可以恢复原始SSP，使其与原始栈指针（RSP）匹配。

由于CET依赖于页表，如果固件实现需要禁用分页，例如从X64长模式切换到IA32保护模式，则必须在禁用分页之前禁用CET功能。在重新启用分页功能后，CET才能重新启用。

当固件实施CET影子栈时，必须确保影子栈的安全实施，并遵守以下列出的准则：
1) 影子栈必须位于只读页中，并在页表条目中设置dirty (D)位。因此，CPU知道这是一个有效的影子栈内存位置，并将内容写入影子栈。与此同时，内核必须清除dirty (D)位，以便正常读取，来防止CPU误将任何数据写入正常只读页。
2) 影子栈包含段值和返回地址。X86的有效段值为16位。因此，内核需要确保前64K字节的内存是不可执行的，以防止CPU将段值作为返回地址弹出并在那里执行代码。
3) 虽然CET支持写入影子栈指令，但强烈建议禁用写入影子栈（WRSS）功能。

#### 前向边缘控制流

编译器还支持插入前向边缘控制流检查器的能力，例如Clang控制流完整性（CFI）和Microsoft Visual Studio控制流防护（CFG）。编译器也支持基于硬件的控制流，如Intel CET间接分支跟踪（IBT）和ARM分支目标识别（BTI）。

我们在第15章“英特尔控制流执行技术”和“ARM 指针验证和内存访问控制”中讨论了这些功能。

除了编译器在目标函数中插入ENDBRANCH或BTI指令外，内核实现还需要在可能用于间接分支的汇编代码中明确添加ENDBRANCH或BTI指令。见图16-16。一个例子是异常处理程序，另一个例子是模式切换代码。它们通常都是用汇编代码实现的。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-16.jpg></img></div>
<div align=center>图 16-16 英特尔CET —— 间接分支跟踪</div>

### 地址消毒器

Clang编译器支持地址消毒器，来检测缓冲区溢出。但编译器需要为每个函数插入一个检查器，这将增加固件代码的大小。这在固件中可能是个问题，因为固件可能会加载第三方二进制模块。同样，内核可以在某个独立于编译器功能的级别上支持地址消毒器。这种方法的优点是只需更新内核，其他驱动程序可以照常运行。

#### 基于页表的堆防护

在堆中检测缓冲区溢出的基本思路是在目标缓冲区前后添加一个标签。大多数内存管理库已经有了这样的标签，但只有在释放缓冲区时才会检查标签。我们希望能在运行时检测缓冲区溢出，而不只是在释放缓冲区时。编译器消毒器会在访问缓冲区时插入标签检查器。这不能应用于内核，因为内核不能修改模块代码。不过，内核可以利用硬件功能，将标记区域标记为不可访问。页表就是一种选择。标签可以是不存在的页。它也被称为防护页。见图16-17。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-17.jpg></img></div>
<div align=center>图 16-17 防护页</div>

基于页表的堆防护是在已分配的缓冲区前后添加一个不存在的页。每当内核内存管理模块收到缓冲区分配请求时，它就会为防护页分配更多内存，更新页表，将两个防护页标记为不存在，并返回中间已分配的缓冲区。如果发生缓冲区溢出并且防护页被访问，CPU将产生一个页故障异常，因为防护页是被标记为不存在的内存。

实际上，缓冲区分配可以是页级分配，也可以是池级分配。对于页级分配，防护页可以位于已分配页的前后。见图16-18。页级分配的一个特殊功能是所分配的页可以部分释放。图16-19显示了一个例子。一开始分配了三个页。然后调用者释放了中间的第二个页，留下了一个空洞。为了支持堆防护功能，内核内存管理模块需要将防护页放在中间，以确保第一页和第三页仍然受到防护。

对于池级分配，防护页的设计略有不同。池级分配的一个问题是，分配的缓冲区大小可能不是页面大小的倍数。因此，防护页无法同时捕获缓冲区溢出和下溢。内核内存管理模块可以选择在缓冲区后添加一个防护页来捕捉溢出，或在缓冲区前添加一个防护页来捕捉下溢。见图16-20。在大多数情况下，我们看到问题是由缓冲区溢出引起的。因此，在缓冲区后添加防护页可以捕获更多问题。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-18.jpg></img></div>
<div align=center>图 16-18 页级分配的防护页</div>

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-19.jpg></img></div>
<div align=center>图 16-19 带有部分释放的页级分配的防护页</div>

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-20.jpg></img></div>
<div align=center>图 16-20 池级分配的防护页</div>

堆防护解决方案是一种捕捉缓冲区溢出的简单方法。页表是一项成熟的技术，几乎所有处理器都可以使用。不过，它也有一些局限性：

1) 最大的问题是大小开销。启用堆页面防护后，任何页分配都会导致多分配两个页。启用堆池防护后，每个池分配都会变成页分配。即使是1字节的分配，也需要三页内存。对于资源有限的环境，这可能会导致内存资源不足。
2) 我们还观察到，启用基于页表的堆防护后，性能会下降。每次分配和释放时，内核都必须重新加载页表并刷新页表捕获器 —— 转换旁路缓冲区（TLB）。在多处理器环境中，内核必须同步所有处理器的页表并刷新TLB，以确保缓冲区溢出能在所有的CPU环境中被捕获。
3) 有些固件解决方案使用ROM化的页表，例如X86固件的早期初始阶段。页表本身位于闪存映射的I/O空间上，它不可写入。我们还观察到，有一些固件解决方案在某种程度上锁定了页表，例如英特尔BIOS运行时弹性功能。因此，我们无法使用堆防护功能。

#### 内存标签

与页级保护相比，内存标记技术是一种轻量级选择。我们在第15章讨论了ARM内存标记扩展（MTE）。见图16-21。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-21.jpg></img></div>
<div align=center>图 16-21 内存标记</div>

当内核收到内存分配请求后，会为分配的缓冲区分配一个新标签，然后返回给请求者。在分配的缓冲区之前或之后的内存被分配了其他标签。因此，如果发生越界访问，可以被检测到，因为标签不同。释放缓冲区后，同一缓冲区可分配给其他标记。因此，也可以检测到使用后释放（use-after-free）。

标签实际上是内存地址的高位。从处理器的角度来看，地址空间被扩展了。图16-22举例说明了一个系统的标签位数为2位，共有4个标签。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-22.jpg></img></div>
<div align=center>图 16-22 带有标签的影子内存空间</div>

图16-23显示了一个缓冲区分配例子。例如，请求者调用服务分配0x60字节的内存。内核会在地址0x8765_0080 ~ 0x8765_0100处找到一个空闲的内存块。缓冲区后的内存（0x8765_0100 ~ 0x8765_0200）被标记为标签2；然后缓冲区后的最终地址为0x0200_0000_8765_0100 ~ 0x0200_0000_8765_0200。缓冲区之前的内存（0x8765_00040 ~ 0x8765_0080）被标记为标签3；然后缓冲区之前的最终地址为0x0300_0000_8765_0080 ~ 0x0300_0000_0000_8765_0040。内核为该缓冲区选择标签1，并返回0x0100_0000_8765_0100 ~ 0x0100_0000_0000_8765_0080。如果程序溢出访问缓冲区后的内存，那么指针将位于0x0100_0000_8765_0100和 0x0100_0000_8765_0200之间。由于该地址范围的标签不同于有效地址0x0300_0000_8765_0100 ~ 0x0300_0000_0000_8765_0200，因此CPU会阻止访问，并产生异常。

内存使用完毕后，内核需要释放内存。内核会将内存更改为标签0，有效地址切换为0x0000_0000_8765_0100 ~ 0x0000_0000_8765_0080。然后，如果程序出现“使用后释放”（use-after-free）问题，并仍以介于0x0100_0000_8765_0100和0x0100_0000_8765_0080之间的地址访问该区域，则可以再次捕获标记不匹配问题。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-23.jpg></img></div>
<div align=center>图 16-23 带有内存标签的缓冲区溢出检测</div>

内存标记的一个特殊优势是，如果两个对象使用不同的标签，它可以支持跨对象检测。与基于页表的堆防护类似，内存标记也有一些局限性：
1) 标记的内存大小有特定处理器的对齐要求。例如，ARM MTE要求16字节对齐的标记内存。小尺寸的溢出或下溢可能无法检测到。
2) 内存标签数量有限。以ARM MTE为例。标签字段只有4位。这意味着总共有16种不同的标签。内存分配算法需要确保相邻的两个内存区域具有不同的标记。在极少数情况下，如果溢出发生在两个具有相同标记的地址区域，则无法检测到溢出。

表16-3显示了地址消毒器解决方案总结。

表 16-3 地址消毒器解决方案总结
| | 运行时检测器 | 地址消毒器 | 堆防护 | 内存标记 |
| :--- | :--- | :--- | :--- | :--- |
| 溢出检测能力 | 栈 | 栈，堆，全局变量 | 堆 | 栈，堆，全局变量 |
| 硬件依赖 | 否 | 否 | 分页 | 硬件标签（ARM MTE）|
| 编译器依赖 | MSVC | Clang, GCC | 否 | 对于堆，否；对于栈和全局变量，是 |
| 对齐 | 4字节 | 8字节 | 页 | 处理器特定（ARM 16字节）|
| 跨目标检测 | 否 | 否 | 否 | 是 |
| 生产构建 | 否 | 否 | 否 | 是 |

#### 栈防护

固件内核通常会为其他驱动程序和应用程序设置栈和堆。在资源有限的环境中，我们需要精确计算所需的栈大小和堆大小。潜在的风险就是栈超限。如果分配的栈过小，栈可能会与堆内存重叠，从而导致堆损坏。见图16-24的左侧。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-24.jpg></img></div>
<div align=center>图 16-24 不带防护的栈和带防护的栈</div>

为了检测栈超限，我们可以在栈底部分配一个防护页 —— 页表中的不存在的页。这样，当发生栈超限时，CPU就会因为不存在的页访问而产生页面故障异常。除了防护页，我们还需要分配一个已知的良好页作为异常处理程序的栈，因为正常栈中没有任何空间。栈开关是处理器特定的。例如，IA32处理器需要设置一个任务，并使用任务切换来处理异常。X64处理器则可以直接使用异常处理程序中标识的栈开关。如果我们启用了影子栈功能，那么我们也可以对影子栈使用相同的机制。这是为了应对潜在的情况，即影子栈超限与正常栈超限同时发生。栈保护功能的最终内存布局如图16-24右侧所示。

## 遏制破坏

如果内核无法破解漏洞，那么内核就应该设法遏制破坏，防止攻击持续存在。域隔离是实现这种遏制的常用方法。这里的域指的是资源集合，包括物理内存、硬件设备、设备输入/输出、软件进程、软件服务等。

### 用户模式/监督模式

现代CPU架构支持用户模式和监督模式隔离的概念。操作系统内核在监督模式下运行，普通应用程序在用户模式下运行。用户模式应用程序可使用ARM监管调用（SVC）或X86系统调用（sysCall）进入监督模式。理想情况下，用户模式应用程序中的漏洞不会影响内核，因为内核有自己的执行域。一个用户模式应用程序中的漏洞不会影响其他用户模式应用程序，因为内核为不同的应用程序提供了不同的执行域。

操作系统架构有两种基本设计 —— 宏内核和微内核。见图16-25。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-25.jpg></img></div>
<div align=center>图 16-25 操作系统架构</div>

在宏内核下，所有操作系统组件都在监督模式下，例如内存管理、进程管理、设备驱动程序、网络驱动程序、输入/输出驱动程序、文件系统驱动程序等。应用程序使用系统调用接口与内核通信。典型的宏内核包括MS-DOS、Unix和Linux操作系统。应用程序使用系统调用与内核通信。

随着操作系统的不断向前发展，人们减少了内核中组件的数量。宏内核因此演变成了微内核。只有必要组件仍处于监督模式，例如内存管理和进程管理。其他操作系统组件则被取消权限，进入用户模式，并使用进程间通信（IPC）相互通信。内核中的组件数量越少，操作系统就越安全。设备驱动程序中的漏洞不会影响内核。不过，在实现时，人们也意识到微内核会带来性能上的损失，因为用户模式/监督模式的切换比宏内核模式所需的切换要频繁得多。

实际上，微内核要比宏内核小得多。典型的微内核包括MINIX、L3和L4。微内核的一个重要特性是安全。最近，人们开始关注微内核应用程序接口（API）的正式规范，包括API安全特性和实现正确性的正式证明。第三代微内核seL4号称是一个高保障、高性能的操作系统微内核。它的独特之处在于，在不影响性能的情况下进行了全面的正式验证。其他微内核包括QNX Neutrino 和Google Fuchsia Zircon内核。

如今，操作系统使用混合模式来平衡微内核的模块化设计和宏内核的性能优势。它运行微内核和其他操作系统组件，组件处于监督模式，例如Windows NT内核和macOS下的混合Mach内核。

如今，大多数系统固件都使用宏内核，如TianoCore EDK II或coreboot。由于系统固件的大部分任务是初始化芯片，访问设备需要监督模式权限，例如内存映射I/O (MMIO)、I/O、CPU特定型号寄存器（MSR）等设备。

在UEFI环境中，可以为PCIe选项ROM（OROM）启用环3用户模式执行。苹果Mac系统取消了OROM的权限，使其在环3用户模式下运行，并使用OROM沙盒监控OROM的行为。OROM只能调用和安装有限的预期UEFI接口子集，例如读写磁盘块或绘制图形。此外，OROM只能与指定的设备对话。每个OROM都是隔离的，因此无法相互攻击。因此，一个OROM的破坏不会影响系统和其他组件。见图16-26。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-26.jpg></img></div>
<div align=center>图 16-26 UEFI中的用户模式选项ROM</div>

某些特殊的非主机固件可实现用户模式/监督模式隔离，例如管理引擎（ME）或基板管理控制器（BMC）。嵌入式操作系统可应用于此类固件，例如ThreadX、FreeRTOS、Zephyr或Yocto。

#### 内核内存保护

如果启用了监督模式，内核就需要自我保护，以抵御来自用户模式的任何攻击。CPU提供了防止用户代码访问内核模式代码或内核数据的功能。然而，事实并非如此。内核通常被映射到每个进程的地址空间，以达到最佳性能。见图16-27。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-27.jpg></img></div>
<div align=center>图 16-27 内核地址空间映射到进程</div>

这种方法的风险在于经典的返回到用户（ret2usr）攻击。这种攻击可以通过使用用户空间地址覆盖内核控制的数据（例如返回地址、跳转表、函数表等）来实现。图16-28显示了两种ret2usr攻击模式。内核代码可能获取用户函数指针并执行用户代码，或者内核代码可能引用指向用户数据结构的数据结构并执行其中的函数。一个老例子就是NULL指针访问。用户模式代码可以准备一组精心选择的参数，以触发内核中的NULL指针解除引用，并构建一个程序，将任意代码映射到地址0。然后，内核可以直接调用用户提供的函数。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-28.jpg></img></div>
<div align=center>图 16-28 返回用户攻击</div>

#### 用户内存执行/访问预防

由于这种攻击的模式是以内核权限执行用户模式代码或在内核代码中访问用户模式数据，因此一种简单的缓解方法就是在硬件支持下，防止以内核权限执行用户模式代码，并防止访问用户模式数据。

##### 英特尔监督模式执行/访问防御

英特尔引入了监督模式执行预防（SMEP）功能，来防止内核执行任意用户模式代码。英特尔还引入了监督模式访问预防（SMAP）功能，来防止内核访问任意用户数据。

##### ARM永不特权执行/访问

ARM引入了与SMEP类似的“永不执行特权”（PXN）功能和与SMAP类似的“永不访问特权”（PAN）功能。启用这两项功能后，就可以阻止代码控制和数据控制这两种ret2usr攻击模式。见图16-29。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-29.jpg></img></div>
<div align=center>图 16-29 使用SMEP+SMAP/PXN+PAN的保护</div>

遗憾的是，仍然存在绕过SMEP+SMAP/PXN+PAN的攻击。Meltdown是一种利用乱序执行的侧信道攻击。在这种攻击中，用户模式代码可能会尝试访问内核数据结构。虽然访问会因权限违规而导致异常，但CPU仍会乱序执行指令，以获取内核数据并将其加载到CPU缓存中。虽然指令退出时没有提交最终结果，但CPU缓存中的数据并没有被清除。从内存和寄存器的角度来看，无法获取内核数据。然而，数据就在缓存中。它并不是不可见的。随后，用户模式代码会根据缓存访问和内存访问之间的时间差来识别缓存中的数据。这就是典型的基于时间的侧信道攻击。

#### 内核地址隔离

Meltdown攻击之所以能够得逞的原因之一是用户模式和内核模式代码共享同一个页表。因此，乱序执行的代码可以绕过特权模式隔离。为了缓解Meltdown攻击，一种技术是将内核模式页表与用户模式页表分开。用户页表只映射用户内存和上下文切换所需的最小内核内存。其余的内核内存不应存在。内核页表映射内核内存。用户内存不应存在，或通过SMAP+SMEP/PXN+PAN隔离。见图16-30。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-30.jpg></img></div>
<div align=center>图 16-30 内核地址隔离</div>

Linux实现了KAISER，也称为内核页表隔离（KPTI），来支持内核地址隔离。KAISER选择SMAP+SMEP作为实用方法，而不是未映射用户内存（也称为强内核隔离），因为强内核隔离需要重写当今内核的大部分内容。

固件可以实现用户模式/监督模式隔离。因此，用户模式代码中的漏洞不会影响内核。如果这样做，固件应采用当前的最佳实践。例如，应启用SMAP+SMEP/PXN+PAN来防止用户模式代码被内核执行或访问。应启用内核地址隔离来抵御Meltdown攻击。

### 虚拟机监控器

虚拟机监控器（VMM）是很早以前提出的一个概念。它可以作为参考监控器监控系统行为。虚拟机监控器的一个重要用途是在一个虚拟机域中隔离不受信任的应用程序。

VMM有两种基本类型。类型I VMM直接在机器硬件上运行。它可以是操作系统内核的一部分。它必须为系统中的所有虚拟机执行调度和资源分配，并需要硬件外设的驱动程序。类型II VMM作为主机操作系统上的应用程序运行，依赖主机系统进行内存管理、处理器调度、资源分配和硬件驱动程序。见图16-31。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-31.jpg></img></div>
<div align=center>图 16-31 VMM的两种类型</div>

尽管大多数CPU都在指令级支持监督模式和用户模式隔离，但监督模式下的指令集无法满足Popek和Goldberg定义的VMM类型I的要求。例如，Robin和Irvine总结了英特尔奔腾支持安全VMM的能力。如今，大多数CPU通过一组新指令和一种新的执行模式增加了对VMM的支持，例如Intel X86 CPU的 ROOT模式和ARM CPU的 HYP模式或异常级别2 (EL2)。可以通过ARM管理程序调用（HVC）或X86虚拟机调用（VmCall）进入管理程序模式。

