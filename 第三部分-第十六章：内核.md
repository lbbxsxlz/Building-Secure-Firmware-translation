## 第十六章

# 内核

固件的实现类似于嵌入式操作系统。它有一个内核来管理资源，例如系统内存，内核还负责分派任务。操作系统可以通过两种方式抵御软件攻击——破解漏洞和遏制破坏。与编译器防御技术类似，操作系统可以通过强制代码保护来破解漏洞，例如数据执行预防（DEP）、代码完整性防护（CIG）和任意代码防护（ACG）。地址空间布局随机化（ALSR）可使攻击者更难预测目标地址。如今，控制流防护（CFG）变得越来越重要，因为基于控制流的攻击可以绕过基本加固措施，如DEP。

如果内核无法破解漏洞利用，内核应将破坏控制在有限的范围内，并预防任何持续性破坏。权限隔离是遏制破坏的一种策略。在适当的硬件支持下，我们可以使用基于环的用户模式/监管模式隔离和基于虚拟机监控器（VMM）的隔离。加密域技术包括英特尔软件防护扩展（SGX）、AMD安全加密虚拟化（SEV）和英特尔信任域扩展（TDX）。域隔离也是另一种策略。可信执行环境（TEE）是另一个不错的选择，例如ARM TrustZone 技术和英特尔系统管理模式（SMM）。如果硬件支持域分区，一个平台可以独立运行两个或多个系统。表16-1列出了内核防御技术总结。

表 16-1 内核抵御技术总结
| 检测方法 | 检测预防 | 细节 |
| :--- | :--- | :--- |
| 破坏漏洞利用 | | |
| 代码保护（代码完整性防护）| 代码注入 | 内核只允许签名的可执行镜像执行。|
| 代码保护（数据执行预防）| 代码注入 | 内核将代码区标记为只读可执行，将数据区标记为可读写不可执行。执行环境，例如栈和堆，也应是不可执行的。|
| 代码保护（任意代码防护）| 代码注入 | 内核默认将内存区域标记为不可执行，例如栈，堆和释放内存。可执行内存不能被其他模块分配。|
| 地址空间布局随机化 | 缓存区溢出 | 内核会从堆中的随机位置分配数据，并移动镜像加载位置。|
| 控制流防护 | 控制流攻击 | 内核设置控制流执行环境，例如影子栈或分支目标保护。|
| 地址消毒器（栈防护）| 栈超限 | 内核会在栈底部设置一个防护页，来捕捉运行时堆栈超限。这种超限可能是由过多的递归函数调用或分配巨大的局部变量造成的。|
| 地址消毒器（堆防护）| 缓存区溢出 | 内核会为堆中已分配的内存设置防护页，来捕捉运行时的缓冲区溢出。|
| 地址消毒器（内存标记）| 缓存区溢出 | 内核会为已分配的内存分配一个特殊标签，来捕捉运行时缓冲区溢出。|
| 控制破坏 | | |
| 监管模式（内核内存保护）| 用户模式下的漏洞 | 内核会设置基于环的权限隔离，来防止用户模式代码访问内核模式数据。|
| 监督模式（用户内存执行/访问预防）| 用户模式下的漏洞 | 内核设置基于CPU的保护，以 防止内核执行用户代码和访问用户数据。|
| 监督模式（内核地址隔离）| 用户模式下的漏洞 | 内核会设置双页表，来防止来自用户模式代码的侧信道攻击。|
| 虚拟机监控器（管理程序保护的代码完整性）| 虚拟机中的漏洞 | 内核设置基于管理程序的权限隔离。管理程序验证内核代码的完整性，并设置数据执行防护。|
| 虚拟机监控器（内核数据保护KDP）| 虚拟机中的漏洞 | 内核设置基于管理程序的权限隔离。管理程序将关键内核内存标记为只读。|
| 虚拟机监控器（沙箱）| 虚拟机中的漏洞 | 虚拟机解释器为应用代码设置一个沙箱。|
| 可信执行环境 | 非可信环境中的漏洞 | 内核设置基于可信执行环境的域隔离。|
| 系统分区 | 在其他分区中的漏洞 | 内核设置基于硬件的域隔离。|

## 破坏漏洞利用

首先，让我们看看内核如何在运行时预防漏洞利用。

### 代码保护

代码保护技术用于防止代码注入攻击。代码保护包括三个方面：代码完整性防护（CIG）、数据执行预防（DEP）和任意代码防护（ACG）。图16-1以UEFI固件中带有DEP/CIG/ACG的内存布局为例进行说明。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-1.jpg></img></div>
<div align=center>图 16-1 UEFI固件中的代码保护（DEP，CIG，ACG）</div>

#### 代码完整性防护

代码完整性保护意味着固件只能加载已签名的代码。如果代码没有签名或由未知实体签名，则不会加载代码。

在第4、6和8章中，我们讨论了代码完整性检查程序的不同变体。表16-2列出了校验器的总结和需要校验的组件。最终的固件解决方案可根据威胁模型选择全部或部分子集。

表 16-2 代码完整性防护总结
| 技术 | 验证者 | 要验证的组件 |
| :--- | :--- | :--- |
| Cerberus, Titan | 平台信任根 | 主机或非主机可变固件的全部内容，包括平台OEM固件、基板管理控制器（BMC）等。|
| Intel Boot Guard | 硅片认证的代码模块 | 主机平台OEM固件 |
| UEFI Secure Boot | 平台原始设备制造商（OEM）固件 | 第三方固件代码，包括PCI选项ROM和操作系统加载器。|
| Linux Secure Boot Shim | Linux Shim作为加载器 | Linux操作系统加载器，Linux内核。|
| Windows CIG，Integrity Policy Enforcement(IPE) | 操作系统 | Windows可执行文件，Linux可执行文件。|
| SPDM，PCI Component Authentication | 主机固件和软件，非主机或设备启动器 | 设备固件。|

例如，如果您的平台信任非主机固件，但不信任平台OEM固件，那么您可以使用Cerberus或Titan作为平台信任根，或使用Intel Boot Guard作为硅片认证代码模块来执行验证。但如果也要验证非主机固件，则不能选择Intel Boot Guard，因为它不具备这种功能。

如果平台固件需要从其他存储区域，例如磁盘或PCI主机总线适配器卡，加载第三方组件，则可以使用UEFI安全启动来验证PCI选项ROM或操作系统加载器的完整性。如果系统非常特殊，没有PCI卡，且操作系统加载器已集成到系统固件中，则不需要UEFI安全启动。您可以选择平台信任根来验证OEM固件和操作系统内核，然后依靠操作系统内核来验证磁盘中的驱动程序。

最后，如果一个平台信任所有设备，那么就可以跳过设备认证过程。如果您正在设计一个高可靠性平台，并且需要验证任何硬件组件，那么您就需要一个平台信任根（PRoT）来验证非主机固件。这些非主机固件实体包括基板管理控制器（BMC）和管理引擎（ME），也称为服务器平台服务（SPS）等。这些非主机固件实体的设备固件可通过PCI数据交换（DOE）上的安全协议和数据模型（SPDM）协议或SMBus上的管理组件传输协议（PMCI）访问其设备固件。

根据镜像是否可读，有两种典型的代码完整性验证方式：

1. 加载镜像并验证:

验证器可以将镜像哈希值作为验证策略。见图16-2。这种技术的缺点是，每当镜像更新时，都需要更新镜像哈希值。另一种替代方法是使用镜像数字签名。镜像可以包含公钥和镜像签名。验证者可以携带公钥的哈希值，并用它来验证镜像的公钥，以便在识别过程中使用。然后，验证者可以使用公钥本身来验证签名，以用于认证过程。见图16-3。当验证者有能力加载镜像时，就可以使用这种方法。Cerberus、Intel Boot Guard 和UEFI安全启动都采用了这种技术。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-2.jpg></img></div>
<div align=center>图 16-2 通过哈希的可读的固件镜像验证</div>

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-3.jpg></img></div>
<div align=center>图 16-3 通过数字签名的可读的固件镜像验证</div>

2. 读取密钥和质疑/响应。

有时验证器没有能力读取镜像。例如，主机系统固件无法访问设备固件。因此，我们可以依靠设备信任根来验证设备固件镜像，并依靠设备信任根向主机系统固件提供验证证据。主机验证器可以请求设备公钥，然后向设备发送带有随机数的质疑。然后，主机依据设备私钥签发的随机数签名来验证响应。见图16-4。这种技术不同于直接验证镜像的解决方案#1，因为在这里我们验证的是设备信任根的身份。既然是信任根，我们就相信它会验证设备固件镜像。该协议在安全协议和数据模型（SPDM）规范中定义，用于设备测量、认证和会话创建。硬件设备标准也采用了该协议，如外围组件互连接口（PCIe）、计算接口链接（CXL）和通用串行总线（USB）。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-4.jpg></img></div>
<div align=center>图 16-4 通过质疑/响应的设备固件镜像验证</div>

#### 数据执行预防

数据执行预防（DEP）是指系统内核将代码区域标记为写保护（WP），将数据区域标记为不可执行（NX）。这一规则可应用于任何可执行镜像，例如可移植和可执行（PE）通用对象文件格式（COFF）镜像或可执行和可链接格式（ELF）镜像。它还应适用于执行环境，例如栈或堆。见图16-5。

操作系统直接支持DEP。我们需要注意一些固件的特殊启用区域：

1) 大多数固件都有严格的大小要求。因此，链接脚本可能会将代码区与数据区合并，并使用最小对齐设置，如32字节。DEP技术无法应用于这种配置。DEP的最低要求是将代码区与数据区分开，并使用最小的页面大小作为对齐方式，如4K字节。
2) 某些固件镜像可能包含自修改代码，尤其是模式切换代码，因为只有在运行时才能确定段的位置。一般不建议这样做。栈或全局数据区可用于保存此类信息。
3) 闪存区域上的就地执行（XIP）镜像可在常驻DRAM初始化之前的固件启动早期阶段使用。系统的页表空间可能有限。如果仍然需要应用该规则，我们需要将多个镜像合并为一个大镜像。因此，我们需要减少可执行区域页表中的条目数。
区域。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-5.jpg></img></div>
<div align=center>图 16-5 固件DEP环境</div>

#### 任意代码防护

任意代码防护意味着系统内核会将所有内存区域标记为不可执行，包括栈、堆和任何未使用的页面。系统内核是调度镜像时唯一可以分配可执行内存的实体。其他模块无法自行分配可执行内存。

ACG技术是DEP的扩展。它可以阻止代码注入，因为其他模块无法分配代码页，而且所有现有代码页都被标记为只读。

在实践中，我们确实看到一些驱动程序可能会分配可执行代码的使用例子。例如，64位模式的UEFI代码模块可能需要切换到32位模式，来调用32位固件支持包（FSP）API。如果该模块检测到自己位于4GB以上的内存中，它将在4GB以下的内存中分配一个可执行代码区域，以便执行模式切换。因此，内核可以选择在调度所有模块后锁定代码区域分配，以防止任意代码的执行。

独立固件实现可以轻松应用这一规则，因为在调度所有镜像后，不需要加载额外的镜像，也不需要可执行内存。然而，当固件需要从另一个域（如操作系统）加载组件时，情况就变得复杂了。以UEFI固件为例，在UEFI内核加载操作系统加载器后，操作系统加载器可以为操作系统内核分配LoaderCode内存类型的内存，并跳转到操作系统内核。操作系统加载器必须具备为操作系统内核分配可执行内存的能力。内核需要了解新加载的模块，并在允许执行前验证代码的完整性。否则，任意代码将无法执行。

### 地址空间布局随机化

地址空间布局随机化（ASLR）是一种随机化执行环境内存的技术，例如可执行镜像或共享库的基地址、程序栈和程序堆。即使程序中存在漏洞，ASLR也能使攻击者更难预测目标地址。随机化技术可包括洗牌（最有可能用于镜像）或移位（最有可能用于数据）。图16-6以UEFI固件中的内存布局为例，展示了图像洗牌和数据移位。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-6.jpg></img></div>
<div align=center>图 16-6 UEFI固件中的ASLR</div>

#### 数据移位

数据移位用于堆或栈随机化。固件内核可以为堆保留一大块内存。当内核收到分配内存的请求时，内核会分配更多内存，并用随机数移位返回地址。随机数被测量作为熵。参见图16-7。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-7.jpg></img></div>
<div align=center>图 16-7 ASLR——数据移位</div>

我们来看一个例子。我们有页面级分配，对齐方式为4K。如果我们将熵设为3位，那么最大随机数就是8。随机数有八种可能，0、1、2、3、4、5、6和7。因此，最终地址有八种可能：基地址 + 0、+ 0x1000、+ 0x2000、+ 0x3000、+ 0x4000、+ 0x5000、+0x6000 和 + 0x7000。如果攻击者想要猜测地址，他们只有八分之一的概率猜对。

在操作系统中，熵可能相当大，因为操作系统使用虚拟内存管理和多进程。而固件可能只有有限的资源用于简单的内存管理和单一进程。因此，我们可以考虑对固件采用不同的随机化策略。

1) 随机移位一次

内核可以在顶部分配一个随机大小的未使用内存区域，并始终分配精确的大小。见图16-8。假设内存分配算法是自上而下的。如果内存分配算法是自下而上的，那么不可用的内存就在底部。这是最简单的策略。风险在于，如果攻击者知道差异，他们就能计算出其余部分。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-8.jpg></img></div>
<div align=center>图 16-8 ASLR —— 随机移位一次</div>

2) 设置随机的栏

内核可以使用随机大小进行移位，并为空闲内存搜索设置一个栏。然后，内核会分配精确的大小。见图16-9。采用这种方法时，熵必须是一个大数，因为小数可能导致栏设置非常接近，不会带来太多随机性。然而，也可能出现这样的情况，系统有足够的内存，但栏设置得太低，导致内核无法找到已释放的内存。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-9.jpg></img></div>
<div align=center>图 16-9 ASLR —— 设置随机栏</div>

3) 扩大到固定分配大小

内核可以根据熵位 —— 最大随机数 —— 来扩大分配大小。然后，内核会移动一个随机大小，并返回最终数据。见图16-10。这种方法的优点是内存分配是确定的。这种方法的风险在于，如果熵太大，可能会导致较大的内存分配出现资源不足的情况。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-10.jpg></img></div>
<div align=center>图 16-10 ASLR —— 扩大到固定分配大小</div>

4) 扩大到随机的分配大小

对于#3，更好的解决方案是让内核根据随机数来扩大分配的内存大小。然后，内核会返回最终数据，并释放剩余的已分配内存。见图16-11。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-11.jpg></img></div>
<div align=center>图 16-11 ASLR —— 扩大到随机的分配大小</div>

不同的固件组件可能使用不同的策略。以UEFI固件为例。保留的内存、ACPI内存和运行时内存不能随机分配，因为我们必须为S4恢复流程保持相同的内存布局。因此，我们需要在顶部为这些用途预先分配一个大内存仓。在预EFI初始化（PEI）阶段，内存相当有限，而且PEI内核不支持内存释放操作。因此，我们可以使用#1 —— 随机移位一次。在UEFI环境中，整个系统内存都是可用的。然后，我们可以使用#4 —— 放大到随机分配大小。当系统管理模式存在到操作系统运行时，我们最好使用确定性技术，如#3。见图16-12和16-13。

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-12.jpg></img></div>
<div align=center>图 16-12 ASLR —— PEI和UEFI内存</div>

<div align=center><img src=Figures/Chapter-16-Screenshot/Figure-16-13.jpg></img></div>
<div align=center>图 16-13 ASLR —— SMM内存</div>

ALSR的最大挑战在于熵的选择。熵值过小可能会导致保护不力。熵值过小也可能导致地址在多次系统重启后仍可预测。以前面为例，攻击者可以重启系统八次，然后他们可能会得到一次正确的地址并成功攻击系统。然而，较大的熵值可能会影响系统的稳定性。固件通常在资源有限的环境中运行。例如，X86系统管理模式（SMM）只有4至8MB的内存。微控制器可能只有几千字节。非常激进的随机化可能会过度浪费系统内存，并在某些特殊情况下导致资源耗尽。由于随机性，也很难调试这些情况。

