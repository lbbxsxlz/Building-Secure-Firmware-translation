## 第十三章

# 虚拟固件

在前几章中，我们讨论了系统中真实固件的安全设计。现在我们来看一下虚拟固件。图13-1是一个典型的I型虚拟化架构。当系统固件完成平台初始化后，会启动管理程序。然后，管理程序创建四个域并启动它们。每个客户机域都有自己的虚拟固件。虚拟固件为客户机操作系统准备所需的接口，并启动客户机操作系统。

在真实机器中，固件的目的是初始化硬件，并为操作系统（OS）提供通用接口。因此，操作系统可以与平台无关。在虚拟机中，虚拟固件也有同样的作用。虚拟固件为客户机操作系统提供相同的通用接口。例如，如果客户机操作系统是UEFI Windows或UEFI Linux，虚拟固件需要为客户机UEFI操作系统创建UEFI环境。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-1.jpg></img></div>
<div align=center>图 13-1 虚拟化架构</div>

## 客户机域中的新威胁

当我们谈到安全，首先得要了解威胁模型。基于两种不同的使用案例，虚拟固件有两种不同的威胁模型：

    1） 客户机域信任管理程序

1972年，Anderson在“计算机安全技术规划研究”技术报告中提到了“参考监控器”的概念。参考监控器是一个抽象的机器，它控制着主体对客体的访问。参考监控器确保主体对客体拥有访问权限，并保护客体免受未经授权的访问。1974年，Popek和Goldberg发表了“可虚拟化的第三代体系结构的形式要求”，并提到了虚拟机监控器（VMM）（也称为管理程序）的三个特性：1）效率；2）资源控制；3）等价性。由于VMM可以控制系统资源，因此它是个很好的参考监控器备选。在大多数当前虚拟化架构中，VMM可以访问和控制客户机域的行为。例如，IT人员可能会在发送给企业用户的笔记本电脑上安装一个管理程序来保护客户机操作系统。当最终用户使用操作系统时，他们会信任管理程序。

在这种情况下，客户机依赖管理程序提供保护。虚拟固件可以信任硬件设备和管理程序提供的软件服务。管理程序控制着一切。虚拟固件无需考虑特殊的新威胁。

    2） 客户机域不信任管理程序

然而，云世界的情况发生了变化。在基础设施即服务（IaaS）模式中，云服务提供商（CSP）在物理机上建立了虚拟机监控器，并提供虚拟机作为服务来出租。现在的问题是：租客是否信任云服务提供商？让我们逐一考虑CIA的三要素：机密性、完整性和可用性。首先是机密性。租客可能不想与CSP共享公司的秘密数据。其次是完整性。租客可能不想让CSP修改任何公司数据。第三是可用性。租客可能不希望来自CSP的服务意外中断。

可用性应该由CSP维护。CSP在提供云服务时应采用可靠性、可用性和可维护性（RAS）。非信任输入在使用前应经过验证，例如网络数据包或磁盘镜像，这与真实系统固件类似。但是，如果CSP因网络断开或管理程序关闭而停止服务，虚拟固件将无能为力。

这种情况下的保密性和完整性比较特殊，因为CSP被视为恶意，并且CSP可能会尝试攻击客户机域。例如，攻击者可能会在管理程序中放置扫描仪来扫描客户机内存以获取机密。攻击者可能会在虚拟固件中植入rootkit来控制客户机操作系统。因此，客户机域需要一种方法来保护其数据免遭管理程序的攻击。

从高层来看，虚拟机数据可分为三类：1）处于静态的数据；2）传输中的数据；3）使用中数据。处于静态的数据可以通过加密来保护。传输中的数据可以通过网络协议（例如传输层安全TLS）来保护。使用中数据的保护需要虚拟固件的硬件辅助。

### 案例研究

现在，让我们来看一下虚拟化中安全扩展的一些实际案例。

#### AMD安全加密虚拟化（SEV）

当CPU执行代码或引用数据时，需要访问明文内存。在目前的大多数架构中，DRAM中的数据也是明文。这就带来了潜在的风险，如果攻击者能劫持内存总线，他们就能读取数据并修改数据。为了减少这种攻击，AMD采用了安全内存加密（SME），对发送到DRAM的数据进行加密（见图13-2）。因此，内存总线上或DRAM中的数据都是密文。每个CPU片上系统（SOC）都包含一个带有一个高级加密标准（AES）引擎AMD安全处理器（AMD-SP），用于加密和解密数据。AES密钥在每次重置系统时随机生成，并且SOC外部无法使用。

SME功能可以根据页表来部分启用。页表中的物理地址有一个enCrypted位（C位），用于指示该页是否需要加密。因此，操作系统可以决定哪些内存范围需要加密。为了向不知道新C位的操作系统提供支持，CPU可以代替使用透明SME(TSME)。在TSME模式下，无论C位是设置还是清除，所有内存都会被加密。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-2.jpg></img></div>
<div align=center>图 13-2 AMD SME架构</div>

SME功能很好，但并不能解决云世界中的所有问题，因为管理程序仍然可以访问客户机域的内存。只有一个密钥在SME中使用。

AMD安全加密虚拟化（SEV）技术使用SME，并增加了一个具有多个加密密钥的扩展功能（见图13-3）。在启动过程中，每个客户机域都有一个唯一的虚拟机（VM）地址空间ID（ASID）。SEV硬件为数据或代码分配一个了带有虚拟机ASID的标签。当数据进入或离开SOC时，数据将根据相关标签使用唯一密钥进行加密或解密。因此，管理程序或其他域无法访问该域中的内存。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-3.jpg></img></div>
<div align=center>图 13-3 AMD SEV架构</div>

在某些情况下，客户机域需要与管理程序通信来共享信息。因此，客户机可以选择禁用通信缓冲区的加密，将其作为共享页面，而将其他页面加密为私有页面（见图13-4）。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-4.jpg></img></div>
<div align=center>图 13-4 AMD SEV通信</div>

共享内存的一个例子是用于直接内存访问（DMA）的内存。DMA不允许加密。如果客户机设备驱动程序需要使用DMA与管理程序模拟的设备或真实硬件设备通信，设备驱动程序需要分配一个DMA缓冲区并清除C位。当DMA缓冲区被回收为正常内存页时，该驱动程序需要清除C位，将其标记为私有页。

SEV的安全性基于加密密钥的安全性。由于每个虚拟机都需要一个唯一的密钥，SEV固件需要提供一个密钥管理接口，来执行三个安全属性： 1）平台的真实性；2）已启动客户机的证明；3）客户机数据的机密性。

平台的真实性可由SEV固件中的身份密钥证明。每个SEV平台都包含一个由AMD和平台所有者分配的身份密钥。客户机的证明可通过客户机的镜像测量来证明。当SEV固件启动客户机固件时，它也会测量客户机镜像。之后，SEV固件可将测量提供给客户机的所有者。由于SEV固件已通过身份密钥认证，因此客户机所有者会信任SEV固件。只有在客户机所有者验证了测量并决定信任该客户机镜像后，客户机所有者才会向客户机镜像传输更多数据，例如用于解密虚拟机磁盘的磁盘加密密钥。客户机数据的保密性基于SEV固件已知的内存加密密钥。SEV固件不得泄露加密密钥，也不得泄露任何有关加密密钥的线索。

AMD SEV可对客户机内存进行加密。但管理程序可能会通过修改RAX/RBX/RCX/RDX等客户寄存器来篡改客户程序的执行。AMD SEV加密状态（SEV-ES）为客户机寄存器状态提供了额外保护。在启动过程中，客户机寄存器被初始化为已知状态，并作为SEV启动过程的一部分进行加密和测量。完整性检查针对每个VMRUN进行。使用SEV-ES为虚拟机分配专用的虚拟机保存区（VMSA），其中包含例如段状态、控制状态、通用寄存器（GPR）状态和浮点运算单元（FPU）状态等信息。
(FPU) 状态等信息。

如果客户机域需要使用GPR与管理程序通信，那么管理程序就必须访问客户机寄存器区域。因此，客户机需要将寄存器复制到专用的客户机管理程序通信块（GHCB）。见图13-5。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-5.jpg></img></div>
<div align=center>图 13-5 使用GHCBAMD SEV-ES通信</div>

让我们以CPUID指令为例。CPUID指令使用EAX寄存器作为输入，并使用EAX、EBX、ECX和EDX寄存器作为输出。在没有SEV-ES的虚拟化环境中，当客户机域执行CPUID指令时，会触发VmExit。管理程序会解析VmExit原因，来了解是CPUID指令触发了VmExit。然后，管理程序会获取EAX值作为CPUID索引，并在客户机通用寄存器字段中设置EAX/EBX/ECX/EDX，然后恢复客户机。

然而，这一流程无法与SEV-ES配合使用，因为管理程序不被允许直接从客户机读取EAX或向客户机写入EAX/EBX/ECD/EDX。有两种方法可以解决这个问题：1）客户机软件可以用另一种操作取代CPUID指令，即写入GHCB中的EAX、触发VmExit，并从GHCB中读取EAX/EBX/ECX/EDX。这会给现有的客户机软件二进制文件带来兼容性问题。2）另一种方法是利用新的VMM通信异常（#VC）。见图13-6。当客户机软件执行CPUID时，CPU硬件会触发一个带有错误码的#VC异常，以指示该指令是什么。然后，客户机#VC异常处理程序可将指令（CPUID）及其输入参数（EAX）写入GHCB，并触发VmExit。相应的管理处理程序会解析GHCB中的指令和输入数据，将指令的输出数据写入GHCB，并恢复到客户机。然后，客户机#VC处理程序将指令（CPUID）的输出参数（EAX/EBX/ECX/EDX）读到CPU寄存器。在新的#VC处理程序的帮助下，兼容性得以保持。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-6.jpg></img></div>
<div align=center>图 13-6 使用GHCB和#VC的AMD SEV-ES通信</div>

这种GHCB通信机制可用于需要管理程序解析客体机状态的指令，例如CPUID、读MSR、写MSR、I/O读、I/O写等。有了SEV-ES，客户机内存和客户机状态就不会被管理程序篡改。客户机固件需要启用该功能，以提供其执行环境。

更多详细信息，请参阅《AMD架构程序员手册》。

#### 英特尔可信域执行（TDX）

英特尔提供内存加密功能。全内存加密（TME）提供基本的内存加密功能。它类似于AMD SME。它使用一个短暂密钥对系统的整个物理内存进行加密。为了支持虚拟化环境中的客户机内存安全性，英特尔以灵活的方式提供了多密钥全内存加密（MKTME）。通过MKTME，每个页面都可以标记一个密钥ID。在运行时期间，管理程序会为不同的虚拟机分配不同的KeyID，以实现域隔离。以图13-7为例。管理程序有一个共享KeyID 0和一个私有KeyID 1。客户机域0与管理程序共享KeyID 0、与域1共享的KeyID 4和私有KeyID 2。客户机域1与管理程序共享KeyID 0，与域1共享KeyID 4，以及私有KeyID 3。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-7.jpg></img></div>
<div align=center>图 13-7 英特尔使用KeyID的MKTME通信</div>

对于DMA，管理程序可以在IOMMU页表中设置KeyID，类似于在外部页表（EPT）——主机页表中设置KeyID的方式。对于物理DMA，KeyID可直接应用于物理地址。这种设计可以简化客户机软件。

更多详细信息，请参阅英特尔MKTME规范。

在英特尔MKTME和虚拟化技术的基础上，英特尔推出了可信域执行（TDX）技术。英特尔TDX类似于AMD SEV。它可以提供一个硬件隔离的虚拟机（VM），称为可信域（TD）。TD有两种功能：

    1）内存和CPU状态的机密性和完整性。TD只信任：在安全仲裁模式（SEAM）下执行的英特尔TDX模块、英特尔认证代码模块（ACM），也称为SEAM加载器（SEAMLDR）、英特尔TD Quoting Enclave(QE)和英特尔CPU硬件。TD中的数据受到保护，可抵御来自软件的攻击，例如其他虚拟机或TD、管理程序、BIOS系统管理模式（SMM）、集成设备等。它还能抵御来自硬件的攻击，例如离线内存分析和主动内存攻击，包括捕获、修改、重定位、拼接和别名。但是，内存重放攻击不在此范围内。TD仍依赖管理程序来设置资源。内存和CPU状态的可用性不在攻击范围内。

    TDX模块是英特尔TDX的一个关键概念。它由SEAM加载器加载到SEAM内存中，并受SEAM范围寄存器（SEAMRR）的保护。它管理TD与管理程序之间的转换。如果出现虚拟机退出事件导致TD客户机退出，CPU将切换到英特尔TDX模块，而不是管理程序。然后，英特尔TDX模块使用SEAMRET指令切换到管理程序。管理程序处理虚拟机退出事件后，使用SEAMCALL指令切换到英特尔TDX模块。然后，英特尔TDX模块执行虚拟机进入，以恢复TD客户机。图13-8显示了英特尔TDX模块流程。

<div align=center><img src=Figures/Chapter-13-Screenshot/Figure-13-8.jpg></img></div>
<div align=center>图 13-8 英特尔TDX模块流程</div>
