## 第二十章

# 编程语言

在本开发部分的最后一章中，我们将探讨固件开发中的语言选择。鉴于已有大量教材介绍各种编程语言本身，本文将不深入探讨语言细节，而是聚焦于固件开发中可能采用的不同语言的安全特性。

编程语言主要分为三类：机器语言、汇编语言和高级语言。如今几乎无人使用第一代机器语言——这种语言采用二进制格式0和1来表示机器代码。让我们从汇编语言开始探讨。

## 汇编语言

汇编语言是第二代编程语言。它属于低级语言，因为它使用符号替代二进制0和1来表示机器代码。汇编语言难以编写、调试、审查和维护。汇编语言中常见的问题罗列如下：
1) 非易失性寄存器访问：非易失性寄存器在函数调用过程中需被保护。例如，根据调用约定，RBX寄存器是非易失性寄存器。它应在函数入口处保存，并在函数退出时使用后恢复，或者完全避免在函数内使用。若RBX寄存器在函数内使用，但未被保护和恢复，将导致调用方与被调用方之间的契约失效。
2) 错误的栈偏移量：函数使用栈存储局部变量和函数参数。通常,这些数据可通过栈偏移量访问，例如[RBP – 0x20]或[RSP + 0x38]。其中RBP是栈基地址寄存器，RSP是栈指针寄存器。通常，RBP应该被使用，因为它一旦在函数入口处设定后就不会改变。使用RSP配合偏移量是危险的，因为RSP会受到栈PUSH和POP指令影响。数据可能通过[RSP + 0x38]正确访问，但在PUSH操作后，同一数据需通过[RSP + 0x40]访问。
3) 寄存器误用：指令集仅提供有限数量的寄存器。使用汇编语言时，程序员必须明确每个寄存器的用途。有时指令要求使用RDX寄存器，但代码却使用了另一个寄存器RAX。这是典型的复制粘贴错误。程序员从其他地方复制代码片段后，忘记更新所有相关位置。
4) 循环计数器偏移量错误：指令集包含循环计数器寄存器，例如IA指令集中的RCX。LOOP指令会导致RCX自减。类似于C语言的for循环，错误的计数器可能引发偏移量错误（OBOE），进而导致缓冲区溢出。
5) 语法混淆：汇编语言缺乏标准。不同汇编语法可能产生不同的机器码转换方式。以IA指令为例。GNU汇编器(GSA)采用AT&T语法，微软汇编器(MASM)则使用Intel语法。最大问题在于这两种语法中源操作数与目标操作数的顺序存在差异。若需将RCX寄存器值存入RAX寄存器，Intel语法应写为“MOV RAX, RCX”，AT&T语法则为“MOVQ %RCX, %RAX”。我们见过大量案例：开发者因只熟悉其中一种语法，在复制代码后转换为另一种语法时，因顺序错误导致问题。

这些汇编语言问题无法被汇编器检测到，因为汇编器只是遵循指令将其转换为机器码，而无法理解其真实意图。通常，汇编语言的使用应限制在某些特殊领域：

1) 启动代码：这是CPU通电后的第一条指令。启动代码应尽快为高级语言设置运行环境，例如为C语言设立栈。
2) 模式切换：指令集可能定义多种CPU执行模式，例如16位实模式、32位保护模式和64位长模式。不同模式间的切换需要特殊处理，例如设置控制寄存器或模式特异寄存器，并切换至不同段地址。高级语言通常不提供此类支持。
3) 异常处理程序：当系统遭遇软异常或硬件中断时，CPU将切换到异常处理程序。异常处理程序的入口通常采用汇编语言编写，因为高级语言无法处理CPU上下文的保存与恢复。
4) 设置跳转与长跳转：这是两个标准C函数。setjump()保存当前位置，longjump()则在后续跳转至该位置。由于当前位置包含CPU上下文信息，这两个函数均采用汇编语言实现。
5) 特殊指令：以IA指令集为例，其包含特殊寄存器访问指令，例如控制寄存器（CR）、特定型号寄存器（MSR）、流式（SIMD）扩展（SSE）、高级向量扩展（AVX）等，以及特殊指令，例如串行化加载操作（LFENCE）、刷新缓存行（CFLUSH）、性能优化的自旋等待循环（PAUSE）、数据进内存非临时存储（MOVNTI）等特殊指令。

建议为这些操作的抽象提供高级语言库。因此，其他代码也应调用该库来完成工作。汇编语言在这些有限领域仍具实用价值，但其使用范围应仅限于这些领域。其余部分应归属于高级语言。

## C语言

C语言自诞生于Unix操作系统以来，或许是最受欢迎且最成功的编程语言。它是高级语言，但能胜任低级任务，例如修改内存内容或修改特定地址处的内存映射I/O寄存器。在固件领域，C语言堪称最佳选择，因为固件需要直接访问硬件相关内容，例如内存或内存映射I/O寄存器，而C语言在此领域表现卓越且功能强大。借助C语言，开发者能够完全掌控机器硬件。我们认为这源于C语言的本质——它诞生于Unix操作系统的编写需求。

现在让我们从安全角度审视C语言。根据微软的研究，内存安全问题占C和C++语言安全漏洞的70%。我们在固件领域也观察到类似数据：缓冲区溢出和整数溢出导致了50%的安全问题。原因在于固件本质上也属于软件范畴。固件同样存在类似的内存安全问题，包括内存访问错误，例如缓冲区溢出、释放后使用，以及未初始化数据错误，例如野指针、空指针引用等。

在第14章，我们探讨了C语言编程的最佳实践与规范。在第15章，我们阐述了C编译器的防御性技术。在第16章，我们则聚焦于固件内核增强方案。一方面，整个行业已提供应对这些缺陷的指导与工具；另一方面，人们也在寻求更优的类型安全语言，以从源头防止开发者引入缺陷。

## Rust

Rust是一种新型语言。若将C语言视为可移植的汇编语言，那么Rust便是安全的C语言。Rust语言的设计旨在赋能开发者构建可靠高效的软件。它提供了

1) 性能：Rust运行速度极快且内存效率高。它没有运行时环境或垃圾回收机制。它能够驱动性能关键型服务并在嵌入式设备上运行。运行时性能和运行时内存消耗对固件至关重要，因为典型的固件运行在资源受限的环境中。即便在英特尔架构（IA）系统固件中，代码也需在系统管理模式（SMM）下运行，该模式仅配备有限的系统管理内存（SMRAM），例如1MB或8MB。嵌入式设备同样面临类似限制。Rust嵌入式版本提供灵活的内存管理方案，动态内存分配可选。开发者可选择使用全局分配器与动态数据结构，或采用全静态分配方案。此设计必要性在于：固件代码可能在无DRAM的闪存设备上运行。
2) 可靠性：Rust引入了丰富的类型系统和所有权模型，确保内存安全与线程安全，使您能在编译时消除多类错误。这或许是最具吸引力的特性。Rust并非首个引入类型安全概念的语言。类型安全语言面临的主要担忧在于运行时类型检查导致的性能下降。对于嵌入式系统或固件而言，这种性能影响难以接受。Rust的优势在于多数检查已在编译时完成。因此最终生成的二进制文件无需执行此类检查。凭借严格的语法规则，Rust能追踪数据对象的生命周期，因此无需运行时垃圾回收。这种设计不仅缩减了二进制文件大小，更显著提升了运行时性能。
3) 生产力：Rust拥有友好的编译器，能提供有用的错误信息。编译器不仅指出问题所在，还会给出修复建议。它引导你如何编写Rust语言。Rust提供了单元测试框架，你可以在函数实现后立即编写一组单元测试。Rust还通过外部函数接口（FFI）实现了与其他语言的互操作性。它能生成兼容C语言的应用程序二进制接口（ABI），支持Rust调用C语言程序，或从C语言调用Rust程序。

### Rust安全解决方案

固件开发中的主要安全问题类别包括内存安全问题和算术问题。在第15章，我们讨论了两种编译器防御策略：消除漏洞和破坏漏洞利用。Rust通过在编译时引入严格规则，在消除漏洞方面表现出色。任何违规都会导致构建失败。同时Rust为缓冲区溢出注入运行时边界检查以破坏利用。生成的代码会在运行时违规时调用panic处理程序。表20-1展示了Rust处理安全问题的解决方案。两种经典内存安全问题 ——空间安全问题与时间安全问题—— 被分别解决。让我们逐一审视这些方案。

表 20-1 Rust安全解决方案

|  类型  |  子类型  | Rust解决方案 |
| :----- | :----- | :----- |
| 访问错误（空间）| 缓冲区溢出（写）| 为切片（Slice）使用偏移/索引<br>运行时边界检查 - [panic_handler] |
|        | 缓冲区过度读取 | 为切片（Slice）使用偏移/索引<br>运行时边界检查 - [panic_handler] |
| 访问错误（时间）| 使用后释放（悬空指针）| 所有权 —— 编译时检查 |
|        | 双重释放 | 所有权 —— 编译时检查 |
| 未初始化数据 | 未初始化变量 | 初始化 —— 编译时检查 |
|        | 野指针 | 初始化 —— 编译时检查 |
|        | 空指针解引用 | 使用 Option <T>枚举<br>分配检查 —— [alloc_error_handler] |
| 算术问题 | 整型溢出 | DEBUG: 运行时检查 —— [panic_handler].<br>RELEASE: 丢弃溢出数据.<br>编译标记: -C overflow-checks=on/off.<br>函数: checked\|overflowing\|saturating\|wrapping_add\|sub\|mul\|div\|rem\|shlshr\|pow(). |
|         | 类型转换 | 必须显式指定 —— 编译时检查.<br>(Dest Size == Source Size) => no-op<br>(Dest Size < Source Size) => truncate<br>(Dest Size > Source Size) => {<br>(source is unsigned) => zero-extend<br>(source is signed) => sign-extend<br>} |

Rust内存安全的核心在于隔离别名与变异。别名意味着同一数据可通过多种方式访问。数据具有共享性。变异则指所有者拥有更新数据的权限。数据可被修改。危险源于别名与变异的结合。

让我们看看清单20-1中的C程序。你能发现多少问题？

清单 20 -1

```
char *a1 = "hello world!";
char *b1 = "hello world!";
{
    int main()
    char *a2 = strdup (a1);
    char *b2 = a2;
    char *b3 = strchr (a2, 'h');
    char *b4 = strchr (a2, 'w');
    *a1 = 'k';
    *a2 = 'l';
    *(a1 + 19) = 'm';
    *(a2 + 19) = 'n';
    printf("a1=%s (%p)\n", a1, a1);
    printf("a2=%s (%p)\n", a2, a2);
    printf("b1=%s (%p)\n", b1, b1);
    printf("b2=%s (%p)\n", b2, b2);
    printf("b3=%s (%p)\n", b3, b3);
    printf("b4=%s (%p)\n", b4, b4);
    free (a1);
    free (a2);
    free (b1);
    free (b2);
    free (b3);
    free (b4);
    printf("OK\n");
    return 0;
}
```