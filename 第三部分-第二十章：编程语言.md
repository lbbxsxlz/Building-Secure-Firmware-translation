## 第二十章

# 编程语言

在本开发部分的最后一章中，我们将探讨固件开发中的语言选择。鉴于已有大量教材介绍各种编程语言本身，本文将不深入探讨语言细节，而是聚焦于固件开发中可能采用的不同语言的安全特性。

编程语言主要分为三类：机器语言、汇编语言和高级语言。如今几乎无人使用第一代机器语言——这种语言采用二进制格式0和1来表示机器代码。让我们从汇编语言开始探讨。

## 汇编语言

汇编语言是第二代编程语言。它属于低级语言，因为它使用符号替代二进制0和1来表示机器代码。汇编语言难以编写、调试、审查和维护。汇编语言中常见的问题罗列如下：
1) 非易失性寄存器访问：非易失性寄存器在函数调用过程中需被保护。例如，根据调用约定，RBX寄存器是非易失性寄存器。它应在函数入口处保存，并在函数退出时使用后恢复，或者完全避免在函数内使用。若RBX寄存器在函数内使用，但未被保护和恢复，将导致调用方与被调用方之间的契约失效。
2) 错误的栈偏移量：函数使用栈存储局部变量和函数参数。通常,这些数据可通过栈偏移量访问，例如[RBP – 0x20]或[RSP + 0x38]。其中RBP是栈基地址寄存器，RSP是栈指针寄存器。通常，RBP应该被使用，因为它一旦在函数入口处设定后就不会改变。使用RSP配合偏移量是危险的，因为RSP会受到栈PUSH和POP指令影响。数据可能通过[RSP + 0x38]正确访问，但在PUSH操作后，同一数据需通过[RSP + 0x40]访问。
3) 寄存器误用：指令集仅提供有限数量的寄存器。使用汇编语言时，程序员必须明确每个寄存器的用途。有时指令要求使用RDX寄存器，但代码却使用了另一个寄存器RAX。这是典型的复制粘贴错误。程序员从其他地方复制代码片段后，忘记更新所有相关位置。
4) 循环计数器偏移量错误：指令集包含循环计数器寄存器，例如IA指令集中的RCX。LOOP指令会导致RCX自减。类似于C语言的for循环，错误的计数器可能引发偏移量错误（OBOE），进而导致缓冲区溢出。
5) 语法混淆：汇编语言缺乏标准。不同汇编语法可能产生不同的机器码转换方式。以IA指令为例。GNU汇编器(GSA)采用AT&T语法，微软汇编器(MASM)则使用Intel语法。最大问题在于这两种语法中源操作数与目标操作数的顺序存在差异。若需将RCX寄存器值存入RAX寄存器，Intel语法应写为“MOV RAX, RCX”，AT&T语法则为“MOVQ %RCX, %RAX”。我们见过大量案例：开发者因只熟悉其中一种语法，在复制代码后转换为另一种语法时，因顺序错误导致问题。

这些汇编语言问题无法被汇编器检测到，因为汇编器只是遵循指令将其转换为机器码，而无法理解其真实意图。通常，汇编语言的使用应限制在某些特殊领域：

1) 启动代码：这是CPU通电后的第一条指令。启动代码应尽快为高级语言设置运行环境，例如为C语言设立栈。
2) 模式切换：指令集可能定义多种CPU执行模式，例如16位实模式、32位保护模式和64位长模式。不同模式间的切换需要特殊处理，例如设置控制寄存器或模式特异寄存器，并切换至不同段地址。高级语言通常不提供此类支持。
3) 异常处理程序：当系统遭遇软异常或硬件中断时，CPU将切换到异常处理程序。异常处理程序的入口通常采用汇编语言编写，因为高级语言无法处理CPU上下文的保存与恢复。
4) 设置跳转与长跳转：这是两个标准C函数。setjump()保存当前位置，longjump()则在后续跳转至该位置。由于当前位置包含CPU上下文信息，这两个函数均采用汇编语言实现。
5) 特殊指令：以IA指令集为例，其包含特殊寄存器访问指令，例如控制寄存器（CR）、特定型号寄存器（MSR）、流式（SIMD）扩展（SSE）、高级向量扩展（AVX）等，以及特殊指令，例如串行化加载操作（LFENCE）、刷新缓存行（CFLUSH）、性能优化的自旋等待循环（PAUSE）、数据进内存非临时存储（MOVNTI）等特殊指令。

建议为这些操作的抽象提供高级语言库。因此，其他代码也应调用该库来完成工作。汇编语言在这些有限领域仍具实用价值，但其使用范围应仅限于这些领域。其余部分应归属于高级语言。

## C语言

C语言自诞生于Unix操作系统以来，或许是最受欢迎且最成功的编程语言。它是高级语言，但能胜任低级任务，例如修改内存内容或修改特定地址处的内存映射I/O寄存器。在固件领域，C语言堪称最佳选择，因为固件需要直接访问硬件相关内容，例如内存或内存映射I/O寄存器，而C语言在此领域表现卓越且功能强大。借助C语言，开发者能够完全掌控机器硬件。我们认为这源于C语言的本质——它诞生于Unix操作系统的编写需求。

现在让我们从安全角度审视C语言。根据微软的研究，内存安全问题占C和C++语言安全漏洞的70%。我们在固件领域也观察到类似数据：缓冲区溢出和整数溢出导致了50%的安全问题。原因在于固件本质上也属于软件范畴。固件同样存在类似的内存安全问题，包括内存访问错误，例如缓冲区溢出、释放后使用，以及未初始化数据错误，例如野指针、空指针引用等。

在第14章，我们探讨了C语言编程的最佳实践与规范。在第15章，我们阐述了C编译器的防御性技术。在第16章，我们则聚焦于固件内核增强方案。一方面，整个行业已提供应对这些缺陷的指导与工具；另一方面，人们也在寻求更优的类型安全语言，以从源头防止开发者引入缺陷。

## Rust

Rust是一种新型语言。若将C语言视为可移植的汇编语言，那么Rust便是安全的C语言。Rust语言的设计旨在赋能开发者构建可靠高效的软件。它提供了

1) 性能：Rust运行速度极快且内存效率高。它没有运行时环境或垃圾回收机制。它能够驱动性能关键型服务并在嵌入式设备上运行。运行时性能和运行时内存消耗对固件至关重要，因为典型的固件运行在资源受限的环境中。即便在英特尔架构（IA）系统固件中，代码也需在系统管理模式（SMM）下运行，该模式仅配备有限的系统管理内存（SMRAM），例如1MB或8MB。嵌入式设备同样面临类似限制。Rust嵌入式版本提供灵活的内存管理方案，动态内存分配可选。开发者可选择使用全局分配器与动态数据结构，或采用全静态分配方案。此设计必要性在于：固件代码可能在无DRAM的闪存设备上运行。
2) 可靠性：Rust引入了丰富的类型系统和所有权模型，确保内存安全与线程安全，使您能在编译时消除多类错误。这或许是最具吸引力的特性。Rust并非首个引入类型安全概念的语言。类型安全语言面临的主要担忧在于运行时类型检查导致的性能下降。对于嵌入式系统或固件而言，这种性能影响难以接受。Rust的优势在于多数检查已在编译时完成。因此最终生成的二进制文件无需执行此类检查。凭借严格的语法规则，Rust能追踪数据对象的生命周期，因此无需运行时垃圾回收。这种设计不仅缩减了二进制文件大小，更显著提升了运行时性能。
3) 生产力：Rust拥有友好的编译器，能提供有用的错误信息。编译器不仅指出问题所在，还会给出修复建议。它引导你如何编写Rust语言。Rust提供了单元测试框架，你可以在函数实现后立即编写一组单元测试。Rust还通过外部函数接口（FFI）实现了与其他语言的互操作性。它能生成兼容C语言的应用程序二进制接口（ABI），支持Rust调用C语言程序，或从C语言调用Rust程序。

### Rust安全解决方案

固件开发中的主要安全问题类别包括内存安全问题和算术问题。在第15章，我们讨论了两种编译器防御策略：消除漏洞和破坏漏洞利用。Rust通过在编译时引入严格规则，在消除漏洞方面表现出色。任何违规都会导致构建失败。同时Rust为缓冲区溢出注入运行时边界检查以破坏利用。生成的代码会在运行时违规时调用panic处理程序。表20-1展示了Rust处理安全问题的解决方案。两种经典内存安全问题 ——空间安全问题与时间安全问题—— 被分别解决。让我们逐一审视这些方案。

表 20-1 Rust安全解决方案

|  类型  |  子类型  | Rust解决方案 |
| :----- | :----- | :----- |
| 访问错误（空间）| 缓冲区溢出（写）| 为切片（Slice）使用偏移/索引<br>运行时边界检查 - [panic_handler] |
|        | 缓冲区过度读取 | 为切片（Slice）使用偏移/索引<br>运行时边界检查 - [panic_handler] |
| 访问错误（时间）| 使用后释放（悬空指针）| 所有权 —— 编译时检查 |
|        | 双重释放 | 所有权 —— 编译时检查 |
| 未初始化数据 | 未初始化变量 | 初始化 —— 编译时检查 |
|        | 野指针 | 初始化 —— 编译时检查 |
|        | 空指针解引用 | 使用 Option <T>枚举<br>分配检查 —— [alloc_error_handler] |
| 算术问题 | 整型溢出 | DEBUG: 运行时检查 —— [panic_handler].<br>RELEASE: 丢弃溢出数据.<br>编译标记: -C overflow-checks=on/off.<br>函数: checked\|overflowing\|saturating\|wrapping_add\|sub\|mul\|div\|rem\|shlshr\|pow(). |
|         | 类型转换 | 必须显式指定 —— 编译时检查.<br>(Dest Size == Source Size) => no-op<br>(Dest Size < Source Size) => truncate<br>(Dest Size > Source Size) => {<br>(source is unsigned) => zero-extend<br>(source is signed) => sign-extend<br>} |

#### 所有权

Rust内存安全的核心在于隔离别名与变异。别名意味着同一数据可通过多种方式访问。数据具有共享性。变异则指所有者拥有更新数据的权限。数据可被修改。危险源于别名与变异的结合。

让我们看看清单20-1中的C程序。你能发现多少问题？

清单 20 -1

```
char *a1 = "hello world!";
char *b1 = "hello world!";
{
    int main()
    char *a2 = strdup (a1);
    char *b2 = a2;
    char *b3 = strchr (a2, 'h');
    char *b4 = strchr (a2, 'w');
    *a1 = 'k';
    *a2 = 'l';
    *(a1 + 19) = 'm';
    *(a2 + 19) = 'n';
    printf("a1=%s (%p)\n", a1, a1);
    printf("a2=%s (%p)\n", a2, a2);
    printf("b1=%s (%p)\n", b1, b1);
    printf("b2=%s (%p)\n", b2, b2);
    printf("b3=%s (%p)\n", b3, b3);
    printf("b4=%s (%p)\n", b4, b4);
    free (a1);
    free (a2);
    free (b1);
    free (b2);
    free (b3);
    free (b4);
    printf("OK\n");
    return 0;
}
```

该程序的内存布局如图20-1所示。a1和b1均位于全局数据段。它们指向只读数据段中的字符串“hello world!”。启用优化时，a1和b1指向相同位置；若关闭优化，a1和b1则指向不同位置。a2、b2、b3和b4位于栈区。其中a2、b2和b3指向堆区中的“hello world!”字符串，而b4指向该字符串的中间位置。尽管程序更新了a1和a2指向的字符串，但b1、b2和b3指向的字符串也会被更新。这可能是副作用。更新a1还可能导致运行时崩溃，因为只读区域默认标记为受保护状态，除非程序在链接阶段将只读数据区合并到普通数据区。字符串更新还涉及对m和n的缓冲区溢出访问。最后需注意：仅需对堆内数据执行一次free操作。由于b2、b3和b4指向与a2相同的字符串，因此仅需调用free(a2)。程序注释详见清单20-2。

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-1.jpg></img></div>
<div align=center>图 20-1 清单20-1的内存布局 </div>

清单 20-2
```
char *a1 = "hello world!";
char *b1 = "hello world!";
{
    int main()
    char *a2 = strdup (a1);
    char *b2 = a2;
    char *b3 = strchr (a2, 'h');
    char *b4 = strchr (a2, 'w');
    //*a1 = 'k'; // crash in normal build. Need merge .rdata to .data section.
    // b1 update if optimization on, side effect?
    // b1 not update if optimization off
    *a2 = 'l'; // cause b2, b3 update, side effect?
    //*(a1 + 19) = 'm'; // illegal, but no crash most likely
    //*(a2 + 19) = 'n'; // illegal, crash at free() most likely
    printf("a1=%s (%p)\n", a1, a1);
    printf("a2=%s (%p)\n", a2, a2);
    printf("b1=%s (%p)\n", b1, b1);
    printf("b2=%s (%p)\n", b2, b2);
    printf("b3=%s (%p)\n", b3, b3);
    printf("b4=%s (%p)\n", b4, b4);
    //free (a1); // illegal, crash
    free (a2); // legal, required otherwise memory leak
    //free (b1); // illegal, crash
    //free (b2); // maybe legal, only if a2 is not freed.
    //free (b3); // illegal, but works, if a2 is not freed
    //free (b4); // illegal, crash
    printf("OK\n");
    return 0;
}
```

清单20-1的程序能够成功编译，是因为C编译器不会执行此类检查。它依赖开发者正确编写代码。而在Rust中，你无法以这种方式编写代码。如果数据是可变的，就不能共享；反之，如果数据被共享，就必须是可变的。Rust有三种基础编程模式：所有权、共享借用和可变借用。让我们逐一解析。

首先，图20-2展示了所有权的概念。在清单20-3中，我们初始化字符串s1，将s1赋值给s2，随后又将s1赋值给s3。这在C语言中合法，但在Rust中非法。原因在于：当s1被赋值给s2时，字符串“hello world!”的所有权从s1转移至s2，s1随即失效。因此，当代码试图将s1赋值给s3时，编译器会在清单20-4中报错。若需同时使用s2和s1该如何处理？此时需借助借用机制（亦称引用）。

清单 20-3

```
fn test1() {
    // ownership
    let s1 = String::from ("hello world!");
    let mut s2 = s1;
    let mut s3 = s1; // error because the ownership is moved to s2
    s2.make_ascii_lowercase();
    println!("s1={}", s1);
    println!("s2={}", s2);
    println!("s3={}", s3);
}
```

清单 20-4

```
error[E0382]: use of moved value: `s1`
--> src\main.rs:6:14
|
4 | let s1 = String::from ("hello world!");
| -- move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
5 | let mut s2 = s1;
| -- value moved here
6 | let mut s3 = s1; // error because the ownership is moved to s2
| ^^ value used here after move
```

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-2.jpg></img></div>
<div align=center>图 20-2 Rust中的所有权 </div>

其次，图20-3展示了共享借用的概念。在清单20-5中，我们初始化s1，并将s1作为引用赋值给s2和s3，这没有问题。然而，如果想更新s2引用的字符串，编译器会如清单20-6中报错，因为s2和s3都是不可变借用。如果想要更新s2？必须使用可变借用。

清单 20-5

```
fn test2() {
    // immutable borrow
    let s1 = String::from ("hello world!");
    let s2 = &s1;
    let s3 = &s1;
    s2.make_ascii_lowercase(); // error because s2 is immutable borrow.
    println!("s1={}", s1);
    println!("s2={}", s2);
    println!("s3={}", s3);
}
```

清单 20-6

```
error[E0596]: cannot borrow `*s2` as mutable, as it is behind a `&` reference
    --> src\main.rs:18:5
   |
17 | let s2 = &s1;
   |    --- help: consider changing this to be a mutable
17 | let s3 = &s1;reference: `&mut s1`
19 | s2.make_ascii_lowercase(); // error because s2 is immutable
        borrow.
   | ^^ `s2` is a `&` reference, so the data it refers to cannot be
        borrowed as mutable
```

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-3.jpg></img></div>
<div align=center>图 20-3 Rust中的共享借用 </div>

第三，图20-4展示了可变借用的概念。在清单20-7中，我们初始化s1，并将s1作为可变引用赋值给s2和s3，因为后续需要更新s2。然而当尝试将s1作为可变引用赋值给s3时，编译器会如清单20-8中报错，因为s3已成为第二个可变借用，这种情况是不合法的。Rust语言中最多只允许一次可变借用。

清单 20-7

```
fn test3() {
    // mutable borrow
    let mut s1 = String::from ("hello world!");
    let s2 = &mut s1;
    let s3 = &mut s1; // error because this is second mutable borrow.
    s2.make_ascii_lowercase();
    println!("s1={}", s1);
    println!("s2={}", s2);
    println!("s3={}", s3);
}
```

清单 20-8

```
error[E0499]: cannot borrow `s1` as mutable more than once at a time
    --> src\main.rs:29:14
   |
29 | let s2 = &mut s1;
   |    ------- first mutable borrow occurs here
30 | let s3 = &mut s1; // error because this is second mutable borrow.
   |    ^^^^^^^ second mutable borrow occurs here
31 | s2.make_ascii_lowercase();
   |    -- first borrow later used here
```

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-4.jpg></img></div>
<div align=center>图 20-4 Rust中的可变借用 </div>

您可能还会发现这些函数中并未调用free()，因为代码本身并不需要free()。free()是由编译器注入的。清单20-9展示了编译器为清单20-3中test1()函数的入口和出口生成的二进制代码。由于开发者必须遵循严格的规则，Rust编译器能在编译时管理对象的生命周期。因此编译器会在代码中注入__rust_alloc和__rust_dealloc，而非使用运行时垃圾回收机制。编译时还能实现诸多优化，这也是Rust能高效运行的原因之一。

清单 20-9

```
0000000140001140: 55                   push     rbp
0000000140001141: 56                   push     rsi
0000000140001142: 48 81 EC A8 00 00    sub      rsp,0A8h
                  00
0000000140001149: 48 8D AC 24 80 00    lea      rbp,[rsp+80h]
                  00 00
0000000140001151: 48 C7 45 20 FE FF    mov      qword ptr [rbp+20h],
                                                0FFFFFFFFFFFFFFFEh
                  FF FF
0000000140001159: BE 0C 00 00 00       mov      esi,0Ch
000000014000115E: B9 0C 00 00 00       mov      ecx,0Ch
0000000140001163: BA 01 00 00 00       mov      edx,1
0000000140001168: E8 93 08 00 00       call     __rust_alloc
000000014000116D: 48 85 C0             test     rax,rax
0000000140001170: 0F 84 D9 00 00 00    je       000000014000124F
0000000140001176: 48 89 45 F0          mov      qword ptr [rbp-10h],rax
...
00000001400011C4: 0F 10 45 F0          movups   xmm0,xmmword ptr [rbp-10h]
00000001400011C8: 0F 29 45 A0          movaps   xmmword ptr [rbp-60h],xmm0
00000001400011CC: 0F 28 45 A0          movaps   xmm0,xmmword ptr [rbp-60h]
00000001400011D0: 0F 29 45 D0          movaps   xmmword ptr [rbp-30h],xmm0
...
0000000140001235: 48 8B 4D D0          mov      rcx,qword ptr [rbp-30h]
0000000140001239: 41 B8 01 00 00 00    mov      r8d,1
000000014000123F: E8 CC 07 00 00       call     __rust_dealloc
0000000140001244: 90                   nop
0000000140001245: 48 81 C4 A8 00 00    add      rsp,0A8h
00
000000014000124C: 5E                   pop      rsi
000000014000124D: 5D                   pop      rbp
000000014000124E: C3                   ret
```

最后，我们再看一个示例，展示Rust如何在清单20-10中捕获问题。str_find_char()函数的作用是定位字符串中某个字符的首次出现位置，类似于C语言中的strchr()。接着调用s.clear()，意味着会截断该字符串。由于str_find_char()的返回值是对原始字符串s的引用，这种截断操作会影响结果。后续的println无法输出预期内容。幸运的是，Rust编译器出色地捕获了此问题，并在清单20-11中显示了错误信息。它发现存在s的不可变引用，因此s无法获得可变借用权限来截断内容。

清单 20-10

```
fn str_find_char(s: &String, c: char) -> Option<&str> {
   let bytes = s.as_bytes();
   let len = s.len();
   for (i, &item) in bytes.iter().enumerate() {
      if item == c as u8 {
         return Some(&s[i..len]);
      }
   }
   None
}

fn test4() {
   let mut s = String::from("hello world");
   let result = str_find_char(&s, 'w');
   s.clear(); // error!
   match result {
      Some(word) => println!("found: {}", word),
      None => println!("not found"),
   }
}
```

清单 20-11

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
   --> src\main.rs:71:5
   |
69 | let result = str_find_char(&s, 'w');
   |     -- immutable borrow occurs here
70 |
71 | s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
72 |
73 | match result {
   |     ------ immutable borrow later used here
```

### Option<T> 类型

在清单20-10中，存在一种数据类型——Option<&str>。它有何用途？

C语言有空指针概念。空指针解引用会在运行时引发异常。Tony Hoare曾将空指针称为“价值十亿美元的错误”。该机制诞生于1965年，仅因其易于实现。最终却导致无数错误、漏洞和系统崩溃。

Rust通过Option<T>类型解决了NULL指针问题。其定义详见清单20-12。

```
pub enum Option<T> {
   /// No value
   None,
   /// Some value T
   Some(T)
}
```

清单20-13展示了可能存在问题的C程序。若开发者忘记在test()函数中检查NULL指针，C版本中可能发生NULL引用。这种情况在Rust中绝不会发生。清单20-14展示了Rust版本。当数据可能为空时，必须使用Option<T>类型。程序获取数据时，必须通过Some(T)从Option<T>参数中提取数据，并包含None模式处理无值情况。由此彻底消除了空指针引用的风险。

清单 20-13

```
void print_ptr_data (int *optional) {
   if (optional == NULL) { // It might be missing.
      printf ("NULL pointer\n");
   } else {
      printf ("value is %d\n", *optional);
   }
}

void test() {
   int *optional = NULL;
   print_ptr_data (optional);
   optional = malloc (sizeof(int));
   *optional = 5;
   print_ptr_data (optional);
}
```

清单 20-14

```
fn print_ptr_data (optional: Option<Box<i32>>) {
   match optional {
      Some(p) => println!("value is {}", p),
      None => println!("Value is None"),
   }
}

fn test5() {
   let optional = None;
   print_ptr_data (optional);
   let optional = Some(Box::new(5));
   print_ptr_data (optional);
}
```

### 边界检查

在C语言中，缓冲区溢出是最关键的问题之一。通常，Rust建议使用迭代器访问缓冲区。例如，清单20-10展示了str_find_char()函数使用bytes.iter().enumerate()的方式。然而，开发者仍有机会改写缓冲区数组的索引，从而犯错误。例如，在清单20-15中，str_find_char()返回Some(&s[i..len+1])，而正确形式应为Some(&s[i..len])。此处虽绕过了编译时检查，但仍可通过清单20-16中的运行时检查捕获该错误。

清单 20-15

```
fn str_find_char(s: &String, c: char) -> Option<&str> {
   let bytes = s.as_bytes();
   let len = s.len();
   for (i, &item) in bytes.iter().enumerate() {
      if item == c as u8 {
         return Some(&s[i..len+1]); // bug
      }
   }
   None
}
```

清单 20-16

```
thread 'main' panicked at 'byte index 12 is out of bounds of `hello
world`', src\libcore\str\mod.rs:2017:9
note: Run with `RUST_BACKTRACE=1` environment variable to display a
backtrace.
```

Rust编译器会在运行时为缓冲区访问插入边界检查代码。若发生越界访问，插入的检查器将调用预定义函数panic_handler()。默认的panic_handler()由标准库提供。固件通常仅链接Rust核心库，需定义自己的panic_handler()，如示例20-17所示。

```
#[panic_handler]
fn panic_handler(_info: &core::panic::PanicInfo) -> ! {
   // Add your own debug information
   loop {}
}
```

### 未初始化数据检查

Rust在编译时会消除未初始化的数据。编译器通过静态分析确保所有数据在任何路径中都必须初始化，包括像if/else语句等条件赋值情况。与C语言类似，虽然可能存在误报，但能在编译时消除任何风险更为稳妥。