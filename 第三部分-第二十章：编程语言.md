## 第二十章

# 编程语言

在本开发部分的最后一章中，我们将探讨固件开发中的语言选择。鉴于已有大量教材介绍各种编程语言本身，本文将不深入探讨语言细节，而是聚焦于固件开发中可能采用的不同语言的安全特性。

编程语言主要分为三类：机器语言、汇编语言和高级语言。如今几乎无人使用第一代机器语言——这种语言采用二进制格式0和1来表示机器代码。让我们从汇编语言开始探讨。

## 汇编语言

汇编语言是第二代编程语言。它属于低级语言，因为它使用符号替代二进制0和1来表示机器代码。汇编语言难以编写、调试、审查和维护。汇编语言中常见的问题罗列如下：
1) 非易失性寄存器访问：非易失性寄存器在函数调用过程中需被保护。例如，根据调用约定，RBX寄存器是非易失性寄存器。它应在函数入口处保存，并在函数退出时使用后恢复，或者完全避免在函数内使用。若RBX寄存器在函数内使用，但未被保护和恢复，将导致调用方与被调用方之间的契约失效。
2) 错误的栈偏移量：函数使用栈存储局部变量和函数参数。通常,这些数据可通过栈偏移量访问，例如[RBP – 0x20]或[RSP + 0x38]。其中RBP是栈基地址寄存器，RSP是栈指针寄存器。通常，RBP应该被使用，因为它一旦在函数入口处设定后就不会改变。使用RSP配合偏移量是危险的，因为RSP会受到栈PUSH和POP指令影响。数据可能通过[RSP + 0x38]正确访问，但在PUSH操作后，同一数据需通过[RSP + 0x40]访问。
3) 寄存器误用：指令集仅提供有限数量的寄存器。使用汇编语言时，程序员必须明确每个寄存器的用途。有时指令要求使用RDX寄存器，但代码却使用了另一个寄存器RAX。这是典型的复制粘贴错误。程序员从其他地方复制代码片段后，忘记更新所有相关位置。
4) 循环计数器偏移量错误：指令集包含循环计数器寄存器，例如IA指令集中的RCX。LOOP指令会导致RCX自减。类似于C语言的for循环，错误的计数器可能引发偏移量错误（OBOE），进而导致缓冲区溢出。
5) 语法混淆：汇编语言缺乏标准。不同汇编语法可能产生不同的机器码转换方式。以IA指令为例。GNU汇编器(GSA)采用AT&T语法，微软汇编器(MASM)则使用Intel语法。最大问题在于这两种语法中源操作数与目标操作数的顺序存在差异。若需将RCX寄存器值存入RAX寄存器，Intel语法应写为“MOV RAX, RCX”，AT&T语法则为“MOVQ %RCX, %RAX”。我们见过大量案例：开发者因只熟悉其中一种语法，在复制代码后转换为另一种语法时，因顺序错误导致问题。

这些汇编语言问题无法被汇编器检测到，因为汇编器只是遵循指令将其转换为机器码，而无法理解其真实意图。通常，汇编语言的使用应限制在某些特殊领域：

1) 启动代码：这是CPU通电后的第一条指令。启动代码应尽快为高级语言设置运行环境，例如为C语言设立栈。
2) 模式切换：指令集可能定义多种CPU执行模式，例如16位实模式、32位保护模式和64位长模式。不同模式间的切换需要特殊处理，例如设置控制寄存器或模式特异寄存器，并切换至不同段地址。高级语言通常不提供此类支持。
3) 异常处理程序：当系统遭遇软异常或硬件中断时，CPU将切换到异常处理程序。异常处理程序的入口通常采用汇编语言编写，因为高级语言无法处理CPU上下文的保存与恢复。
4) 设置跳转与长跳转：这是两个标准C函数。setjump()保存当前位置，longjump()则在后续跳转至该位置。由于当前位置包含CPU上下文信息，这两个函数均采用汇编语言实现。
5) 特殊指令：以IA指令集为例，其包含特殊寄存器访问指令，例如控制寄存器（CR）、特定型号寄存器（MSR）、流式（SIMD）扩展（SSE）、高级向量扩展（AVX）等，以及特殊指令，例如串行化加载操作（LFENCE）、刷新缓存行（CFLUSH）、性能优化的自旋等待循环（PAUSE）、数据进内存非临时存储（MOVNTI）等特殊指令。

建议为这些操作的抽象提供高级语言库。因此，其他代码也应调用该库来完成工作。汇编语言在这些有限领域仍具实用价值，但其使用范围应仅限于这些领域。其余部分应归属于高级语言。

## C语言

C语言自诞生于Unix操作系统以来，或许是最受欢迎且最成功的编程语言。它是高级语言，但能胜任低级任务，例如修改内存内容或修改特定地址处的内存映射I/O寄存器。在固件领域，C语言堪称最佳选择，因为固件需要直接访问硬件相关内容，例如内存或内存映射I/O寄存器，而C语言在此领域表现卓越且功能强大。借助C语言，开发者能够完全掌控机器硬件。我们认为这源于C语言的本质——它诞生于Unix操作系统的编写需求。

现在让我们从安全角度审视C语言。根据微软的研究，内存安全问题占C和C++语言安全漏洞的70%。我们在固件领域也观察到类似数据：缓冲区溢出和整数溢出导致了50%的安全问题。原因在于固件本质上也属于软件范畴。固件同样存在类似的内存安全问题，包括内存访问错误，例如缓冲区溢出、释放后使用，以及未初始化数据错误，例如野指针、空指针引用等。

在第14章，我们探讨了C语言编程的最佳实践与规范。在第15章，我们阐述了C编译器的防御性技术。在第16章，我们则聚焦于固件内核增强方案。一方面，整个行业已提供应对这些缺陷的指导与工具；另一方面，人们也在寻求更优的类型安全语言，以从源头防止开发者引入缺陷。

## Rust

Rust是一种新型语言。若将C语言视为可移植的汇编语言，那么Rust便是安全的C语言。Rust语言的设计旨在赋能开发者构建可靠高效的软件。它提供了

1) 性能：Rust运行速度极快且内存效率高。它没有运行时环境或垃圾回收机制。它能够驱动性能关键型服务并在嵌入式设备上运行。运行时性能和运行时内存消耗对固件至关重要，因为典型的固件运行在资源受限的环境中。即便在英特尔架构（IA）系统固件中，代码也需在系统管理模式（SMM）下运行，该模式仅配备有限的系统管理内存（SMRAM），例如1MB或8MB。嵌入式设备同样面临类似限制。Rust嵌入式版本提供灵活的内存管理方案，动态内存分配可选。开发者可选择使用全局分配器与动态数据结构，或采用全静态分配方案。此设计必要性在于：固件代码可能在无DRAM的闪存设备上运行。
2) 可靠性：Rust引入了丰富的类型系统和所有权模型，确保内存安全与线程安全，使您能在编译时消除多类错误。这或许是最具吸引力的特性。Rust并非首个引入类型安全概念的语言。类型安全语言面临的主要担忧在于运行时类型检查导致的性能下降。对于嵌入式系统或固件而言，这种性能影响难以接受。Rust的优势在于多数检查已在编译时完成。因此最终生成的二进制文件无需执行此类检查。凭借严格的语法规则，Rust能追踪数据对象的生命周期，因此无需运行时垃圾回收。这种设计不仅缩减了二进制文件大小，更显著提升了运行时性能。
3) 生产力：Rust拥有友好的编译器，能提供有用的错误信息。编译器不仅指出问题所在，还会给出修复建议。它引导你如何编写Rust语言。Rust提供了单元测试框架，你可以在函数实现后立即编写一组单元测试。Rust还通过外部函数接口（FFI）实现了与其他语言的互操作性。它能生成兼容C语言的应用程序二进制接口（ABI），支持Rust调用C语言程序，或从C语言调用Rust程序。

### Rust安全解决方案

固件开发中的主要安全问题类别包括内存安全问题和算术问题。在第15章，我们讨论了两种编译器防御策略：消除漏洞和破坏漏洞利用。Rust通过在编译时引入严格规则，在消除漏洞方面表现出色。任何违规都会导致构建失败。同时Rust为缓冲区溢出注入运行时边界检查以破坏利用。生成的代码会在运行时违规时调用panic处理程序。表20-1展示了Rust处理安全问题的解决方案。两种经典内存安全问题 ——空间安全问题与时间安全问题—— 被分别解决。让我们逐一审视这些方案。

表 20-1 Rust安全解决方案

|  类型  |  子类型  | Rust解决方案 |
| :----- | :----- | :----- |
| 访问错误（空间）| 缓冲区溢出（写）| 为切片（Slice）使用偏移/索引<br>运行时边界检查 - [panic_handler] |
|        | 缓冲区过度读取 | 为切片（Slice）使用偏移/索引<br>运行时边界检查 - [panic_handler] |
| 访问错误（时间）| 使用后释放（悬空指针）| 所有权 —— 编译时检查 |
|        | 双重释放 | 所有权 —— 编译时检查 |
| 未初始化数据 | 未初始化变量 | 初始化 —— 编译时检查 |
|        | 野指针 | 初始化 —— 编译时检查 |
|        | 空指针解引用 | 使用 Option <T>枚举<br>分配检查 —— [alloc_error_handler] |
| 算术问题 | 整型溢出 | DEBUG: 运行时检查 —— [panic_handler].<br>RELEASE: 丢弃溢出数据.<br>编译标记: -C overflow-checks=on/off.<br>函数: checked\|overflowing\|saturating\|wrapping_add\|sub\|mul\|div\|rem\|shlshr\|pow(). |
|         | 类型转换 | 必须显式指定 —— 编译时检查.<br>(Dest Size == Source Size) => no-op<br>(Dest Size < Source Size) => truncate<br>(Dest Size > Source Size) => {<br>(source is unsigned) => zero-extend<br>(source is signed) => sign-extend<br>} |

#### 所有权

Rust内存安全的核心在于隔离别名与变异。别名意味着同一数据可通过多种方式访问。数据具有共享性。变异则指所有者拥有更新数据的权限。数据可被修改。危险源于别名与变异的结合。

让我们看看清单20-1中的C程序。你能发现多少问题？

清单 20 -1

```
char *a1 = "hello world!";
char *b1 = "hello world!";
{
    int main()
    char *a2 = strdup (a1);
    char *b2 = a2;
    char *b3 = strchr (a2, 'h');
    char *b4 = strchr (a2, 'w');
    *a1 = 'k';
    *a2 = 'l';
    *(a1 + 19) = 'm';
    *(a2 + 19) = 'n';
    printf("a1=%s (%p)\n", a1, a1);
    printf("a2=%s (%p)\n", a2, a2);
    printf("b1=%s (%p)\n", b1, b1);
    printf("b2=%s (%p)\n", b2, b2);
    printf("b3=%s (%p)\n", b3, b3);
    printf("b4=%s (%p)\n", b4, b4);
    free (a1);
    free (a2);
    free (b1);
    free (b2);
    free (b3);
    free (b4);
    printf("OK\n");
    return 0;
}
```

该程序的内存布局如图20-1所示。a1和b1均位于全局数据段。它们指向只读数据段中的字符串“hello world!”。启用优化时，a1和b1指向相同位置；若关闭优化，a1和b1则指向不同位置。a2、b2、b3和b4位于栈区。其中a2、b2和b3指向堆区中的“hello world!”字符串，而b4指向该字符串的中间位置。尽管程序更新了a1和a2指向的字符串，但b1、b2和b3指向的字符串也会被更新。这可能是副作用。更新a1还可能导致运行时崩溃，因为只读区域默认标记为受保护状态，除非程序在链接阶段将只读数据区合并到普通数据区。字符串更新还涉及对m和n的缓冲区溢出访问。最后需注意：仅需对堆内数据执行一次free操作。由于b2、b3和b4指向与a2相同的字符串，因此仅需调用free(a2)。程序注释详见清单20-2。

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-1.jpg></img></div>
<div align=center>图 20-1 清单20-1的内存布局 </div>

清单 20-2
```
char *a1 = "hello world!";
char *b1 = "hello world!";
{
    int main()
    char *a2 = strdup (a1);
    char *b2 = a2;
    char *b3 = strchr (a2, 'h');
    char *b4 = strchr (a2, 'w');
    //*a1 = 'k'; // crash in normal build. Need merge .rdata to .data section.
    // b1 update if optimization on, side effect?
    // b1 not update if optimization off
    *a2 = 'l'; // cause b2, b3 update, side effect?
    //*(a1 + 19) = 'm'; // illegal, but no crash most likely
    //*(a2 + 19) = 'n'; // illegal, crash at free() most likely
    printf("a1=%s (%p)\n", a1, a1);
    printf("a2=%s (%p)\n", a2, a2);
    printf("b1=%s (%p)\n", b1, b1);
    printf("b2=%s (%p)\n", b2, b2);
    printf("b3=%s (%p)\n", b3, b3);
    printf("b4=%s (%p)\n", b4, b4);
    //free (a1); // illegal, crash
    free (a2); // legal, required otherwise memory leak
    //free (b1); // illegal, crash
    //free (b2); // maybe legal, only if a2 is not freed.
    //free (b3); // illegal, but works, if a2 is not freed
    //free (b4); // illegal, crash
    printf("OK\n");
    return 0;
}
```

清单20-1的程序能够成功编译，是因为C编译器不会执行此类检查。它依赖开发者正确编写代码。而在Rust中，你无法以这种方式编写代码。如果数据是可变的，就不能共享；反之，如果数据被共享，就必须是可变的。Rust有三种基础编程模式：所有权、共享借用和可变借用。让我们逐一解析。

首先，图20-2展示了所有权的概念。在清单20-3中，我们初始化字符串s1，将s1赋值给s2，随后又将s1赋值给s3。这在C语言中合法，但在Rust中非法。原因在于：当s1被赋值给s2时，字符串“hello world!”的所有权从s1转移至s2，s1随即失效。因此，当代码试图将s1赋值给s3时，编译器会在清单20-4中报错。若需同时使用s2和s1该如何处理？此时需借助借用机制（亦称引用）。

清单 20-3

```
fn test1() {
    // ownership
    let s1 = String::from ("hello world!");
    let mut s2 = s1;
    let mut s3 = s1; // error because the ownership is moved to s2
    s2.make_ascii_lowercase();
    println!("s1={}", s1);
    println!("s2={}", s2);
    println!("s3={}", s3);
}
```

清单 20-4

```
error[E0382]: use of moved value: `s1`
--> src\main.rs:6:14
|
4 | let s1 = String::from ("hello world!");
| -- move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
5 | let mut s2 = s1;
| -- value moved here
6 | let mut s3 = s1; // error because the ownership is moved to s2
| ^^ value used here after move
```

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-2.jpg></img></div>
<div align=center>图 20-2 Rust中的所有权 </div>

其次，图20-3展示了共享借用的概念。在清单20-5中，我们初始化s1，并将s1作为引用赋值给s2和s3，这没有问题。然而，如果想更新s2引用的字符串，编译器会如清单20-6中报错，因为s2和s3都是不可变借用。如果想要更新s2？必须使用可变借用。

清单 20-5

```
fn test2() {
    // immutable borrow
    let s1 = String::from ("hello world!");
    let s2 = &s1;
    let s3 = &s1;
    s2.make_ascii_lowercase(); // error because s2 is immutable borrow.
    println!("s1={}", s1);
    println!("s2={}", s2);
    println!("s3={}", s3);
}
```

清单 20-6

```
error[E0596]: cannot borrow `*s2` as mutable, as it is behind a `&` reference
    --> src\main.rs:18:5
   |
17 | let s2 = &s1;
   |    --- help: consider changing this to be a mutable
17 | let s3 = &s1;reference: `&mut s1`
19 | s2.make_ascii_lowercase(); // error because s2 is immutable
        borrow.
   | ^^ `s2` is a `&` reference, so the data it refers to cannot be
        borrowed as mutable
```

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-3.jpg></img></div>
<div align=center>图 20-3 Rust中的共享借用 </div>

第三，图20-4展示了可变借用的概念。在清单20-7中，我们初始化s1，并将s1作为可变引用赋值给s2和s3，因为后续需要更新s2。然而当尝试将s1作为可变引用赋值给s3时，编译器会如清单20-8中报错，因为s3已成为第二个可变借用，这种情况是不合法的。Rust语言中最多只允许一次可变借用。

清单 20-7

```
fn test3() {
    // mutable borrow
    let mut s1 = String::from ("hello world!");
    let s2 = &mut s1;
    let s3 = &mut s1; // error because this is second mutable borrow.
    s2.make_ascii_lowercase();
    println!("s1={}", s1);
    println!("s2={}", s2);
    println!("s3={}", s3);
}
```

清单 20-8

```
error[E0499]: cannot borrow `s1` as mutable more than once at a time
    --> src\main.rs:29:14
   |
29 | let s2 = &mut s1;
   |    ------- first mutable borrow occurs here
30 | let s3 = &mut s1; // error because this is second mutable borrow.
   |    ^^^^^^^ second mutable borrow occurs here
31 | s2.make_ascii_lowercase();
   |    -- first borrow later used here
```

<div align=center><img src=Figures/Chapter-20-Screenshot/Figure-20-4.jpg></img></div>
<div align=center>图 20-4 Rust中的可变借用 </div>

您可能还会发现这些函数中并未调用free()，因为代码本身并不需要free()。free()是由编译器注入的。清单20-9展示了编译器为清单20-3中test1()函数的入口和出口生成的二进制代码。由于开发者必须遵循严格的规则，Rust编译器能在编译时管理对象的生命周期。因此编译器会在代码中注入__rust_alloc和__rust_dealloc，而非使用运行时垃圾回收机制。编译时还能实现诸多优化，这也是Rust能高效运行的原因之一。

清单 20-9

```
0000000140001140: 55                   push     rbp
0000000140001141: 56                   push     rsi
0000000140001142: 48 81 EC A8 00 00    sub      rsp,0A8h
                  00
0000000140001149: 48 8D AC 24 80 00    lea      rbp,[rsp+80h]
                  00 00
0000000140001151: 48 C7 45 20 FE FF    mov      qword ptr [rbp+20h],
                                                0FFFFFFFFFFFFFFFEh
                  FF FF
0000000140001159: BE 0C 00 00 00       mov      esi,0Ch
000000014000115E: B9 0C 00 00 00       mov      ecx,0Ch
0000000140001163: BA 01 00 00 00       mov      edx,1
0000000140001168: E8 93 08 00 00       call     __rust_alloc
000000014000116D: 48 85 C0             test     rax,rax
0000000140001170: 0F 84 D9 00 00 00    je       000000014000124F
0000000140001176: 48 89 45 F0          mov      qword ptr [rbp-10h],rax
...
00000001400011C4: 0F 10 45 F0          movups   xmm0,xmmword ptr [rbp-10h]
00000001400011C8: 0F 29 45 A0          movaps   xmmword ptr [rbp-60h],xmm0
00000001400011CC: 0F 28 45 A0          movaps   xmm0,xmmword ptr [rbp-60h]
00000001400011D0: 0F 29 45 D0          movaps   xmmword ptr [rbp-30h],xmm0
...
0000000140001235: 48 8B 4D D0          mov      rcx,qword ptr [rbp-30h]
0000000140001239: 41 B8 01 00 00 00    mov      r8d,1
000000014000123F: E8 CC 07 00 00       call     __rust_dealloc
0000000140001244: 90                   nop
0000000140001245: 48 81 C4 A8 00 00    add      rsp,0A8h
00
000000014000124C: 5E                   pop      rsi
000000014000124D: 5D                   pop      rbp
000000014000124E: C3                   ret
```

最后，我们再看一个示例，展示Rust如何在清单20-10中捕获问题。str_find_char()函数的作用是定位字符串中某个字符的首次出现位置，类似于C语言中的strchr()。接着调用s.clear()，意味着会截断该字符串。由于str_find_char()的返回值是对原始字符串s的引用，这种截断操作会影响结果。后续的println无法输出预期内容。幸运的是，Rust编译器出色地捕获了此问题，并在清单20-11中显示了错误信息。它发现存在s的不可变引用，因此s无法获得可变借用权限来截断内容。

清单 20-10

```
fn str_find_char(s: &String, c: char) -> Option<&str> {
   let bytes = s.as_bytes();
   let len = s.len();
   for (i, &item) in bytes.iter().enumerate() {
      if item == c as u8 {
         return Some(&s[i..len]);
      }
   }
   None
}

fn test4() {
   let mut s = String::from("hello world");
   let result = str_find_char(&s, 'w');
   s.clear(); // error!
   match result {
      Some(word) => println!("found: {}", word),
      None => println!("not found"),
   }
}
```

清单 20-11

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
   --> src\main.rs:71:5
   |
69 | let result = str_find_char(&s, 'w');
   |     -- immutable borrow occurs here
70 |
71 | s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
72 |
73 | match result {
   |     ------ immutable borrow later used here
```

#### Option<T> 类型

在清单20-10中，存在一种数据类型——Option<&str>。它有何用途？

C语言有空指针概念。空指针解引用会在运行时引发异常。Tony Hoare曾将空指针称为“价值十亿美元的错误”。该机制诞生于1965年，仅因其易于实现。最终却导致无数错误、漏洞和系统崩溃。

Rust通过Option<T>类型解决了NULL指针问题。其定义详见清单20-12。

```
pub enum Option<T> {
   /// No value
   None,
   /// Some value T
   Some(T)
}
```

清单20-13展示了可能存在问题的C程序。若开发者忘记在test()函数中检查NULL指针，C版本中可能发生NULL引用。这种情况在Rust中绝不会发生。清单20-14展示了Rust版本。当数据可能为空时，必须使用Option<T>类型。程序获取数据时，必须通过Some(T)从Option<T>参数中提取数据，并包含None模式处理无值情况。由此彻底消除了空指针引用的风险。

清单 20-13

```
void print_ptr_data (int *optional) {
   if (optional == NULL) { // It might be missing.
      printf ("NULL pointer\n");
   } else {
      printf ("value is %d\n", *optional);
   }
}

void test() {
   int *optional = NULL;
   print_ptr_data (optional);
   optional = malloc (sizeof(int));
   *optional = 5;
   print_ptr_data (optional);
}
```

清单 20-14

```
fn print_ptr_data (optional: Option<Box<i32>>) {
   match optional {
      Some(p) => println!("value is {}", p),
      None => println!("Value is None"),
   }
}

fn test5() {
   let optional = None;
   print_ptr_data (optional);
   let optional = Some(Box::new(5));
   print_ptr_data (optional);
}
```

#### 边界检查

在C语言中，缓冲区溢出是最关键的问题之一。通常，Rust建议使用迭代器访问缓冲区。例如，清单20-10展示了str_find_char()函数使用bytes.iter().enumerate()的方式。然而，开发者仍有机会改写缓冲区数组的索引，从而犯错误。例如，在清单20-15中，str_find_char()返回Some(&s[i..len+1])，而正确形式应为Some(&s[i..len])。此处虽绕过了编译时检查，但仍可通过清单20-16中的运行时检查捕获该错误。

清单 20-15

```
fn str_find_char(s: &String, c: char) -> Option<&str> {
   let bytes = s.as_bytes();
   let len = s.len();
   for (i, &item) in bytes.iter().enumerate() {
      if item == c as u8 {
         return Some(&s[i..len+1]); // bug
      }
   }
   None
}
```

清单 20-16

```
thread 'main' panicked at 'byte index 12 is out of bounds of `hello
world`', src\libcore\str\mod.rs:2017:9
note: Run with `RUST_BACKTRACE=1` environment variable to display a
backtrace.
```

Rust编译器会在运行时为缓冲区访问插入边界检查代码。若发生越界访问，插入的检查器将调用预定义函数panic_handler()。默认的panic_handler()由标准库提供。固件通常仅链接Rust核心库，需定义自己的panic_handler()，如示例20-17所示。

```
#[panic_handler]
fn panic_handler(_info: &core::panic::PanicInfo) -> ! {
   // Add your own debug information
   loop {}
}
```

#### 未初始化数据检查

Rust在编译时会消除未初始化的数据。编译器通过静态分析确保所有数据在任何路径中都必须初始化，包括像if/else语句等条件赋值情况。与C语言类似，虽然可能存在误报，但能在编译时消除任何风险更为稳妥。

#### 算术检查

在C语言中，整数溢出是另一个大问题。在许多情况下，它会导致后续的缓冲区溢出。Rust在数学运算方面做了一些改进。以清单20-18为例，它展示了五种不同的方法来获取两个u32整数相乘的结果。

```
fn test6(a: u32, b:u32) {
   let c : Option<u32> = a.checked_mul(b);
   match c {
      Some(v) => println!("checked multiple: {}", v),
      None => println!("checked multiple: overflow"),
   }

   let (c, o) : (u32, bool) = a.overflowing_mul(b);
   println!("overflowing multiple: {}, overflow: {}", c, o);
   let c : u32 = a.saturating_mul(b);
   println!("saturating multiple: {}", c);
   let c : u32 = a.wrapping_mul(b);
   println!("wrapping multiple: {}", c);
   let c : u32 = a * b;
   println!("direct multiple: {}", c);
}
fn main() {
   test6(0xFFFFFFFF, 0xFFFFFFFF);
}
```

Rust为原始类型提供了一组方法：
1) checked_mul()：结果为Option<T>。若未发生溢出，则结果为Some<T>；否则结果为None。
2) overflowing_mul()：结果为tuple(T, bool)。第一个元素是包装后的结果，第二个元素是布尔值，用于指示是否发生溢出。
3) saturating_mul()：返回值为T类型，表示饱和值。
4) wrapping_mul()：返回值为T类型，表示包装值。

对于乘法运算符，Rust编译器在发布构建中将其视为wrapping_mul()，但在调试构建中注入运行时检查代码。若在运行时发生违规，检查器将在调试构建中调用panic_handler。开发者也可通过编译器标志“-C overflow-checks=on/off”控制运行时溢出检查的启用或关闭。见表20-2。

表 20-2 Rust数学操作 - a:u32 * b:u32

|  方法  |  溢出结果  |
| :----- | :----- |
| c: Option<u32> = a.checked_mul(b) | c是None |
| (c, o) : (u32, bool) = a.overflowing_mul(b) | c存储包装后的值。o表示是否发生溢出。|
| c : u32 = a.saturating_mul(b) | c存储最大的u32值。|
| c : u32 = a.wrapping_mul(b) | c存储包装后的值。|
| c = a * b | c在发布构建中存储的包装值。<br>在调试构建中运行时溢出检查失效。|

在发布构建中，清单20-18的结果如清单20-19所示。在调试构建中，结果如清单20-20所示。

清单 20-19

```
checked multiple: overflow
overflowing multiple: 1, overflow: true
saturating multiple: 4294967295
wrapping multiple: 1
direct multiple: 1
```

清单 20-20

```
checked multiple: overflow
overflowing multiple: 1, overflow: true
saturating multiple: 4294967295
wrapping multiple: 1
thread 'main' panicked at 'attempt to multiply with overflow', src\main.
rs:90:19
note: Run with `RUST_BACKTRACE=1` environment variable to display a
backtrace.
```

固件实现可能包含外部输入，例如位图（BMP）文件、胶囊文件、可移植可执行（PE）镜像、文件系统等。若解析器需执行数学运算，使用检查版本方法比直接乘法更优，可确保溢出情况得到妥善处理。

除了数学运算外，类型转换也可能引发数据截断问题。Rust通过编译时检查强制要求显式进行数据类型转换。

总而言之，Rust对对象及其引用的使用制定了极为严格的规则以消除内存安全隐患。这正是许多开发者难以通过编译的原因之一，尤其是那些习惯C语言，并对C语言的自由度感到满意的开发者。在C语言中，开发者能掌控一切，但也意味着开发者必须确保代码不存在内存安全隐患。Rust则采取截然不同的策略：它刻意让初次编写的代码难以通过编译。编译器会持续提示禁用操作及潜在风险。但一旦代码通过编译，Rust语言便能保证其绝对不存在内存安全问题。

### 不安全代码

迄今为止，我们探讨了Rust带来的诸多安全解决方案，这些方案有助于降低固件开发中的安全风险。然而该方案存在某些局限性。例如，访问NULL地址实际上是合法的，因为传统基本输入输出系统（BIOS）将中断向量表设置在此处。有时，固件代码需要访问映射到固定内存区域的I/O设备，例如位于物理地址0xFED40000的可信平台模块（TPM）。为处理此类场景，Rust引入了unsafe关键字。当代码位于unsafe代码块内时，编译器将不执行任何安全检查。这相当于开发者与编译器之间的契约。Unsafe意味着开发者向Rust编译器宣告：“请信任我。”

根据Rust语言手册，我们可以执行以下高危操作：
• 解引用原始指针
• 调用不安全函数或方法
• 访问或修改可变全局静态变量
• 实现不安全特质
• 访问联合体的字段

在清单20-10和清单20-14中，我们演示了字符串类型和Box<T>类型。这些是Rust定义的类型。它们可用于指向堆中的数据。然而，这些类型在C语言中不可用。为实现与C语言的互操作，Rust必须定义原始指针以兼容C语言中的指针。程序片段20-21展示了原始指针的使用方式。*mut u32表示u32类型指针并且内容可变。由于该代码意图解引用原始指针，必须被包含在unsafe代码块内。这儿，Rust语言不提供任何内存安全保证。在运行时，这可能正常工作，因为开发者可能希望写入IVT；也可能因错误导致崩溃。

清单 20-21

```
fn test7() {
   unsafe {
      let p = 0 as *mut u32;
      *p = 4;
   }
}
```

调用外部函数，例如C函数，也被视为不安全，因为Rust对外部函数没有控制权。示例20-22展示了Rust如何调用C语言的abs()函数。

清单 20-22

```
extern "C" {
   fn abs(a: i32) -> i32;
}

fn test8(a: i32) -> i32 {
   unsafe {
      abs (a)
   }
}
```

全局静态变量被视为可由多个函数共享。根据别名/变异规则，它应为不可变。然而，某些情况下我们确实需要修改全局静态变量，例如全局计数器。通常可变静态变量用于与C语言的交互。危险之处在于Rust要求使用unsafe关键字。示例代码见清单20-23。

清单 20-23

```
static mut COUNTER: u32 = 0;
fn increment_counter() {
   unsafe {
      COUNTER += 1;
   }
}
fn test9() {
   increment_counter();
   unsafe {
      println!("COUNTER: {}", COUNTER);
   }
}
```

Rust支持联合类型，其设计初衷同样是为了与C语言互操作。联合类型存在风险，因为其数据类型具有不确定性。这种特性违反了类型安全原则，可能引发问题，例如部分初始化。见清单20-24，该示例在运行时会输出垃圾数据。

清单 20-24

```
#[repr(C)]
union U {
   d8 : u8,
   d32: u32,
}

fn test10() {
   let dataU = U { d8 : 1 };
   unsafe {
      let data32 = dataU.d32;
      println!("get data {}", data32);
   }
}
```

### 当前的项目

Rust仍是一门年轻的语言。它由Mozilla的Graydon Hoare设计，首次发布于2014年。凭借其安全特性，越来越多的项目开始采用Rust。例如，c2rust工具可帮助将C语言代码转换为Rust的unsafe版本。然后开发者可对unsafe版本进行重构，最终转化为安全版本。Mozilla正将Rust应用于Firefox。Amazon Firecracker是基于Rust的虚拟机监控程序。百度为安全飞地发布了Rust-SGX-SDK，以及作为MesaTEE框架一部分的Rust OP-TEE TrustZone SDK。Facebook采用Rust开发Libra —— 去中心化的金融基础设施。谷歌Fuchsia系统的部分组件使用Rust实现。OpenTitan硬件信任根采用Rust编写的Tock操作系统。OpenSK —— 一款用Rust开发的FIDO2认证器，作为Tock操作系统的应用。2019年，微软宣布将采用Rust作为系统编程语言。2020年，微软开源Verona项目，这是受Rust启发的新型安全基础设施编程研究语言。

固件项目正逐步采用Rust语言。基于Rust的虚拟机监控程序固件可启动云端虚拟机监控程序。oreboot是coreboot的下游分支 —— 一个不含C语言的coreboot实现。EDK II也新增了在完整UEFI固件中构建Rust模块的支持。

加密算法也正在使用Rust持续开发，例如RustCrypto、MesaLink、rusttls、ring、webpki等。rusttls项目包含Cure53的安全审查与审计报告，彰显其代码的高品质。期待未来这些项目能取代OpenSSL或mbed TLS。目前ring/webpki依赖操作系统提供的随机数生成机制。为了在固件中使用ring/webpki，我们需要基于固件的随机数库。例如，efi-random crate在UEFI/EDK II环境中使用RDRAND和RDSEED指令实现随机数生成。

### 限制

Rust为消除固件中的内存安全问题带来了重大改进，但仍有一些与语言无关的固件安全问题需要处理，例如：
1) 硅寄存器锁定：需要使用漏洞扫描工具，例如CHIPSEC。
2) 安全策略：需要执行策略检查以确保固件配置正确。
3) 检查时/使用时（TOC/TOU）问题：需要仔细执行架构审查与设计审查。
4) X86系统管理模式（SMM）调用：需要硬件限制措施，例如SMM_CODE_CHECK特性。

最后但同样重要的是，Rust中的不安全代码始终存在风险。百度Rust-SGX-SDK项目总结了Rust不安全代码的规则：
• 不安全组件应适当隔离和模块化，且规模应保持较小（或最小化）。
• 不安全组件不应削弱安全性，特别是公共API和数据结构。
• 不安全组件应明确标识且易于升级。

在Rust中编写不安全的代码与编写C代码一样。Rust本身不提供任何安全保证。请将这类代码隔离、尽量减少其使用，并仔细审查。

## 其他

固件项目中也使用其他语言。例如，Forth是IEEE 1275-1994标准定义的语言。它用于开源固件项目。一些嵌入式设备采用Java Embedded、MicroPython或.NET Compact Framework。这些语言需要运行时解释器。它们可作为应用程序语言的良好选择，但难以作为固件开发的系统语言。我们也注意到其他类型安全语言，如Ada或OCaml，也应用于嵌入式系统，例如Mirage操作系统，但尚未广泛使用。