## 第六章

# 操作系统弹性

在个人电脑或服务器中，当主机固件完成初始启动时，它会将控制权转交给主机操作系统（OS）加载程序。然后，主机操作系统加载程序将控制权转移到最终操作系统（OS）。操作系统可能由制造商、企业信息技术（IT）部门或最终用户安装。典型的操作系统是Windows或Linux。对于移动设备，可能还有其他类型的通用操作系统，如Chromium、Android或iOS。它们由平台制造商创建或定制，作为整个移动设备解决方案的一部分。在嵌入式系统或微控制器中，操作系统与固件紧密结合，甚至是固件的一部分。其中一些解决方案包括实时操作系统（RTOS），例如FreeRTOS、RT-Thread、Contiki OS、mbed OS、ThreadX、uC/OS、LiteOS、TinyOS等。

由于操作系统是提供真正服务的环境，操作系统是攻击的主要目标。如果个人电脑中的Windows或Linux操作系统实例受到攻击，最终用户可能需要重新安装新的操作系统。但是，如果手机中的Android或iOS实例受到攻击，用户又如何安装新的呢？更不用说运行在嵌入式系统中的RTOS了，最终用户根本不知道它的存在。从整个解决方案的角度来看，"弹性"的概念应从固件扩展到操作系统。

与固件弹性类似，操作系统的弹性也包括三个部分：保护、检测和恢复。由于本书聚焦于固件，我们将不介绍操作系统弹性的所有方面，而重点关注与固件相关的部分。

## 保护

### 自动更新

目前大多数商业操作系统，例如Windows、Linux、Android和iOS，都支持自动组件更新。更新服务由操作系统供应商提供，并且在后台运行。每当操作系统供应商发布新版本时，最终用户就会收到通知，补丁就会自动部署。

自动更新的好处是操作系统软件版本始终是最新的。一旦补丁可用，操作系统软件的漏洞就能立即得到修复。

## 检测

### 镜像签名

镜像签名验证是一种有效的检测机制。UEFI安全启动就是在UEFI固件中使用这一机制的解决方案之一。镜像签名验证从固件扩展到操作系统内核。一些操作系统，如Windows10会强制执行代码签名策略来确保执行代码的完整性。

### 案例研究

现在，让我们来看下操作系统/加载程序安全启动的一些实例。

#### Linux机器所有者密钥（MOK）

UEFI安全启动定义了密钥层次结构。平台密钥（PK）由平台所有者提供。这里的平台所有者通常指创建机器的平台制造商，但也可能是其他人，如最终用户。PK用于签署密钥交换密钥（KEK），该密钥由操作系统供应商提供。KEK用于签署允许的镜像数据库和禁止的镜像数据库。当前的平台通常默认启用UEFI安全启动。由于最终用户没有PK或KEK，他们无法在数据库中注册任何新镜像。对于只想使用操作系统的最终用户来说，这种设计是不错的。但在Linux世界中，开发者被视为机器的所有者。如果开发者更新了操作系统加载程序或操作系统内核，并在自己的启用了UEFI安全启动的机器上测试更新，该怎么办？

开发者可以禁用UEFI安全启动。根据Windows logo使用UEFI的要求，UEFI安全启动可在用户实际场景下禁用。UEFI规范本身未提及禁用该功能。不过，一旦UEFI安全启动被禁用，恶意软件可能会在UEFI安全启动再次启用前安装到系统上，这是一个潜在的风险。

Linux的最低安全启动要求如下： 1）操作系统加载程序必须使用固件中注册的密钥签名，并由固件验证。2）操作系统内核必须使用操作系统加载程序信任的密钥签名，并由操作系统加载程序验证。一种方法是为所有固件注册一个Linux密钥，类似于UEFI证书颁发机构（CA）和微软使用的方法，让所有其他固件注册UEFI CA/Windows密钥。但这会带来扩展性问题。

另一种方法是让UEFI证书颁发机构签署一个Linux程序作为楔子（shim）。然后，就可以使用这个楔子（shim）在Linux世界中使用已知的机器所有者密钥 (MOK)去构建一个新的密钥层次结构。表6-1列出了MOK和UEFI安全启动密钥之间的区别。

表 6-1 MOK和UEFI安全启动密钥
| **密钥** | **谁提供** | **谁注册** | **签名** | **存储** |
| :--- | :--- | :--- | :--- | :--- |
| UEFI安全启动密钥（PK）| 平台所有者 —— 平台制造商 | 平台拥有者 —— 平台制造商 | KEK | UEFI已认证变量 |
| UEFI安全启动密钥（KEK）| 操作系统供应商 —— UEFI证书颁发机构（CA），微软 | 平台拥有者 —— 平台制造商 | db/dbx | UEFI已认证变量 |
| UEFI安全启动密钥（db/dbx）| 操作系统供应商 —— UEFI证书颁发机构（CA），微软 | 平台拥有者 —— 平台制造商 | UEFI option ROM，UEFI加载程序（Windows操作系统加载程序），Linux shim | UEFI已认证变量 |
| Linux MOK | 机器所有者 —— 最终用户 | 机器所有者 —— 最终用户 | Linux操作系统加载程序， Linux操作系统内核 | UEFI启动服务变量（未认证）|

使用Linux MOK时，启动流程如图6-1所示。UEFI固件使用UEFI安全启动密钥（db）来验证Linux shim。shim可以嵌入默认的Linux密钥数据库，例如SUSE密钥。因此，Linux shim可以验证 Linux的Grub2加载程序和使用SUSE密钥签名的Linux内核。

<div align=center><img src=Figures/Chapter-6-Screenshot/Figure-6-1.jpg></img></div>
<div align=center>图 6-1 使用MOK签名验证</div>

如果Linux开发人员想创建一个新的Grub2或Linux内核，他们可以在Linux环境中创建一个机器所有者密钥（MOK），并对Grub2和Linux内核签名。用户需要使用MOK实用程序为MOK注册密码，然后重新启动系统。下一次启动时，MOK管理器会检测到更改请求，并让用户输入密码以确认MOK注册。一旦用户确认更新，MOK立即生效。Linux shim使用MOK列表来验证新的Linux Grub2和Linux内核。

Linux MOK系统的好处是它可以维护从平台到Linux内核的安全启动链，而且最终用户可以灵活地为内核开发注册安全启动密钥。

#### Chromium操作系统验证启动

安全启动的安全性也可以在非UEFI操作系统中实现。以Google Chrome浏览器为例，验证固件解决方案已扩展到Chromium操作系统验证启动。验证启动的目的是确保只有谷歌签名的Chromium操作系统能被固件加载。表6-2显示了Chromium验证启动使用的密钥。

表6-2 Chromium验证启动使用的密钥
| **密钥** | **验证** | **存储** | **版本控制** |
| :--- | :--- | :--- | :--- |
| 根密钥 | 固件数据密钥 | 只读固件（GBB）| 否 |
| 固件数据密钥 | 读写固件 | 读写固件头部（VBLOCK）| 是 |
| 内核子密钥 | 内核数据密钥 | 读写固件 | 是（作为固件）|
| 内核数据密钥 | 操作系统内核 | 操作系统内核头部 | 是 |
| 恢复密钥 | 恢复操作系统内核 | 只读固件 | 否 |

我们在第4章讨论了coreboot安全启动流程。现在让我们将它们结合在一起。固件的只读（RO）部分作为平台的信任根。只读固件包含启动块和谷歌二进制块（GBB），它包括根密钥。系统启动时，启动块代码会在GBB中找到根密钥，并使用根密钥验证读/写（RW）固件的密钥块。在固件密钥内部，存在固件数据密钥，用来验证读/写固件的前言部分。固件前言包括固件主体签名、固件版本和内核子密钥。一旦固件主体通过签名验证后，只读固件会将控制权转移到读写固件主体。然后固件主题使用内核子密钥验证内核密钥块。内核密钥块内部有一个内核数据密钥，用于验证内核前言。内核前言包括内核主体的签名、内核版本和相关引导加载程序信息。一旦内核主体通过签名验证，读写固件就会将控制权传递给内核。整个过程见图6-2。

<div align=center><img src=Figures/Chapter-6-Screenshot/Figure-6-2.jpg></img></div>
<div align=center>图 6-2 Chromium验证启动中的签名验证</div>
