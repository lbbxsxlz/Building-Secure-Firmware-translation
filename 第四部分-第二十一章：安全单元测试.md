## 第二十一章

# 安全单元测试

在完成所有代码开发工作后，我们需要进行安全测试。通常开发人员需先执行安全单元测试，再将代码交付给测试团队。此时，测试团队需开展更全面的系统级安全测试。市面上有大量介绍软件测试技术的书籍，本章将不再赘述相关内容。相反，在本章，我们将从开发人员视角聚焦固件特有的安全单元测试。在下一章，我们将从测试工程师视角探讨固件特有的系统安全测试。

## 安全单元测试计划

在第二章中，我们探讨了主动式固件安全开发的整体理念，并阐述了威胁模型。安全单元测试应聚焦于威胁模型，以验证已识别的威胁是否得到妥善缓解。我们还指出了固件中的八个高风险区域，并提供了安全代码审查的指导原则。表21-1展示了针对这些区域的安全单元测试。

表 20-1 针对8个高分线区域的安全单元测试

|  类别  |  安全单元测试  |
| :----- | :----- |
| 外部输入 | 识别外部输入 —— SMM通信缓冲区、UEFI变量、固件镜像和胶囊镜像、启动BMP文件、PE/COFF镜像（例如一个操作系统引导加载程序和PCI选项ROM）、文件系统、磁盘镜像、网络数据包等。<br>识别处理外部输入的功能 —— 边界函数。识别执行外部输入检查的功能 —— 检查函数。<br>使用不同输入测试检查函数。<br>验证检查函数的输出结果。|
| 竞争条件 | 识别关键资源 —— SMM通信缓冲区、锁定的硅寄存器等。<br>识别处理关键资源的功能。创建访问关键资源的竞争条件场景。<br>验证关键资源的结果。|
| 硬件输入 | 识别硬件输入 —— 读写硅寄存器、内存映射输入/输出（MMIO）基址寄存器（BAR）、USB描述符、蓝牙低功耗（BLE）广播数据、DMA、缓存等。<br>识别处理硬件输入的函数。<br>识别执行硬件输入检查的函数 —— 检查函数 —— 或识别预防攻击的函数 —— 锁定函数。<br>模拟硬件输入，例如MMIO BAR、USB、BLE等，并测试检查函数。<br>验证检查函数的输出结果。<br>验证锁定函数能否正确执行锁定操作，例如DMA或SMM缓存等。|
| 秘密处理 | 识别秘密/密码。<br>识别使用密钥的函数。<br>识别使用后清除密钥的函数。<br>确保所有路径中的秘密均被清除。<br>若需保存秘密，识别对其进行哈希或加密的函数。<br>识别默认秘密/密码处理机制。<br>验证是否遵循侧信道指南。|
| 寄存器锁定 | 识别需要锁定的寄存器，例如闪存锁定和SMM锁定。<br>识别锁定寄存器的函数。<br>识别控制锁定的策略，例如策略协议或变量。<br>确保最终用户无法控制策略。<br>确保锁定操作在所有启动路径中均会发生。<br>确保锁定操作在任何第三方代码运行之前完成。|
| 安全配置 | 识别控制安全配置的策略，例如安全启动和可测量启动。<br>确保未经授权的最终用户无法更新安全配置。<br>确保默认配置是安全的。|
| 重放/回滚 | 识别安全版本号（SVN）或最低支持版本号（LSN）。<br>识别SVN或LSN的存储位置。<br>确保未经授权的最终用户无法更新SVN或LSN。识别执行版本检查的函数。|
| 密码学 | 识别固件中的加密的用途，例如签名验证或数据加密。<br>识别固件中使用的加密的算法。<br>确保加密算法遵循政府和企业的最新指南，不得使用任何已弃用的算法。<br>确保密钥长度符合政府和企业的最新指南，不得使用过短的密钥长度。<br>识别密钥生成函数和密钥撤销函数。<br>识别密钥存储。<br>
识别用于保障密钥存储完整性与或保密性的保护机制。<br>仅授权用户可更新密钥。<br>验证是否遵循侧信道防护指南来保障密钥保密性。<br>确保签名验证函数能处理密钥缺失或签名缺失的情况。|

对于可能涉及多个高风险区域的解决方案，必须格外谨慎。以基于SMM的固件更新为例，固件更新镜像属于外部输入（#1）。该镜像被放入SMM通信缓冲区，可能存在潜在的检查时间/使用时间攻击（#2）。闪存更新功能需解锁闪存，这为竞争条件攻击（#2）留下了可能。SMM环境需要被保护来预防DMA或SMM缓存攻击（#3）。
启动期间应锁定闪存设备来预防未授权更新（#5）。固件更新功能需检查固件的SVN来预防回滚攻击（#7）。新固件镜像必须采用正确密钥长度的正确的加密算法进行签名（#8）。

为验证开发代码是否遵循第14章介绍的通用安全编码规范，可采用静态代码分析或动态代码分析。在第16章，我们介绍了各类编译器防御技术来消除潜在的漏洞，包括Klocwork和Coverity静态分析工具，同时阐述了地址消毒器与未定义行为消毒器。

## 高级的安全单元测试

通常，对于安全单元测试，我们可能需要编写测试函数，通过不同输入调用目标函数，以评估其运行是否正常，特别是测试目标函数处理外部输入（#1）和硬件输入（#3）的能力。这种方法最大的问题在于，我们无法确定生成的输入是否足以覆盖所有情况。

传统上，等价类分区（ECP）是消除冗余的有效方法，它将输入数据划分为合理数量的分区。此时只需设计覆盖所有分区的测试用例即可。然而，尽管ECP是必要的，但它不足以保障安全单元测试的充分性，因为ECP的前提条件我们能够定义一组覆盖所有情况的分区。对于简单函数这或许可行，但在实践中，很难对复杂数据结构定义一套完整的ECP分区集，例如文件系统，可执行文件格式或网络数据包。因此我们需要其他方法。

### 模糊测试

模糊测试，也称模糊测试法，是一种自动化测试技术。模糊测试工具能自动生成无效、意外或随机数据，作为目标函数调用的输入值。模糊测试的最大优势之一在于它使开发人员无需创建等价类分区或测试用例。然而模糊测试存在测试预言者问题 —— 测试必须能够区分预期（正常）与意外（存在缺陷）的程序行为。意外行为包括以下情况：

1) 崩溃、挂死或断言是模糊测试中简单而客观的衡量标准。若观察到这些行为，则目标函数必然存在问题。
2) 模糊测试还可能触发其他难以检测的问题，例如缓冲区越界访问、释放后使用或内存泄漏。为捕获此类故障，模糊测试通常需与其他检测工具协同使用，例如地址消毒器、未定义行为消毒器、内存消毒器或泄漏消毒器。
3) 最后同样重要的是，模糊测试可能导致程序返回意外或错误结果。因此开发者需为程序的最终结果或终态编写断言。

模糊测试是一种测试技术。它独立于执行环境，可应用于操作系统应用程序、操作系统内核甚至固件。如今，大多数模糊测试工具，例如Peach、American Fuzzy Lop（AFL）和LibFuzzer，都在操作系统环境中运行。但固件运行于特殊执行环境，并且该环境不提供操作系统级应用程序接口（API）或标准C库。这引发关键问题：如何运行模糊测试工具来检测固件代码？

表21-2列举了不同的固件模糊测试机制。

表 20-1 固件模糊测试机制

|  机制  |  作用  |  优点  |   缺点  |
| :----- | :----- | :----- | :----- |
| 1. 在固件环境中运行固件功能与模糊测试工具。| 移植模糊测试工具到固件中运行。| 不需要修改固件代码。| 移植模糊测试工具需要付出巨大努力。可能存在环境限制，例如内存大小、存储空间和CPU处理能力。|
| 2. 在固件环境中运行固件功能，在操作系统中运行模糊测试工具。| a. 创建固件代理和操作系统代理，用于通过网络对固件与操作系统之间的数据传输进行模糊测试。| 不需要修改模糊测试工具。不需要修改固件代码。| 耗费时间在模糊数据传输上。|
|        | b. 使用虚拟机监控程序实现固件功能与操作系统模糊测试工具之间的数据通信。| 比通过网络进行模糊测试的数据传输更快。| 需要启动虚拟机监控程序来运行目标固件。|
| 3. 在操作系统环境中运行固件功能和模糊测试工具。| a. 移植固件功能到操作系统，并在操作系统上执行模糊测试。| 无需修改模糊测试工具。可通过模糊测试编译器充分利用已插桩的代码。这是最快的解决方案。| 需要付出努力来为固件功能创建系统桩。|
|        | b. 分析固件二进制文件并对目标函数进行模糊测试。| 无需移植固件。| 二进制分析耗时。也需要创建桩函数。|

1) 第一种方案是将模糊测试工具从操作系统移植到固件环境，并在固件环境中运行。见图21-1。若模糊测试工具依赖操作系统API，则需实现固件版本。遗憾的是，根据我们的分析，移植工作量巨大。这也意味着若需保持工具更新，必须持续进行移植。同时，我们观察到针对不同场景开发了多种模糊测试工具。移植所有工具难度极大。即使可以移植所有的模糊测试工具，由于固件执行环境的限制，例如ROM容量、SRAM容量、DRAM容量、存储空间及CPU处理能力，仍很难运行工具。模糊测试工具可能运行失败或速度极慢。

<div align=center><img src=Figures/Chapter-21-Screenshot/Figure-21-1.jpg></img></div>
<div align=center>图 21-1 在固件中运行的带有模糊测试工具的固件模糊测试</div>

2) 第二种方案是在固件中创建一个代理，让固件代理接收来自操作系统的模糊测试数据。操作系统模糊测试代理调用模糊测试工具生成模糊测试数据，并将数据从操作系统传输至固件代理。见图21-2。然而，此方案可能引发性能问题，因为时间会浪费在操作系统与UEFI之间的通信上。模糊测试通常需要生成海量数据，且需要运行好几天。若时间浪费在数据传输上，则模糊测试不够高效。

一种可能的变体方案是使虚拟机管理程序能够在单台本地机器上同时运行目标固件和操作系统模糊测试工具。这种方式可能比通过网络通信更快速，但我们需要推进移植工作，才能让虚拟机管理程序运行固件。

<div align=center><img src=Figures/Chapter-21-Screenshot/Figure-21-2.jpg></img></div>
<div align=center>图 21-2 伴随模糊测试代理通信的固件模糊测试</div>

3) 第三种方案是让固件目标函数在操作系统环境中运行，并直接使用操作系统的模糊测试工具。由于固件函数可能依赖固件专属服务，这些服务在操作系统中可能不可用，我们需要创建操作系统桩函数来提供该服务。若能实现这一点，则可直接复用操作系统模糊测试工具。见图21-3。此方案的优势在于能充分利用操作系统模糊测试工具的全部功能（例如仪器化模式），主机系统资源，包括内存容量、磁盘存储空间及主机CPU执行能力。这是速度最快的解决方案。

此选项的一个可能变体是在没有源代码的情况下，对二进制文件中的特定固件功能进行模糊测试。此时，必须仔细分析固件二进制文件并提供所有依赖服务。该方法的优势在于无需源代码即可测试任何固件二进制文件，但会丧失仪器化模糊测试的优势，且速度远低于基于源代码的测试方式。

<div align=center><img src=Figures/Chapter-21-Screenshot/Figure-21-3.jpg></img></div>
<div align=center>图 21-3 固件代码运行在操作系统中的固件模糊测试</div>

对于EDK II UEFI固件，我们引入了基于主机的固件分析器（HBFA）功能将特定的EDK II固件目标函数构建为操作系统应用程序，并使用模糊测试工具运行它。图21-4展示了基于HBFA的模糊测试用例设计。待测试的固件函数通过操作系统桩函数和测试主函数进行构建。

步骤1：使用操作系统模糊测试工具运行测试应用程序。

步骤2：模糊测试工具生成模糊数据，并将其作为输入参数传递给测试主函数。

步骤3：测试主函数根据模糊测试数据为固件函数设置外部输入数据。

步骤4：测试主函数触发待测固件函数。

步骤5：固件函数调用操作系统桩函数获取外部输入。此处外部输入可以是通信缓冲区、签名固件胶囊镜像、PE/COFF可执行镜像、启动镜像文件、文件系统、网络数据包、USB描述符、蓝牙低功耗广播数据等。随后固件函数可以调用操作系统桩写入输出数据。

步骤6：测试主函数可依据测试预言机验证输出数据。同时，可为测试应用启用消毒器，以检测运行时是否存在违规行为。

<div align=center><img src=Figures/Chapter-21-Screenshot/Figure-21-4.jpg></img></div>
<div align=center>图 21-4 HBFA模糊测试用例设计</div>

### 符号化执行

某些模糊测试工具需要已知的有效种子进行变异，模糊数据正是基于这些种子生成的。即使种子是可选的，优质种子也能有效提升模糊测试的效率。获取种子有多种方式。可通过空种子确定种子值，从互联网下载种子，使用现有系统配置作为种子，或借助工具生成种子。最后一种方式可通过符号执行工具实现，例如KLEE。

在常规执行过程中，程序读取具体输入值并处理执行流程，例如赋值、加法、乘法和条件分支，直至生成具体最终答案。然而，在符号执行过程中，程序读取符号值并处理执行流程。此时仍可执行赋值、加法和乘法操作，但遇到条件分支时，符号执行会通过分叉路径同时执行两个分支。每条路径获得程序状态的副本，在路径约束下以符号化方式独立执行。此处的路径约束指使程序在分支条件中选择特定路径的具体数值。当路径终止时，符号执行通过求解分支条件上累积的路径约束来计算具体数值。所有路径终止后，符号执行收集所有具体数值。这些数值可视为覆盖给定程序所有可能路径的测试用例。

考虑清单21-1中的函数。符号化执行将“buf”作为符号输入值，并将“buf[0] * 4”赋值给“a”，将“buf[4] * 8”赋值给“c”。在第一个if分支中，它评估“buf[0] * 4 < 0”并分叉两条路径：buf[0] < 0和buf[0] >= 0。在第二个if分支中，它评估“buf[4] * 8 == 24”并分叉两条路径：buf[4] == 3和buf[4] != 3。程序终止时，符号化执行可生成三种不同情况：(buf[0] < 0)、(buf[0] >= 0 && buf[4] == 3) 以及 (buf[0] >= 0 && buf[4] != 3)。最终结果对模糊测试工具的种子生成至关重要。若缺少该结果，模糊工具可能需要耗费大量时间才能生成buf[4]=3的值以覆盖第二条路径。

清单 20-1

```
int test (int *buf)
{
    int a = buf[0] * 4;
    int c = buf[4] * 8;
    if (a < 0) {
        return -1;
    } else {
        if (c == 24) {
            return 4;
        } else {
            return 1;
        }
    }
}
```

符号执行是一种分析程序的方法，用于确定哪些输入会触发程序的各个部分执行。完成符号执行后，它能生成覆盖程序所有可能路径的测试用例。这些测试用例可作为模糊测试工具的种子。随后模糊测试工具便能基于这些种子变异模糊测试数据。见图21-5，该方案将KLEE符号化执行作为种子生成器，AFL模糊测试工具作为模糊引擎进行组合。

<div align=center><img src=Figures/Chapter-21-Screenshot/Figure-21-5.jpg></img></div>
<div align=center>图 21-5 AFL Fuzz + KLEE</div>

符号执行是生成种子的一种有效方法，但存在局限性。由于符号执行需要根据每个分支条件分叉状态，随着程序规模的增大，需要维护的状态数量呈指数级增长。对于复杂程序，生成所有路径的最终结果可能耗时极长，某些情况下甚至可能陷入无限循环或引发异常。

### 形式验证

形式验证是一种技术，通过数学形式方法证明系统中代码相对于特定规范或预定义属性的正确性。形式验证的方法是模型检查，即对数学模型进行系统性穷尽性探索。符号执行是形式验证中可采用的一种实现方法。Spin是一款开源的软件验证工具，用于多线程软件应用程序的形式验证。C语言有界模型检查器（CBMC）是一种针对C和C++程序的有界模型检查器，可验证内存安全（包括数组边界检查和指针安全使用检查）、异常检查、各类未定义行为变体检查，以及用户指定的断言。

模型检查工具用检查给定模型是否满足一组程序属性。以清单21-2为例。该程序解析输入参数argc和argv。在程序末尾，添加了一条断言作为属性。当我们对该程序运行CBMC时，CBMC将报告该断言能否成功。除断言外，CBMC还包括内置的仪器化选项，例如边界检查、指针检查、溢出检查等，用于捕获潜在的内存安全问题。

清单 21-2

```
#define MAX_NUM 100

void process_arg (void *arg)
{
    // do something
}

int main(int argc, void **argv) {
    int x = argc;
    int i = 0;
    while (i < argc && i < MAX_NUM && i >= 0) {
        process_arg (argv[i]);
        i = i + 1;
        x = x - 1;
    }
    __CPROVER_assert(x >= 0, "postcondition");
}
```

由于软件程序的复杂性，通过形式化验证的软件项目并不多见。编写一套完整的程序属性集同样是项艰巨的工作。部分操作系统已完成验证，例如安全嵌入式L4内核（seL4）。某些网络协议栈也已通过验证，例如Everest项目中的验证过的HTTPS协议栈。