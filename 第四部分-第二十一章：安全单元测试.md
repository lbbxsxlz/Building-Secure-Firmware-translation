## 第二十一章

# 安全单元测试

在完成所有代码开发工作后，我们需要进行安全测试。通常开发人员需先执行安全单元测试，再将代码交付给测试团队。此时，测试团队需开展更全面的系统级安全测试。市面上有大量介绍软件测试技术的书籍，本章将不再赘述相关内容。相反，在本章，我们将从开发人员视角聚焦固件特有的安全单元测试。在下一章，我们将从测试工程师视角探讨固件特有的系统安全测试。

## 安全单元测试计划

在第二章中，我们探讨了主动式固件安全开发的整体理念，并阐述了威胁模型。安全单元测试应聚焦于威胁模型，以验证已识别的威胁是否得到妥善缓解。我们还指出了固件中的八个高风险区域，并提供了安全代码审查的指导原则。表21-1展示了针对这些区域的安全单元测试。

表 20-1 针对8个高分线区域的安全单元测试

|  类别  |  安全单元测试  |
| :----- | :----- |
| 外部输入 | 识别外部输入 —— SMM通信缓冲区、UEFI变量、固件镜像和胶囊镜像、启动BMP文件、PE/COFF镜像（例如一个操作系统引导加载程序和PCI选项ROM）、文件系统、磁盘镜像、网络数据包等。<br>识别处理外部输入的功能 —— 边界函数。识别执行外部输入检查的功能 —— 检查函数。<br>使用不同输入测试检查函数。<br>验证检查函数的输出结果。|
| 竞争条件 | 识别关键资源 —— SMM通信缓冲区、锁定的硅寄存器等。<br>识别处理关键资源的功能。创建访问关键资源的竞争条件场景。<br>验证关键资源的结果。|
| 硬件输入 | 识别硬件输入 —— 读写硅寄存器、内存映射输入/输出（MMIO）基址寄存器（BAR）、USB描述符、蓝牙低功耗（BLE）广播数据、DMA、缓存等。<br>识别处理硬件输入的函数。<br>识别执行硬件输入检查的函数 —— 检查函数 —— 或识别预防攻击的函数 —— 锁定函数。<br>模拟硬件输入，例如MMIO BAR、USB、BLE等，并测试检查函数。<br>验证检查函数的输出结果。<br>验证锁定函数能否正确执行锁定操作，例如DMA或SMM缓存等。|
| 秘密处理 | 识别秘密/密码。<br>识别使用密钥的函数。<br>识别使用后清除密钥的函数。<br>确保所有路径中的秘密均被清除。<br>若需保存秘密，识别对其进行哈希或加密的函数。<br>识别默认秘密/密码处理机制。<br>验证是否遵循侧信道指南。|
| 寄存器锁定 | 识别需要锁定的寄存器，例如闪存锁定和SMM锁定。<br>识别锁定寄存器的函数。<br>识别控制锁定的策略，例如策略协议或变量。<br>确保最终用户无法控制策略。<br>确保锁定操作在所有启动路径中均会发生。<br>确保锁定操作在任何第三方代码运行之前完成。|
| 安全配置 | 识别控制安全配置的策略，例如安全启动和可测量启动。<br>确保未经授权的最终用户无法更新安全配置。<br>确保默认配置是安全的。|
| 重放/回滚 | 识别安全版本号（SVN）或最低支持版本号（LSN）。<br>识别SVN或LSN的存储位置。<br>确保未经授权的最终用户无法更新SVN或LSN。识别执行版本检查的函数。|
| 密码学 | 识别固件中的加密的用途，例如签名验证或数据加密。<br>识别固件中使用的加密的算法。<br>确保加密算法遵循政府和企业的最新指南，不得使用任何已弃用的算法。<br>确保密钥长度符合政府和企业的最新指南，不得使用过短的密钥长度。<br>识别密钥生成函数和密钥撤销函数。<br>识别密钥存储。<br>
识别用于保障密钥存储完整性与或保密性的保护机制。<br>仅授权用户可更新密钥。<br>验证是否遵循侧信道防护指南来保障密钥保密性。<br>确保签名验证函数能处理密钥缺失或签名缺失的情况。|

对于可能涉及多个高风险区域的解决方案，必须格外谨慎。以基于SMM的固件更新为例，固件更新镜像属于外部输入（#1）。该镜像被放入SMM通信缓冲区，可能存在潜在的检查时间/使用时间攻击（#2）。闪存更新功能需解锁闪存，这为竞争条件攻击（#2）留下了可能。SMM环境需要被保护来预防DMA或SMM缓存攻击（#3）。
启动期间应锁定闪存设备来预防未授权更新（#5）。固件更新功能需检查固件的SVN来预防回滚攻击（#7）。新固件镜像必须采用正确密钥长度的正确的加密算法进行签名（#8）。

为验证开发代码是否遵循第14章介绍的通用安全编码规范，可采用静态代码分析或动态代码分析。在第16章，我们介绍了各类编译器防御技术来消除潜在的漏洞，包括Klocwork和Coverity静态分析工具，同时阐述了地址消毒器与未定义行为消毒器。

## 高级的安全单元测试

通常，对于安全单元测试，我们可能需要编写测试函数，通过不同输入调用目标函数，以评估其运行是否正常，特别是测试目标函数处理外部输入（#1）和硬件输入（#3）的能力。这种方法最大的问题在于，我们无法确定生成的输入是否足以覆盖所有情况。

传统上，等价类分区（ECP）是消除冗余的有效方法，它将输入数据划分为合理数量的分区。此时只需设计覆盖所有分区的测试用例即可。然而，尽管ECP是必要的，但它不足以保障安全单元测试的充分性，因为ECP的前提条件我们能够定义一组覆盖所有情况的分区。对于简单函数这或许可行，但在实践中，很难对复杂数据结构定义一套完整的ECP分区集，例如文件系统，可执行文件格式或网络数据包。因此我们需要其他方法。

### 模糊测试

模糊测试，也称模糊测试法，是一种自动化测试技术。模糊测试工具能自动生成无效、意外或随机数据，作为目标函数调用的输入值。模糊测试的最大优势之一在于它使开发人员无需创建等价类分区或测试用例。然而模糊测试存在测试预言者问题 —— 测试必须能够区分预期（正常）与意外（存在缺陷）的程序行为。意外行为包括以下情况：

1) 崩溃、挂死或断言是模糊测试中简单而客观的衡量标准。若观察到这些行为，则目标函数必然存在问题。
2) 模糊测试还可能触发其他难以检测的问题，例如缓冲区越界访问、释放后使用或内存泄漏。为捕获此类故障，模糊测试通常需与其他检测工具协同使用，例如地址消毒器、未定义行为消毒器、内存消毒器或泄漏消毒器。
3) 最后同样重要的是，模糊测试可能导致程序返回意外或错误结果。因此开发者需为程序的最终结果或终态编写断言。

模糊测试是一种测试技术。它独立于执行环境，可应用于操作系统应用程序、操作系统内核甚至固件。如今，大多数模糊测试工具，例如Peach、American Fuzzy Lop（AFL）和LibFuzzer，都在操作系统环境中运行。但固件运行于特殊执行环境，并且该环境不提供操作系统级应用程序接口（API）或标准C库。这引发关键问题：如何运行模糊测试工具来检测固件代码？

表21-2列举了不同的固件模糊测试机制。

表 20-1 固件模糊测试机制

|  机制  |  作用  |  优点  |   缺点  |
| :----- | :----- | :----- | :----- |
| 1. 在固件环境中运行固件功能与模糊测试工具。| 移植模糊测试工具到固件中运行。| 不需要修改固件代码。| 移植模糊测试工具需要付出巨大努力。可能存在环境限制，例如内存大小、存储空间和CPU处理能力。|
| 2. 在固件环境中运行固件功能，在操作系统中运行模糊测试工具。| a. 创建固件代理和操作系统代理，用于通过网络对固件与操作系统之间的数据传输进行模糊测试。| 不需要修改模糊测试工具。不需要修改固件代码。| 耗费时间在模糊数据传输上。|
|        | b. 使用虚拟机监控程序实现固件功能与操作系统模糊测试工具之间的数据通信。| 比通过网络进行模糊测试的数据传输更快。| 需要启动虚拟机监控程序来运行目标固件。|
| 3. 在操作系统环境中运行固件功能和模糊测试工具。| a. 移植固件功能到操作系统，并在操作系统上执行模糊测试。| 无需修改模糊测试工具。可通过模糊测试编译器充分利用已插桩的代码。这是最快的解决方案。| 需要付出努力来为固件功能创建系统桩。|
|        | b. 分析固件二进制文件并对目标函数进行模糊测试。| 无需移植固件。| 二进制分析耗时。也需要创建桩函数。|